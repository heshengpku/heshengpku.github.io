<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>以太坊私有链搭建操作指南</title>
    <url>/2017/11/01/Ethereum/</url>
    <content><![CDATA[<p>来源：https://my.oschina.net/u/2349981/blog/865256
作者：dophin459</p>
<p>虽然以太坊是一个公有链系统，但是我们可以通过设置一些参数来运行自己的私有链节点，在自己的私有链上进行开发和测试不需要同步公有链数据，也不需要花钱来买以太币，节省存储空间和成本，而且很灵活很方便。本文介绍使用<code>geth</code>客户端搭建私有链的操作步骤，同时会解释在这个过程中用到的各个命令及选项的含义和作用，最后会介绍<code>geth</code>的<code>Javascript Console</code>中的一些常用功能。</p>
<span id="more"></span>
<h2 id="系统和软件">系统和软件</h2>
<ul>
<li>Ubuntu 16.04 64位</li>
<li>geth 1.5.6 =&gt;(<a
href="https://my.oschina.net/u/2349981/blog/856956">安装教程</a>)</li>
</ul>
<h2 id="搭建私有链">搭建私有链</h2>
<h3 id="一准备创世区块配置文件">一、准备创世区块配置文件</h3>
<p>以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。首先将下面的内容保存到一个json文件中，例如<code>genesis.json</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;coinbase&quot;</span>   <span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;difficulty&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0x400&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;extraData&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;0x0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gasLimit&quot;</span>   <span class="punctuation">:</span> <span class="string">&quot;0x2fefd8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nonce&quot;</span>      <span class="punctuation">:</span> <span class="string">&quot;0xdeadbeefdeadbeef&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mixhash&quot;</span>    <span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;parentHash&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;0x00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alloc&quot;</span>      <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="二初始化写入创世区块">二、初始化：写入创世区块</h3>
<p>准备好创世区块配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录用来存放区块链数据，假设新建的数据目录为<code>~/privatechain/data0</code>，<code>genesis.json</code>保存在<code>~/privatechain</code>中，此时目录结构应该是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">privatechain</span><br><span class="line">├── data0</span><br><span class="line">└── genesis.json</span><br></pre></td></tr></table></figure>
<p>接下来进入<code>privatechain</code>中，执行初始化命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> privatechain</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">geth --datadir data0 init genesis.json</span></span><br></pre></td></tr></table></figure>
<p>上面的命令的主体是<code>geth init</code>，表示初始化区块链，命令可以带有选项和参数，其中<code>--datadir</code>选项后面跟一个目录名，这里为<code>data0</code>，表示指定数据存放目录为<code>data0</code>，<code>genesis.json</code>是<code>init</code>命令的参数。</p>
<p>运行上面的命令，会读取<code>genesis.json</code>文件，根据其中的内容，将创世区块写入到区块链中。如果看到以下的输出内容，说明初始化成功了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">I0322 10:52:44.585282 cmd/geth/chaincmd.go:131] successfully wrote genesis block and/or chain rule set: b240e0678c2a8f87cf350225b528e3d97688aad6d4d84ee84e405c7fc9e37e4e</span><br></pre></td></tr></table></figure>
<p>初始化成功后，会在数据目录<code>data0</code>中生成<code>geth</code>和<code>keystore</code>两个文件夹，此时目录结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">privatechain</span><br><span class="line">├── data0</span><br><span class="line">│   ├── geth</span><br><span class="line">│   │   └── chaindata</span><br><span class="line">│   │       ├── 000002.log</span><br><span class="line">│   │       ├── CURRENT</span><br><span class="line">│   │       ├── LOCK</span><br><span class="line">│   │       ├── LOG</span><br><span class="line">│   │       └── MANIFEST-000003</span><br><span class="line">│   └── keystore</span><br><span class="line">└── genesis.json</span><br></pre></td></tr></table></figure>
<p>其中<code>geth/chaindata</code>中存放的是区块数据，<code>keystore</code>中存放的是账户数据。</p>
<h4 id="三启动私有链节点">三、启动私有链节点</h4>
<p>初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">geth --datadir data0 --networkid 1108 console</span></span><br></pre></td></tr></table></figure>
<p>上面命令的主体是<code>geth console</code>，表示启动节点并进入交互式控制台，<code>--datadir</code>选项指定使用<code>data0</code>作为数据目录，<code>--networkid</code>选项后面跟一个数字，这里是<code>1108</code>，表示指定这个私有链的网络id为<code>1108</code>。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id。</p>
<p>运行上面的命令后，就启动了区块链节点并进入了<code>Javascript Console</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Welcome to the Geth JavaScript console!</span><br><span class="line"></span><br><span class="line">instance: Geth/v1.5.6-stable/linux/go1.7.3</span><br><span class="line">    modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中<code>&gt;</code>是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eth：包含一些跟操作区块链相关的方法</span><br><span class="line">net：包含以下查看p2p网络状态的方法</span><br><span class="line">admin：包含一些与管理节点相关的方法</span><br><span class="line">miner：包含启动&amp;停止挖矿的一些方法</span><br><span class="line">personal：主要包含一些管理账户的方法</span><br><span class="line">txpool：包含一些查看交易内存池的方法</span><br><span class="line">web3：包含了以上对象，还包含一些单位换算的方法</span><br></pre></td></tr></table></figure>
<h2 id="探索javascript-console">探索<code>Javascript Console</code></h2>
<p>进入以太坊<code>Javascript Console</code>后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。
接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在<code>Javascript Console</code>中执行的命令。</p>
<h3 id="一创建账户">一、创建账户</h3>
<p>前面只是搭建了私有链，并没有自己的账户，可以在<code>js console</code>中输入<code>eth.accounts</code>来验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.accounts</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>接下来使用<code>personal</code>对象来创建一个账户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">personal.newAccount()</span></span><br><span class="line">Passphrase:</span><br><span class="line">Repeat passphrase:</span><br><span class="line">&quot;0xc232e2add308136571bb8f9197ba4ae4e5ba9836&quot;</span><br></pre></td></tr></table></figure>
<p>会提示输入密码和确认密码，输入密码不会有显示，只要输入就可以了，之后就会显示新创建的账户地址。</p>
<p>可以创建多个账户，我们再来创建一个账户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">personal.newAccount()</span></span><br><span class="line">Passphrase:</span><br><span class="line">Repeat passphrase:</span><br><span class="line">&quot;0x814d39aa21f3eed069f2b21da7b5f857f7343afa&quot;</span><br></pre></td></tr></table></figure>
<p>接下来就可以查看到刚才创建的两个账户了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.accounts</span></span><br><span class="line">[&quot;0xc232e2add308136571bb8f9197ba4ae4e5ba9836&quot;, &quot;0x814d39aa21f3eed069f2b21da7b5f857f7343afa&quot;]</span><br></pre></td></tr></table></figure>
<p>账户默认会保存在数据目录的<code>keystore</code>文件夹中。查看目录结构，发现<code>data0/keystore</code>中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">data0</span><br><span class="line">├── geth</span><br><span class="line">│   ├── chaindata</span><br><span class="line">│   ├── LOCK</span><br><span class="line">│   ├── nodekey</span><br><span class="line">│   └── nodes</span><br><span class="line">├── geth.ipc</span><br><span class="line">├── history</span><br><span class="line">└── keystore</span><br><span class="line">    ├── UTC--2017-03-22T09-06-47.766993033Z--c232e2add308136571bb8f9197ba4ae4e5ba9836</span><br><span class="line">    └── UTC--2017-03-22T09-09-42.041015656Z--814d39aa21f3eed069f2b21da7b5f857f7343afa</span><br></pre></td></tr></table></figure>
<p>小提示：命令都可以按<code>Tab</code>键自动补全。</p>
<h3 id="二查看账户余额">二、查看账户余额</h3>
<p>eth对象提供了查看账户余额的方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getBalance(eth.accounts[0])</span></span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getBalance(eth.accounts[1])</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。</p>
<h4 id="三启动停止挖矿">三、启动&amp;停止挖矿</h4>
<p>通过<code>miner.start()</code>来启动挖矿：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">miner.start(1)</span></span><br></pre></td></tr></table></figure>
<p>其中<code>start</code>的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</p>
<p>如果想停止挖矿，在<code>js console</code>中输入<code>miner.stop()</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">miner.stop()</span></span><br></pre></td></tr></table></figure>
<p>注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的<code>miner.stop()</code>之后回车，即可停止挖矿。</p>
<p>挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.coinbase</span></span><br><span class="line">&quot;0xc232e2add308136571bb8f9197ba4ae4e5ba9836&quot;</span><br></pre></td></tr></table></figure>
<p>现在的coinbase是账户0，要想使挖矿奖励进入其他账户，通过<code>miner.setEtherbase()</code>将其他账户设置成coinbase即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">miner.setEtherbase(eth.accounts[1])</span></span><br><span class="line">true</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.coinbase</span></span><br><span class="line">&quot;0x814d39aa21f3eed069f2b21da7b5f857f7343afa&quot;</span><br></pre></td></tr></table></figure>
<p>我们还是以账户0作为coinbase，挖到区块以后，账户0里面应该就有余额了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getBalance(eth.accounts[0])</span></span><br><span class="line">160000000000000000000</span><br></pre></td></tr></table></figure>
<p><code>getBalance()</code>返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用<code>web3.fromWei()</code>将返回值换算成以太币：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">web3.fromWei(eth.getBalance(eth.accounts[0]),<span class="string">&#x27;ether&#x27;</span>)</span></span><br><span class="line">160</span><br></pre></td></tr></table></figure>
<h3 id="四发送交易">四、发送交易</h3>
<p>目前，账户一的余额还是0：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getBalance(eth.accounts[1])</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>可以通过发送一笔交易，从账户0转移5个以太币到账户1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">amount = web3.toWei(5,<span class="string">&#x27;ether&#x27;</span>)</span></span><br><span class="line">&quot;5000000000000000000&quot;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span></span><br><span class="line">Error: account is locked</span><br><span class="line">    at web3.js:3119:20</span><br><span class="line">    at web3.js:6023:15</span><br><span class="line">    at web3.js:4995:36</span><br><span class="line">    at &lt;anonymous&gt;:1:1</span><br></pre></td></tr></table></figure>
<p>这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">personal.unlockAccount(eth.accounts[0])</span></span><br><span class="line">Unlock account 0xc232e2add308136571bb8f9197ba4ae4e5ba9836</span><br><span class="line">Passphrase:</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">amount = web3.toWei(5,<span class="string">&#x27;ether&#x27;</span>)</span></span><br><span class="line">&quot;5000000000000000000&quot;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)</span></span><br><span class="line">I0322 19:39:36.300675 internal/ethapi/api.go:1047] Tx(0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825) to: 0x814d39aa21f3eed069f2b21da7b5f857f7343afa</span><br><span class="line">&quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;</span><br></pre></td></tr></table></figure>
<p>此时交易已经提交到区块链，返回了交易的hash，但还未被处理，这可以通过查看<code>txpool</code>来验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">txpool.status</span></span><br><span class="line">&#123;</span><br><span class="line">    pending: 1,</span><br><span class="line">    queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一条pending的交易，pending表示已提交但还未被处理的交易。</p>
<p>要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">miner.start(1);admin.sleepBlocks(1);miner.stop();</span></span><br></pre></td></tr></table></figure>
<p>当<code>miner.stop()</code>返回true后，<code>txpool</code>中pending的交易数量应该为0了，说明交易已经被处理了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">txpool.status</span></span><br><span class="line">&#123;</span><br><span class="line">    pending: 0,</span><br><span class="line">    queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，交易已经生效，账户一应该已经收到了5个以太币了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">web3.fromWei(eth.getBalance(eth.accounts[1]),<span class="string">&#x27;ether&#x27;</span>)</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="五查看交易和区块">五、查看交易和区块</h3>
<p><code>eth</code>对象封装了查看交易和区块信息的方法。</p>
<p>查看当前区块总数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.blockNumber</span></span><br><span class="line">33</span><br></pre></td></tr></table></figure>
<p>通过交易hash查看交易：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getTransaction(<span class="string">&quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    blockHash: &quot;0xf5d3da50065ce5793c9571a031ad6fe5f1af326a3c4fb7ce16458f4d909c1613&quot;,</span><br><span class="line">    blockNumber: 33,</span><br><span class="line">    from: &quot;0xc232e2add308136571bb8f9197ba4ae4e5ba9836&quot;,</span><br><span class="line">    gas: 90000,</span><br><span class="line">    gasPrice: 20000000000,</span><br><span class="line">    hash: &quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;,</span><br><span class="line">    input: &quot;0x&quot;,</span><br><span class="line">    nonce: 0,</span><br><span class="line">    r: &quot;0x433fe5845391b6da3d8aa0d2b53674e09fb6126f0070a600686809b57e4ef77d&quot;,</span><br><span class="line">    s: &quot;0x6b0086fb76c46024f849141074a5bc79c49d5f9a658fd0fedbbe354889c34d8d&quot;,</span><br><span class="line">    to: &quot;0x814d39aa21f3eed069f2b21da7b5f857f7343afa&quot;,</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    v: &quot;0x1b&quot;,</span><br><span class="line">    value: 5000000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过区块号查看区块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getBlock(33)</span></span><br><span class="line">&#123;</span><br><span class="line">    difficulty: 132928,</span><br><span class="line">    extraData: &quot;0xd783010506846765746887676f312e372e33856c696e7578&quot;,</span><br><span class="line">    gasLimit: 3244382,</span><br><span class="line">    gasUsed: 21000,</span><br><span class="line">    hash: &quot;0xf5d3da50065ce5793c9571a031ad6fe5f1af326a3c4fb7ce16458f4d909c1613&quot;,</span><br><span class="line">    logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">    miner: &quot;0xc232e2add308136571bb8f9197ba4ae4e5ba9836&quot;,</span><br><span class="line">    mixHash: &quot;0x09849dff7c8b8467812fa80d1fa2a27bc61f1cf16d5b2c05a6ce1b77ee18f3f1&quot;,</span><br><span class="line">    nonce: &quot;0x5b3939449dbdbea0&quot;,</span><br><span class="line">    number: 33,</span><br><span class="line">    parentHash: &quot;0xeca34637642f56f7cfe5b699031c7ddbc43aee00fb10c7f054e0a9719cf226da&quot;,</span><br><span class="line">    receiptsRoot: &quot;0xd5f5b7ee944e57cbff496f7bdda7ceffd5eedffe6d5be5320008190502adc07a&quot;,</span><br><span class="line">    sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</span><br><span class="line">    size: 649,</span><br><span class="line">    stateRoot: &quot;0xc7add6b756980ab9e482766e455597ef1583e747ad62e2924a8e66c6f9170112&quot;,</span><br><span class="line">    timestamp: 1490183209,</span><br><span class="line">    totalDifficulty: 4358016,</span><br><span class="line">    transactions: [&quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;],</span><br><span class="line">    transactionsRoot: &quot;0x7335a362b2c3925e7ba1b41bf7772aa9645a13d4f9c12edd5892b87887264232&quot;,</span><br><span class="line">    uncles: []EthereumEthereum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有更多的功能请自行探索...。</p>
<h3 id="六连接到其他节点">六、连接到其他节点</h3>
<p>可以通过<code>admin.addPeer()</code>方法连接到其他节点，两个节点要想联通，必须保证网络是相通的，并且要指定相同的networkid。</p>
<p>假设有两个节点：节点一和节点二，networkid都是1108，通过下面的步骤就可以从节点一连接到节点二。</p>
<p>首先要知道节点二的enode信息，在节点二的<code>js console</code>中执行下面的命令查看enode信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">admin.nodeInfo.enode</span></span><br><span class="line">&quot;enode://9e86289ea859ca041f235aed87a091d0cd594b377cbe13e1c5f5a08a8a280e62d4019ac54063ed6a1d0e3c3eaedad0b73c40b99a16a176993f0373ffe92be672@[::]:30304&quot;</span><br></pre></td></tr></table></figure>
<p>然后在节点一的<code>js console</code>中执行<code>admin.addPeer()</code>，就可以连接到节点二：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">admin.addPeer(<span class="string">&quot;enode://9e86289ea859ca041f235aed87a091d0cd594b377cbe13e1c5f5a08a8a280e62d4019ac54063ed6a1d0e3c3eaedad0b73c40b99a16a176993f0373ffe92be672@127.0.0.1:30304&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>addPeer()</code>的参数就是节点二的enode信息，注意要把enode中的<code>[::]</code>替换成节点二的IP地址。连接成功后，节点二就会开始同步节点一的区块，同步完成后，任意一个节点开始挖矿，另一个节点会自动同步区块，向任意一个节点发送交易，另一个节点也会收到该笔交易。</p>
<p>通过<code>admin.peers</code>可以查看连接到的其他节点信息，通过<code>net.peerCount</code>可以查看已连接到的节点数量。</p>
<p>除了上面的方法，也可以在启动节点的时候指定<code>--bootnodes</code>选项连接到其他节点。</p>
<h2 id="以太坊源码剖析交易"><a
href="https://bitshuo.com/topic/5948897c8e822fcb444317d0">以太坊源码剖析：交易</a></h2>
<p>交易是区块链中最基本也是最核心的一个概念，在以太坊中，交易更是重中之重，因为以太坊是一个智能合约平台，以太坊上的应用都是通过智能合约与区块链进行交互，而智能合约的执行是由交易触发的，没有交易，智能合约就是一段死的代码，可以说在以太坊中，一切都源于交易。下面就来看看在以太坊中交易是什么样的，交易里面都有什么。
交易的数据结构</p>
<p>在core/types/transaction.go中定义了交易的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">    data txdata</span><br><span class="line">    <span class="comment">// caches</span></span><br><span class="line">    hash atomic.Value</span><br><span class="line">    size atomic.Value</span><br><span class="line">    from atomic.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个结构体里面只有一个data字段，它是txdata类型的，其他的三个字段hash
size
from是缓存字段，txdata也是一个结构体，它里面定义了交易的具体的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">    AccountNonce    <span class="type">uint64</span></span><br><span class="line">    Price, GasLimit *big.Int</span><br><span class="line">    Recipient       *common.Address <span class="string">`rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line">    Amount          *big.Int</span><br><span class="line">    Payload         []<span class="type">byte</span></span><br><span class="line">    V               *big.Int <span class="comment">// signature</span></span><br><span class="line">    R, S            *big.Int <span class="comment">// signature</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各字段的含义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">AccountNonce：此交易的发送者已发送过的交易数</span><br><span class="line">Price：此交易的gas price</span><br><span class="line">GasLimit：本交易允许消耗的最大gas数量</span><br><span class="line">Recipient：交易的接收者，是一个地址</span><br><span class="line">Amount：交易转移的以太币数量，单位是wei</span><br><span class="line">Payload：交易可以携带的数据，在不同类型的交易中有不同的含义</span><br><span class="line">V R S：交易的签名数据</span><br></pre></td></tr></table></figure>
<p>注意：这里并没有一个字段来指明交易的发送者，因为交易的发送者地址可以从签名中得到。</p>
<p>在transaction.go中还定义了一个jsonTransaction结构体，这个结构体用于将交易进行json序列化和反序列化，具体的序列化和反序列化可以参照MarshalJSON和UnmarshalJSON函数。以太坊节点会向外部提供JSON
RPC服务，供外部调用，RPC服务通过json格式传输数据，节点收到json数据后，会转换成内部的数据结构来使用。jsonTransaction结构体使用go语言的struct
tag特性指定了内部数据结构与json数据各字段的对应关系，例如内部的AccountNonce对应json的nonce，Amount对应json的value。web3.js的eth.getTransaction()和eth.sendTransaction()使用的数据就是json格式的，根据这个结构体就可以知道在web3.js中交易的各个字段与程序内部的各个字段的对应关系。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> jsonTransaction <span class="keyword">struct</span> &#123;</span><br><span class="line">    Hash         *common.Hash    <span class="string">`json:&quot;hash&quot;`</span></span><br><span class="line">    AccountNonce *hexutil.Uint64 <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">    Price        *hexutil.Big    <span class="string">`json:&quot;gasPrice&quot;`</span></span><br><span class="line">    GasLimit     *hexutil.Big    <span class="string">`json:&quot;gas&quot;`</span></span><br><span class="line">    Recipient    *common.Address <span class="string">`json:&quot;to&quot;`</span></span><br><span class="line">    Amount       *hexutil.Big    <span class="string">`json:&quot;value&quot;`</span></span><br><span class="line">    Payload      *hexutil.Bytes  <span class="string">`json:&quot;input&quot;`</span></span><br><span class="line">    V            *hexutil.Big    <span class="string">`json:&quot;v&quot;`</span></span><br><span class="line">    R            *hexutil.Big    <span class="string">`json:&quot;r&quot;`</span></span><br><span class="line">    S            *hexutil.Big    <span class="string">`json:&quot;s&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：Payload这个字段在eth.sendTransaction()中对应的是data字段，在eth.getTransaction()中对应的是input字段。
交易的Hash</p>
<p>下面是计算交易Hash的函数，它是先从缓存tx.hash中取，如果取到，就直接返回，如果缓存中没有，就调用rlpHash计算hash，然后把hash值加入到缓存中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hash hashes the RLP encoding of tx.</span></span><br><span class="line"><span class="comment">// It uniquely identifies the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> Hash() common.Hash &#123;</span><br><span class="line">    <span class="keyword">if</span> hash := tx.hash.Load(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hash.(common.Hash)</span><br><span class="line">    &#125;</span><br><span class="line">    v := rlpHash(tx)</span><br><span class="line">    tx.hash.Store(v)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rlpHash的代码在core/types/block.go中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rlpHash</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> (h common.Hash) &#123;</span><br><span class="line">    hw := sha3.NewKeccak256()</span><br><span class="line">    rlp.Encode(hw, x)</span><br><span class="line">    hw.Sum(h[:<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从rlpHash函数可以看出，计算hash的方法是先对交易进行RLP编码，然后计算RLP编码数据的hash，具体的hash算法是Keccak256。</p>
<p>那么到底是对交易中的哪些字段计算的hash呢？这就要看rlp.Encode对哪些字段进行了编码。rlp.Encode代码在rlp/encode.go中，不用看具体的实现，在注释中有这么一段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If the type implements the Encoder interface, Encode calls</span></span><br><span class="line"><span class="comment">// EncodeRLP. This is true even for nil pointers, please see the</span></span><br><span class="line"><span class="comment">// documentation for Encoder.</span></span><br></pre></td></tr></table></figure>
<p>就是说如果一个类型实现了Encoder接口，那么Encode函数就会调用那个类型所实现的EncodeRLP函数。所以我们就要看Transaction这个结构体是否实现了EncodeRLP函数。回到core/types/transaction.go中，可以看到Transaction确实实现了EncodeRLP函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DecodeRLP implements rlp.Encoder</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span> EncodeRLP(w io.Writer) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rlp.Encode(w, &amp;tx.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这可以看出交易的hash实际上是对tx.data进行hash计算得到的：txhash=Keccak256(rlpEncode(tx.data))。
交易的类型</p>
<p>在源码中交易只有一种数据结构，如果非要给交易分个类的话，我认为交易可以分为三种：转账的交易、创建合约的交易、执行合约的交易。web3.js提供了发送交易的接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(transactionObject [, callback])</span><br></pre></td></tr></table></figure>
<p>参数是一个对象，在发送交易的时候指定不同的字段，区块链节点就可以识别出对应类型的交易。
转账的交易</p>
<p>转账是最简单的一种交易，这里转账是指从一个账户向另一个账户发送以太币。发送转账交易的时候只需要指定交易的发送者、接收者、转币的数量。使用web3.js发送转账交易应该像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;</span>,</span><br><span class="line">    <span class="attr">to</span>: <span class="string">&quot;0xd46e8dd67c5d32be8058bb8eb970870f07244567&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">10000000000000000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>value是转移的以太币数量，单位是wei，对应的是源码中的Amount字段。to对应的是源码中的Recipient。
创建合约的交易</p>
<p>创建合约指的是将合约部署到区块链上，这也是通过发送交易来实现。在创建合约的交易中，to字段要留空不填，在data字段中指定合约的二进制代码，from字段是交易的发送者也是合约的创建者。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&quot;contract creator&#x27;s address&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&quot;contract binary code&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data字段对应的是源码中的Payload字段。 执行合约的交易</p>
<p>调用合约中的方法，需要将交易的to字段指定为要调用的合约的地址，通过data字段指定要调用的方法以及向该方法传递的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&quot;sender&#x27;s address&quot;</span>,</span><br><span class="line">    <span class="attr">to</span>: <span class="string">&quot;contract address&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&quot;hash of the invoked method signature and encoded parameters&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data字段需要特殊的编码规则，具体细节可以参考Ethereum Contract
ABI。自己拼接字段既不方便又容易出错，所以一般都使用封装好的SDK（比如web3.js）来调用合约。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">代码版本：1.5.9</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric chaincode开发调试</title>
    <url>/2018/01/02/Fabric-Chaincode/</url>
    <content><![CDATA[<p>链码（<code>Chaincode</code>）即<code>Fabric</code>中的智能合约，作为运行在<code>Fabric</code>区块链网络上的程序，链码在一般的运行模式下是运行在docker容器中的。
为了方便在开发中调试链码，可以使用开发模式。</p>
<ul>
<li>需要已经安装：<code>docker</code>、<code>docker-compose</code>和<code>Fabric</code>的相关镜像，
<code>Go</code>和<code>Fabric</code>的源码不是必需的，因为调试仍然是在<code>Fabric</code>镜像中进行。</li>
</ul>
<span id="more"></span>
<h3 id="首先下载官方提供的fabric-samples">1.
首先下载官方提供的fabric-samples：</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hyperledger/fabric-samples.git</span><br></pre></td></tr></table></figure>
<p>将需要调试的chaincode源码（比如<code>gocc</code>）放入链码目录（<code>fabric-samples/chaincode</code>）</p>
<p>如果要使用couchdb作为状态数据库,
应该在<code>docker-comose-simple.yaml</code>的<code>peer</code>环境变量中添加：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_STATEDATABASE=CouchDB</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:5984</span></span><br></pre></td></tr></table></figure> 在依赖中添加： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">orderer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">couchdb</span></span><br></pre></td></tr></table></figure> 并添加couchdb容器：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">couchdb:</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">couchdb</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-couchdb</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">5984</span><span class="string">:5984</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">DB_URL:</span> <span class="string">http://localhost:5984/member_db</span></span><br></pre></td></tr></table></figure></p>
<p>为了使用<code>DEBUG</code>模式调试链码，需要在<code>chaincode</code>容器中添加环境变量：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">CORE_CHAINCODE_LOGGING_LEVEL=DEBUG</span></span><br></pre></td></tr></table></figure></p>
<h4 id="打开终端1">2. 打开终端1</h4>
<p>启动网络： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd fabric-samples/chaincode-docker-devmode</span><br><span class="line">docker-compose -f docker-compose-simple.yaml up -d</span><br></pre></td></tr></table></figure></p>
<p>进入链码容器： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it chaincode bash</span><br></pre></td></tr></table></figure></p>
<p>编译链码（假设链码文件夹为<code>/gocc</code>） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd gocc</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>
启动链码： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./gocc</span><br></pre></td></tr></table></figure></p>
<h4 id="打开终端2">3. 打开终端2</h4>
<p>进入fabric客户端： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> 安装并实例化： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0</span><br><span class="line">peer chaincode instantiate -n mycc -v 0 -c &#x27;&#123;&quot;Args&quot;:[&quot;&quot;]&#125;&#x27; -C myc</span><br></pre></td></tr></table></figure> 调用
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode invoke -n mycc -v 0 -c &#x27;&#123;&quot;Args&quot;:[&quot;...&quot;]&#125;&#x27; -C myc</span><br></pre></td></tr></table></figure></p>
<p>查询 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode query -n mycc -v 0 -c &#x27;&#123;&quot;Args&quot;:[&quot;...&quot;]&#125;&#x27; -C myc</span><br></pre></td></tr></table></figure></p>
<h4 id="关闭网络">4. 关闭网络</h4>
<p>退出终端 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<p>关闭网络： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose-simple.yaml down</span><br></pre></td></tr></table></figure></p>
<p>删除<code>myc.block</code>文件，下次才能正常启动网络:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm myc.block</span><br></pre></td></tr></table></figure></p>
<h2 id="fabric-couchdb-实现排序查询">Fabric + CouchDB 实现排序查询</h2>
<p>在<a
href="localhost:5984/_utils">localhost:5984/_utils</a>可以打开<code>Fauxton</code>直接查看couchdb信息
为需要排序的字段创建索引文件（index），然后即可在网页客户端或者chaincode中的<code>rich query</code>中查询：
- 在<code>Design Documents</code>中添加<code>Mango Indexes</code> -
创建索引文件，例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;data.createTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;chaincodeid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;data.docType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ddoc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;indexTimeSortDoc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;indexTimeSortDesc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>即为<code>createTime</code>字段创建了一个默认反序排列的索引，其中<code>chaincode</code>与<code>docType</code>必不可少，<code>ddoc</code>与<code>name</code>的具体值随意</li>
<li>在<code>Run A Query with Mango</code>中即可实现正反序查询：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;selector&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;data.docType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typename&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;data.createTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;chaincodeid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;data.docType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意不同的字段排序方法需要创建不同的索引文件</li>
</ul>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
        <tag>Chaincode</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker命令整理</title>
    <url>/2017/10/01/Docker/</url>
    <content><![CDATA[<ul>
<li>Docker 容器镜像删除</li>
</ul>
<span id="more"></span>
<h2
id="停止所有的container这样才能够删除其中的images">1.停止所有的container，这样才能够删除其中的images：</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<p>如果想要删除所有container的话再加一个指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h2 id="查看当前有些什么images">2.查看当前有些什么images</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h2
id="删除images通过image的id来指定删除谁">3.删除images，通过image的id来指定删除谁</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;image id&gt;</span><br></pre></td></tr></table></figure>
<p>想要删除untagged
images，也就是那些id为&lt;None&gt;的image的话可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;&#123;print $3&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>要删除全部image的话</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>从大学数学到小学数学：从集合论证明算术基本定理</title>
    <url>/2022/10/17/FundArith/</url>
    <content><![CDATA[<p>2022年，通读了《陶哲轩实分析》一书。其从Peano公理出发，依次定义自然数、整数、有理数、实数和加减乘除、极限等运算，一气呵成、让人膜拜。</p>
<p>因为是关于数学分析的书，Tao只在第三章讲了集合论，而数理逻辑还在附录里。</p>
<p>但是我们常常听说“集合论是现代数学的基石”，那么理所当然是可以在定义数系之前，先做集合论的公理化。</p>
<p>因此我也想做一次尝试，在不做其他任何预设的情况下，完全从数学公理出发，进行一次“严谨的”推导。</p>
<p>当然有很多离散数学、集合论的课程就是这样做的。</p>
<p>不过个人能力有限，打算只证明一个小学生都知道的简单定理——算术基本定理，就收工。</p>
<span id="more"></span>
<p>内容主要涉及到4个部分：</p>
<ul>
<li>数理逻辑，可参照Kenneth H. Rosen的《离散数学及其应用》</li>
<li>集合论，可参照Herbert B. Enderton的《Elements of Set
Theory》和维基百科关于集合论公理化的词条</li>
<li>数系（只需要自然数和整数），可参照陶哲轩的《Analysis
I》即《陶哲轩实分析》的前4章、Herbert B. Enderton的《Elements of Set
Theory》</li>
<li>数论，可参照陈景润的《初等数论》（<em>这里要吐槽一下哈尔滨工业大学出版社，这本书出版得很“粗糙”，分三册然后几十页的后记重复三次先不说，还有我等凡夫俗子肉眼可见的错误、很多还是明显的排版错误就有一大堆，所以这也是“逼迫”我自己推导一次的动力吧</em>）</li>
</ul>
<h2 id="一数理逻辑">一、数理逻辑</h2>
<h3 id="命题逻辑">1）命题逻辑</h3>
<h4
id="定义命题是一个陈述句所表达的判断具有真值即这句话不是真的true就是假的false">定义：命题是一个陈述句所表达的判断，具有真值，即这句话不是真的（True）就是假的（False）。</h4>
<p>例如：“雪是白色的”。</p>
<p><strong>命题不等同于句子</strong>：例如，“雪是白色的”和“白色是雪的颜色”是不同的句子，但它们判断相同的事，所以是相同的命题。</p>
<p><strong>命题不依赖于语言</strong>：例如，“雪是白的”和“Snow is
white”是相同的判断。</p>
<p>疑问句、祈使句、感叹句都不能表达命题。</p>
<p>真值为“真”时，记作 T，为“假”时，记作 F。</p>
<h4 id="逻辑运算符">逻辑运算符</h4>
<ol type="1">
<li><p>（否定）逻辑“非”：如果命题<span
class="math inline">\(p\)</span>的真值为T，则<span
class="math inline">\(\neg p\)</span>为F，如果命题<span
class="math inline">\(p\)</span>的真值为F，则<span
class="math inline">\(\neg p\)</span>为T。</p></li>
<li><p>（合取）逻辑“与”：如果命题<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>的真值都为T，则<span
class="math inline">\(p\wedge q\)</span>为T。反之，如果命题<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>中有一个真值为F，则<span
class="math inline">\(p\wedge q\)</span>为F。</p></li>
<li><p>（析取）逻辑“或”：如果命题<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>中有一个真值为T，则<span
class="math inline">\(p\vee q\)</span>为T。反之，如果命题<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>的真值都为F，则为<span
class="math inline">\(p\vee q\)</span>为F。</p></li>
<li><p>（蕴涵）如果假定命题<span
class="math inline">\(p\)</span>的真值为T，可以推导出命题<span
class="math inline">\(q\)</span>也为T，则称命题<span
class="math inline">\(p\)</span>蕴涵<span
class="math inline">\(q\)</span>，记作<span
class="math inline">\(p\implies q\)</span>。</p></li>
</ol>
<p>利用命题和否定的定义，就可以得到数学证明中常用的反证法。</p>
<p><strong>反证法</strong>：给定一个命题<span
class="math inline">\(p\)</span>和它的否定命题<span
class="math inline">\(\neg
p\)</span>，则两者中如果一个是假的，另一个就必然是真的。所以在证明某一个命题<span
class="math inline">\(p\)</span>时，可以通过证明<span
class="math inline">\(\neg p\)</span>为假，从而“反过来”证明<span
class="math inline">\(p\)</span>为真。</p>
<p>关于<span class="math inline">\(p\implies q\)</span>，可以定义：</p>
<ul>
<li><span class="math inline">\(p\)</span>为<span
class="math inline">\(q\)</span>的充分条件</li>
<li><span class="math inline">\(q\)</span>为<span
class="math inline">\(p\)</span>的必要条件</li>
<li><span class="math inline">\(p\implies q\)</span>称为原命题</li>
<li><span class="math inline">\(q\implies p\)</span>称为逆命题</li>
<li><span class="math inline">\(\neg p\implies \neg
q\)</span>称为否命题</li>
<li><span class="math inline">\(\neg q\implies \neg
p\)</span>称为逆否命题</li>
</ul>
<p><strong>对于一个假命题<span
class="math inline">\(p\)</span>，即可推导出真命题，也可推导出假命题，所以<span
class="math inline">\(p\)</span>为假时，<span
class="math inline">\(p\implies q\)</span>是恒为真的。</strong></p>
<p>也就是说，如果以假命题为条件出发，推导得出的数字结论没有意义。</p>
<p>这也是为什么，现代数学这么强调公理化，并且对公理之间的兼容性吹毛求疵的原因。</p>
<p><strong>等价关系</strong>：如果<span class="math inline">\(p\implies
q\)</span>且<span class="math inline">\(q\implies
p\)</span>为真，则称命题<span class="math inline">\(p\)</span>与<span
class="math inline">\(q\)</span>等价，记作<span
class="math inline">\(p\iff q\)</span>，文字上常常写作“<span
class="math inline">\(p\)</span>当且仅当<span
class="math inline">\(q\)</span>”。</p>
<p>命题逻辑里最“简单”的证明方法就是使用真值表。</p>
<p>下面证明：如果<span class="math inline">\(p\)</span>与<span
class="math inline">\(q\)</span>等价，那么<span
class="math inline">\(p\)</span>为真且<span
class="math inline">\(q\)</span>为真，或者<span
class="math inline">\(p\)</span>为假且<span
class="math inline">\(q\)</span>为假，即<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>一定同真或同假。</p>
<p><code>证明</code>：根据定义，有<span class="math inline">\(p\iff
q\)</span>即<span class="math inline">\((p\implies q) \wedge (q\implies
p)\)</span>真值表： <span
class="math display">\[\begin{array}{c|c|c|c|c}
p&amp;q&amp;p\implies q&amp; q\implies p &amp; p\iff q \\\
T&amp;T&amp;T&amp;T&amp;T \\\
T&amp;F&amp;F&amp;T&amp;F \\\
F&amp;T&amp;T&amp;F&amp;F \\\
F&amp;F&amp;T&amp;T&amp;T
\end{array}\]</span></p>
<p>通过真值表可以看到，当<span class="math inline">\(p\iff
q\)</span>为T时，必须<span class="math inline">\(p\implies
q\)</span>和<span class="math inline">\(q\implies
p\)</span>同时为真，这时<span class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>只能是同真或同假。反之，当<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>同真或同假时，<span
class="math inline">\(p\iff q\)</span>也一定为真。<span
class="math inline">\(\square\)</span></p>
<p>下面证明：原命题与逆否命题等价。</p>
<p><code>证明</code>：根据蕴涵的定义，原命题的真值表为： <span
class="math display">\[\begin{array}{c|c|c}
q&amp; p &amp; q\implies p \\\
T&amp;T&amp;T \\\
T&amp;F&amp;F \\\
F&amp;T&amp;T \\\
F&amp;F&amp;T
\end{array}\]</span> 逆否命题的真值表为： <span
class="math display">\[\begin{array}{c|c|c|c|c}
p&amp;q&amp; \neg p &amp; \neg q &amp; \neg q\implies \neg p \\\
T&amp;T&amp;F&amp;F&amp;T \\\
T&amp;F&amp;F&amp;T&amp;F \\\
F&amp;T&amp;T&amp;F&amp;T\\\
F&amp;F&amp;T&amp;T&amp;T
\end{array}\]</span> 可以看到不论<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>的真假，原命题与逆否命题都同真或同假，所以原命题与逆否命题等价。<span
class="math inline">\(\square\)</span></p>
<h3 id="一阶逻辑">2）一阶逻辑</h3>
<p>一阶逻辑，又称谓词逻辑，和命题逻辑的不同之处在于，一阶逻辑包含<strong>量词</strong>：</p>
<ol type="1">
<li>存在：<span class="math inline">\(\exists\)</span></li>
<li>任意：<span class="math inline">\(\forall\)</span></li>
</ol>
<p>所以在一阶逻辑中，可以使用逻辑“变量”<span
class="math inline">\(x\)</span>。例如，命题<span
class="math inline">\(x+1=2\)</span>，只有在<span
class="math inline">\(x=1\)</span>时为真。</p>
<p>通过一阶逻辑，我们的数学表达能力大大提升了。</p>
<p>后续的公理，除了文字表述，我也尽量给出逻辑符号的形式化表述。</p>
<h3 id="相等公理">3）相等公理</h3>
<p>等价只是描述了两个命题的关系，而对于一般的数学对象，需要引入相等关系。</p>
<h4 id="自反公理对任意的对象x有xx">1.
<font color=red>（自反公理）对任意的对象<span
class="math inline">\(x\)</span>，有<span
class="math inline">\(x=x\)</span>。</font></h4>
<p><span class="math inline">\(\forall x : x=x\)</span></p>
<h4 id="对称公理对任意的对象x和y如果xy那么yx">2.
<font color=red>（对称公理）对任意的对象<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，如果<span
class="math inline">\(x=y\)</span>，那么<span
class="math inline">\(y=x\)</span>。</font></h4>
<p>$x, y : x=y y=x $</p>
<h4 id="传递公理对任意的对象xy和z如果xy且yz那么xz">3.
<font color=red>（传递公理）对任意的对象<span
class="math inline">\(x\)</span>、<span
class="math inline">\(y\)</span>和<span
class="math inline">\(z\)</span>，如果<span
class="math inline">\(x=y\)</span>且<span
class="math inline">\(y=z\)</span>，那么<span
class="math inline">\(x=z\)</span>。</font></h4>
<p>$x, y, z : x=y y=z x=z $</p>
<h4
id="替换公理对任意的对象x和y如果xy那么对任意一个关于x的命题px有px和py等价">4.
<font color=red>（替换公理）对任意的对象<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，如果<span
class="math inline">\(x=y\)</span>，那么对任意一个关于<span
class="math inline">\(x\)</span>的命题<span
class="math inline">\(P(x)\)</span>，有<span
class="math inline">\(P(x)\)</span>和<span
class="math inline">\(P(y)\)</span>等价。</font></h4>
<p>$x, y : x=y (P(x) P(y)) $</p>
<h2 id="二集合论">二、集合论</h2>
<p>通常理解，集合是由一些数学对象组成的整体。</p>
<p>构成集合<span class="math inline">\(A\)</span>的对象<span
class="math inline">\(a\)</span>称作“元素”或“成员”，记作<span
class="math inline">\(a \in A\)</span>。当元素<span
class="math inline">\(a\)</span>不属于集合<span
class="math inline">\(A\)</span>时，记作<span class="math inline">\(a
\notin A\)</span>。</p>
<h3 id="朴素集合论">1）朴素集合论</h3>
<p>在朴素集合论中，可以使用一个非常简练的概括公理完成集合论的定义，但是其中却存在着悖论。</p>
<p><strong>伪！（概括公理）</strong>：对任意一个关于<span
class="math inline">\(x\)</span>的命题<span
class="math inline">\(P(x)\)</span>，满足<span
class="math inline">\(P(x)\)</span>为真的对象<span
class="math inline">\(x\)</span>构成一个集合。</p>
<p><span class="math inline">\(\exists A, \forall x: x \in A \iff
P(x)\)</span></p>
<p>这个集合可以记作 <span class="math inline">\(A = \lbrace x | P(x)
\rbrace\)</span>。</p>
<p><font color=blue><strong>罗素悖论</strong>：不存在一个集合是由“所有不包括自身的集合”所组成的。</font></p>
<p><code>证明</code>：设命题<span
class="math inline">\(P(x)\)</span>为“所有不包括自身的集合<span
class="math inline">\(x\)</span>”，即<span class="math inline">\(x
\notin x\)</span>，根据概括公理，满足这个命题的对象<span
class="math inline">\(x\)</span>构成一个集合，设为集合<span
class="math inline">\(A = \lbrace x | x \notin x \rbrace\)</span>。
然后讨论命题<span class="math inline">\(A \in A\)</span>的真伪：
如果<span class="math inline">\(A \in A\)</span>为真，那么<span
class="math inline">\(A\)</span>是自身的元素，根据集合<span
class="math inline">\(A\)</span>的定义，则满足命题<span
class="math inline">\(P(x)\)</span>，即<span class="math inline">\(A
\notin A\)</span>，矛盾； 如果<span class="math inline">\(A \notin
A\)</span>为真，那么满足命题<span
class="math inline">\(P(x)\)</span>，则根据集合<span
class="math inline">\(A\)</span>的定义，<span
class="math inline">\(A\)</span>是自身的元素，即<span
class="math inline">\(A \in A\)</span>，矛盾。<span
class="math inline">\(\square\)</span>
所以数学需要更严格的公理化集合论，此处使用常见的ZFC集合论。</p>
<h3 id="公理化集合论">2）公理化集合论</h3>
<h4 id="外延公理如果两个集合有相同的元素那么它们相等">1.
<font color=red>（外延公理）如果两个集合有相同的元素，那么它们相等。</font></h4>
<p><span class="math inline">\(\forall A, \forall B : (\forall x : x \in
A \iff x \in B) \implies A=B\)</span></p>
<h4 id="空集公理存在一个没有元素的集合">2.
<font color=red>（空集公理）存在一个没有元素的集合。</font></h4>
<p><span class="math inline">\(\exists A, \forall x : x \notin
A\)</span></p>
<p>通过外延公理可以证明这个集合是唯一的，称这个集合为<strong>空集</strong>，记作
<span class="math inline">\(\varnothing\)</span>。</p>
<h4 id="配对公理对任意两个集合x和y存在一个集合有且只有x和y作为元素">3.
<font color=red>（配对公理）对任意两个集合<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，存在一个集合有且只有<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>作为元素。</font></h4>
<p><span class="math inline">\(\forall x, \forall y, \exists A, \forall
z : z \in A \iff z=x \vee z=y\)</span></p>
<p>配对公理可以构造双元素集合，记作<span class="math inline">\(\lbrace
x,y\rbrace\)</span>。</p>
<p>当<span
class="math inline">\(x=y\)</span>时，也可以构造单元素集合：即对任意集合<span
class="math inline">\(x\)</span>，存在集合<span
class="math inline">\(\lbrace x,x\rbrace\)</span>，记作<span
class="math inline">\(\lbrace x\rbrace\)</span>。</p>
<h4
id="并集公理对任意集合a存在一个集合bx是b的元素当且仅当x是a的某个元素的元素">4.
<font color=red>（并集公理）对任意集合<span
class="math inline">\(A\)</span>，存在一个集合<span
class="math inline">\(B\)</span>，<span
class="math inline">\(x\)</span>是<span
class="math inline">\(B\)</span>的元素当且仅当<span
class="math inline">\(x\)</span>是<span
class="math inline">\(A\)</span>的某个元素的元素。</font></h4>
<p><span class="math inline">\(\forall A, \exists B, \forall x : x \in B
\iff (\exists y : x \in y \wedge y \in A)\)</span></p>
<p>通过外延公理可以证明这个集合是唯一的，称这个集合为<span
class="math inline">\(A\)</span>的<strong>并集</strong>，记作 <span
class="math inline">\(\bigcup A\)</span>。</p>
<p>通过配对公理可以得到一个更容易理解的形式：对任意两个集合<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>，存在一个集合，其元素属于<span
class="math inline">\(A\)</span>或者属于<span
class="math inline">\(B\)</span>。</p>
<p><span class="math inline">\(\forall A, \forall B, \exists C, \forall
x : x \in C \iff x \in A \vee x \in B\)</span></p>
<p><code>证明</code>：根据配对公理，对任意两个集合<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>，存在一个集合<span
class="math inline">\(\lbrace A,B\rbrace\)</span>。对集合<span
class="math inline">\(\lbrace
A,B\rbrace\)</span>，根据并集公理，得到存在一个集合<span
class="math inline">\(C\)</span>，满足<span
class="math inline">\(x\)</span>是<span
class="math inline">\(C\)</span>的元素当且仅当<span
class="math inline">\(x\)</span>是<span class="math inline">\(\lbrace
A,B\rbrace\)</span>的元素的元素，即<span
class="math inline">\(x\)</span>是<span
class="math inline">\(A\)</span>的元素或<span
class="math inline">\(x\)</span>是<span
class="math inline">\(B\)</span>的元素。<span
class="math inline">\(\square\)</span></p>
<p>通过外延公理可以证明这个集合是唯一的，称这个集合为<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>的<strong>并集</strong>，记作 <span
class="math inline">\(A \cup B\)</span>。</p>
<h4
id="分类公理子集公理对任意集合a存在一个集合bx是b的元素当且仅当x是a的元素且命题px成立">5.
<font color=red>（分类公理、子集公理）对任意集合<span
class="math inline">\(A\)</span>，存在一个集合<span
class="math inline">\(B\)</span>，<span
class="math inline">\(x\)</span>是<span
class="math inline">\(B\)</span>的元素当且仅当<span
class="math inline">\(x\)</span>是<span
class="math inline">\(A\)</span>的元素且命题<span
class="math inline">\(P(x)\)</span>成立。</font></h4>
<p><span class="math inline">\(\forall A, \exists B, \forall x: x \in B
\iff x \in A \land P(x)\)</span></p>
<p>这个集合<span class="math inline">\(B\)</span>称作<span
class="math inline">\(A\)</span>的一个<strong>子集</strong>，记作 <span
class="math inline">\(B \subseteq A\)</span>，即 <span
class="math inline">\(B \subseteq A \iff (\forall x : x \in B \implies x
\in A)\)</span>。</p>
<p>当<span class="math inline">\(B \subseteq A\)</span>且<span
class="math inline">\(A \subseteq B\)</span>时，即<span
class="math inline">\((\forall x : x \in B \implies x \in A) \wedge
(\forall x : x \in A \implies x \in B)\)</span>，所以<span
class="math inline">\(\forall x : x \in B \iff x \in
A\)</span>，根据外延公理，有<span
class="math inline">\(B=A\)</span>。</p>
<p>当<span class="math inline">\(B \subseteq A\)</span>且<span
class="math inline">\(B \neq A\)</span>时，集合<span
class="math inline">\(B\)</span>称作<span
class="math inline">\(A\)</span>的一个<strong>真子集</strong>，记作
<span class="math inline">\(B \subset A\)</span>。</p>
<p>通常定义子集的方式为<span class="math inline">\(B=\lbrace x \in A |
P(x)\rbrace\)</span>。</p>
<p>使用分类公理，对任意非空集合<span
class="math inline">\(A\)</span>，可以定义集合<span
class="math inline">\(A\)</span>的<strong>交集</strong><span
class="math inline">\(\bigcap A\)</span>，即<span
class="math inline">\(\bigcap A\)</span>的元素都是<span
class="math inline">\(A\)</span>的任意元素的元素。</p>
<p><font color=green><strong>推论</strong>：对任意非空集合<span
class="math inline">\(A\)</span>，它的交集存在。</font></p>
<p><code>证明</code>：因为<span
class="math inline">\(A\)</span>不是空集，所以存在一个元素<span
class="math inline">\(c \in A\)</span>，设命题<span
class="math inline">\(P(x)\)</span>为<span class="math inline">\(\forall
y \neq c (y\in A \implies x \in
y)\)</span>，根据分类公理，存在一个集合<span
class="math inline">\(B\)</span>，满足<span class="math inline">\(x \in
B \iff x \in c \wedge \forall y \neq c(y \in A \implies x \in y) \iff
\forall y (y\in A \implies  x \in y)\)</span>。<span
class="math inline">\(\square\)</span></p>
<p>对任意两个集合<span class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>，存在一个集合，其元素属于<span
class="math inline">\(A\)</span>并且属于<span
class="math inline">\(B\)</span>，称这个集合为<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>的<strong>交集</strong>，记作 <span
class="math inline">\(A \cap B\)</span>。</p>
<h4 id="幂集公理对任意集合a存在一个以a的全部子集为元素的集合">6.
<font color=red>（幂集公理）对任意集合<span
class="math inline">\(A\)</span>，存在一个以<span
class="math inline">\(A\)</span>的全部子集为元素的集合。</font></h4>
<p><span class="math inline">\(\forall A, \exists B, \forall x: x \in B
\iff x \subseteq A\)</span></p>
<p>通过外延公理可以证明这个集合是唯一的，称这个集合是<span
class="math inline">\(A\)</span>的<strong>幂集</strong>，记作 <span
class="math inline">\(\mathcal{P}(A)\)</span>。</p>
<h4
id="无穷公理存在一个集合mathbfn使得空集是mathbfn的元素并且如果x是mathbfn的元素那么x与它的单元素集合lbrace-xrbrace的并集也是mathbfn的元素">7.
<font color=red>（无穷公理）存在一个集合<span
class="math inline">\(\mathbf{N}\)</span>，使得空集是<span
class="math inline">\(\mathbf{N}\)</span>的元素，并且如果<span
class="math inline">\(x\)</span>是<span
class="math inline">\(\mathbf{N}\)</span>的元素，那么<span
class="math inline">\(x\)</span>与它的单元素集合<span
class="math inline">\(\lbrace x\rbrace\)</span>的并集也是<span
class="math inline">\(\mathbf{N}\)</span>的元素。</font></h4>
<p><span class="math inline">\(\exists \mathbf{N}: \varnothing \in
\mathbf{N} \land (\forall x: x \in \mathbf{N} \implies x \cup \lbrace
x\rbrace \in \mathbf{N})\)</span></p>
<p>这种集合也称作<strong>归纳集合</strong>，其中可以定义集合<span
class="math inline">\(x\)</span>的<strong>后继</strong>为<span
class="math inline">\(x \cup \lbrace x\rbrace\)</span>。</p>
<p>这个公理的本质是：存在一个集合包含所有的自然数。</p>
<h4
id="替代公理对任意集合a存在一个集合by是b的元素当且仅当存在x是a的元素且命题pxy为真">8.
<font color=red>（替代公理）对任意集合<span
class="math inline">\(A\)</span>，存在一个集合<span
class="math inline">\(B\)</span>，<span
class="math inline">\(y\)</span>是<span
class="math inline">\(B\)</span>的元素当且仅当存在<span
class="math inline">\(x\)</span>是<span
class="math inline">\(A\)</span>的元素且命题<span
class="math inline">\(P(x,y)\)</span>为真。</font></h4>
<p>其中<span
class="math inline">\(P\)</span>是一个双变量谓词，对任何集合<span
class="math inline">\(x\)</span>存在唯一的集合<span
class="math inline">\(y\)</span>使<span
class="math inline">\(P(x,y)\)</span>成立，定义<span
class="math inline">\(F(x)=y\)</span>当且仅当<span
class="math inline">\(P(x,y)\)</span>。</p>
<p><span class="math inline">\(\forall A, \exists B, \forall y: y \in B
\iff \exists x \in A : y = F(x)\)</span></p>
<p>分类公理可以从替代公理和空集公理共同得出。</p>
<h4 id="正则公理对任意非空集合a至少存在一个元素xx与a的交集为空集">9.
<font color=red>（正则公理）对任意非空集合<span
class="math inline">\(A\)</span>，至少存在一个元素<span
class="math inline">\(x\)</span>，<span
class="math inline">\(x\)</span>与<span
class="math inline">\(A\)</span>的交集为空集</font></h4>
<p><span class="math inline">\(\forall A: A \neq \varnothing \implies
\exists x \in A : x \cap A = \varnothing\)</span></p>
<p><font color=green>推论：不存在以自身为元素的集合。</font></p>
<p><code>证明</code>：反证法，假设存在一个集合<span
class="math inline">\(A\)</span>，使得<span
class="math inline">\(A\)</span>是自身的一个元素，即<span
class="math inline">\(A \in A\)</span>。根据配对公理，存在集合<span
class="math inline">\(B = \lbrace A\rbrace\)</span>。由于<span
class="math inline">\(B\)</span>中只有一个元素<span
class="math inline">\(A\)</span>，根据正则公理，有<span
class="math inline">\(A \cap \lbrace A\rbrace=
\varnothing\)</span>。但根据假设有<span class="math inline">\(A \in
A\)</span>且<span class="math inline">\(A \in \lbrace
A\rbrace\)</span>，所以<span class="math inline">\(A \cap \lbrace
A\rbrace= \lbrace A\rbrace \neq \varnothing\)</span>，矛盾。<span
class="math inline">\(\square\)</span></p>
<h4
id="选择公理给定一个集合x其元素皆为互不相交的非空集合那么存在一个集合y包含x每一个元素的仅仅一个元素">10.
<font color=red>（选择公理）给定一个集合<span
class="math inline">\(x\)</span>，其元素皆为互不相交的非空集合，那么存在一个集合<span
class="math inline">\(y\)</span>，包含<span
class="math inline">\(x\)</span>每一个元素的仅仅一个元素。</font></h4>
<p><span class="math inline">\(\forall X \left[ \varnothing \notin X
\implies \exists f : X \rightarrow \bigcup X \quad \forall A \in X \, (
f(A) \in A ) \right]\)</span></p>
<h2 id="三自然数">三、自然数</h2>
<h3 id="peano公理">1）Peano公理</h3>
<p>对自然数最“自然”的定义，就是使用<strong>Peano公理</strong>：</p>
<h4 id="是一个自然数">1. <font color=red><span
class="math inline">\(0\)</span>是一个自然数。</font></h4>
<h4 id="如果n是一个自然数那么n的后继也是一个自然数将n的后继记作n">2.
<font color=red>如果<span
class="math inline">\(n\)</span>是一个自然数，那么<span
class="math inline">\(n\)</span>的后继也是一个自然数。</font>将<span
class="math inline">\(n\)</span>的后继记作<span
class="math inline">\(n++\)</span>。</h4>
<h4 id="不是任何自然数的后继等价于对任意一个自然数n有n不等于0">3.
<font color=red><span
class="math inline">\(0\)</span>不是任何自然数的后继。</font>等价于，对任意一个自然数<span
class="math inline">\(n\)</span>，有<span
class="math inline">\(n++\)</span>不等于<span
class="math inline">\(0\)</span>。</h4>
<h4 id="对于不同的自然数它们的后继也不同等价于如果nm那么nm">4.
<font color=red>对于不同的自然数，它们的后继也不同。</font>等价于，如果<span
class="math inline">\(n++=m++\)</span>，那么<span
class="math inline">\(n=m\)</span>。</h4>
<h4
id="数学归纳法令pn表示对自然数的任意一个命题如果p0为真且当pn为真时有pn也为真那么对任意自然数n都有pn为真">5.
<font color=red>（数学归纳法）令<span
class="math inline">\(P(n)\)</span>表示对自然数的任意一个命题，如果<span
class="math inline">\(P(0)\)</span>为真且当<span
class="math inline">\(P(n)\)</span>为真时有<span
class="math inline">\(P(n++)\)</span>也为真，那么对任意自然数<span
class="math inline">\(n\)</span>，都有<span
class="math inline">\(P(n)\)</span>为真。</font></h4>
<p>一般把全体自然数的集合记作<span
class="math inline">\(\mathbf{N}\)</span>。</p>
<p>通过集合论中的无穷公理和分类公理可以得到<span
class="math inline">\(\mathbf{N}\)</span>的存在性，通过外延公理可以证明<span
class="math inline">\(\mathbf{N}\)</span>的唯一性。</p>
<h3 id="构造自然数">2）构造自然数</h3>
<p>当然，更“纯粹”地，我们还可以直接从集合论公理中构造出自然数，试一试：</p>
<ol type="1">
<li>根据空集公理，存在空集<span
class="math inline">\(\varnothing\)</span>，定义<span
class="math inline">\(0=\varnothing\)</span>；（对应Peano公理的第一条）</li>
<li>定义集合<span class="math inline">\(n\)</span>的后继为<span
class="math inline">\(n \cup \lbrace n\rbrace\)</span>，即定义<span
class="math inline">\(1=0++=0 \cup \lbrace 0\rbrace= \varnothing \cup
\lbrace \varnothing\rbrace= \lbrace
\varnothing\rbrace\)</span>，依次类推可以定义<span
class="math inline">\(2=\lbrace \varnothing, \lbrace \varnothing\rbrace
\rbrace\)</span>、<span class="math inline">\(3=\lbrace \varnothing,
\lbrace \varnothing\rbrace, \lbrace \varnothing, \lbrace
\varnothing\rbrace \rbrace
\rbrace\)</span>等等；（根据自然数的定义，对应可以证明Peano公理的第二、三、四、五条）</li>
</ol>
<p>根据无穷公理，包括<span
class="math inline">\(\varnothing\)</span>及其全部后继的集合是存在的，可以把这一类集合称为归纳集合（inductive
set）。</p>
<p>根据后继的定义，由<span class="math inline">\(n \in n \cup \lbrace
n\rbrace\)</span>且<span class="math inline">\(n \subseteq n \cup
\lbrace n\rbrace\)</span>，可以得到对任意自然数<span
class="math inline">\(n \in n++\)</span>且<span class="math inline">\(n
\subseteq n++\)</span>。</p>
<p><font color=green><strong>推论</strong>：<span
class="math inline">\(0\)</span>不是任何自然数的后继。</font></p>
<p><code>证明</code>:反证法，假设<span
class="math inline">\(0=n++\)</span>，即<span
class="math inline">\(\varnothing = n \cup \lbrace
n\rbrace\)</span>，因为存在元素<span class="math inline">\(n \in \lbrace
n\rbrace\)</span>，根据并集公理<span class="math inline">\(n \in n \cup
\lbrace n\rbrace\)</span>，即<span class="math inline">\(n \in
\varnothing\)</span>，但是这与空集公理矛盾。<span
class="math inline">\(\square\)</span></p>
<p><strong>自然数定义</strong>：把包括<span
class="math inline">\(\varnothing\)</span>及其全部后继的“最小”集合称为自然数集。即对任意的归纳集合，自然数都是它们的元素，而自然数集就是全体自然数的集合。</p>
<p><font color=blue><strong>定理1</strong>：自然数集的存在性。即存在一个集合，它的元素是任意归纳集合的元素。</font></p>
<p><code>证明</code>：设<span
class="math inline">\(A\)</span>是一个归纳集合，根据无穷公理，这个集合是存在的。根据分类公理，设命题<span
class="math inline">\(P(x)\)</span>为“<span
class="math inline">\(x\)</span>是除<span
class="math inline">\(A\)</span>以外任意归纳集合的元素”，则存在一个集合<span
class="math inline">\(B\)</span>，满足 <span class="math inline">\(x \in
B \iff x \in A \wedge P(x) \iff x
\text{是任意归纳集合的元素}\)</span>。<span
class="math inline">\(\square\)</span></p>
<p>注意，这里不能直接从全体归纳集合的交集得到自然数集，因为“全体归纳集合”不是一个明确定义的集合。</p>
<p><font color=blue><strong>定理2</strong>：自然数集<span
class="math inline">\(\mathbf{N}\)</span>是归纳集合，并且<span
class="math inline">\(\mathbf{N}\)</span>是任意归纳集合的子集。</font></p>
<p><code>证明</code>：首先，根据归纳集合的定义，空集<span
class="math inline">\(\varnothing\)</span>是任意归纳集合的元素，所以<span
class="math inline">\(\varnothing \in
\mathbf{N}\)</span>。然后，对于某个自然数<span class="math inline">\(n
\in \mathbf{N}\)</span>，自然数<span
class="math inline">\(n\)</span>是任意归纳集合的元素，则由归纳集合的定义，<span
class="math inline">\(n++\)</span>也是任意归纳集合的元素，则<span
class="math inline">\(n++ \in \mathbf{N}\)</span>，所以自然数集<span
class="math inline">\(\mathbf{N}\)</span>也是归纳集合。根据子集的定义，自然数集<span
class="math inline">\(\mathbf{N}\)</span>是任意归纳集合的子集。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>定理3（数学归纳法）</strong>：自然数集<span
class="math inline">\(\mathbf{N}\)</span>的任意子集，如果它是归纳集合，那么它等于自然数集。</font></p>
<p><code>证明</code>：设自然数集的子集<span class="math inline">\(T
\subseteq
\mathbf{N}\)</span>为归纳集合；根据定理2，自然数集是归纳集合的子集，即<span
class="math inline">\(\mathbf{N} \subseteq T\)</span>，所以<span
class="math inline">\(T = \mathbf{N}\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>定理4</strong>：任意一个非<span
class="math inline">\(0\)</span>的自然数都是某个自然数的后继。</font></p>
<p><code>证明</code>：设自然数集的子集<span
class="math inline">\(T=\lbrace n \in \mathbf{N} | n = 0 \vee (\exists p
\in \mathbf{N}: n = p++) \rbrace\)</span>。因此<span
class="math inline">\(0 \in T\)</span>，并且如果<span
class="math inline">\(m \in T\)</span>，根据子集的定义，则<span
class="math inline">\(m \in \mathbf{N}\)</span>及<span
class="math inline">\(m++ \in \mathbf{N}\)</span>，即对于<span
class="math inline">\(m++\)</span>来说存在<span class="math inline">\(p
= m \in \mathbf{N}\)</span>满足<span class="math inline">\(m++ =
p++\)</span>，那么<span class="math inline">\(m++ \in
T\)</span>。因此<span
class="math inline">\(T\)</span>是归纳集合，根据定理3（数学归纳法），可得<span
class="math inline">\(T = \mathbf{N}\)</span>。<span
class="math inline">\(\square\)</span></p>
<p>为了证明Peano公理的第四条，需要先引入一个“传递集”（transitive
set）的概念。</p>
<p><strong>传递集</strong>：如果集合<span
class="math inline">\(A\)</span>的元素的任意元素也是<span
class="math inline">\(A\)</span>的一个元素，那么集合<span
class="math inline">\(A\)</span>就被称为传递集，即<span
class="math inline">\(\forall x, \forall a : x \in a \wedge a \in A
\implies x \in A\)</span>。</p>
<p>等价表述有：集合<span
class="math inline">\(A\)</span>的并集是自身的子集<span
class="math inline">\(\bigcup A \subseteq A\)</span>；集合<span
class="math inline">\(A\)</span>的元素也是自身的子集<span
class="math inline">\(a \in A \implies a \subseteq  A\)</span>。</p>
<p><font color=blue><strong>定理5</strong>：对于传递集<span
class="math inline">\(a\)</span>，有<span class="math inline">\(\bigcup
(a++) = a\)</span>。</font></p>
<p><code>证明</code>：根据后继的定义、集合并集的运算规则以及传递集的性质<span
class="math inline">\(\bigcup A \subseteq A\)</span>，有<span
class="math inline">\(\bigcup (a++) = \bigcup (a\cup \lbrace a\rbrace) =
\bigcup a \cup \bigcup\lbrace a\rbrace= \bigcup a \cup a =
a\)</span>。<span class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>定理6</strong>：任意自然数是一个传递集。</font></p>
<p><code>证明</code>：设命题<span
class="math inline">\(P(n)\)</span>为“自然数<span
class="math inline">\(n\)</span>是一个传递集”，根据分类公理，存在一个集合<span
class="math inline">\(T=\lbrace n \in \mathbf{N} |
P(n)\rbrace\)</span>。下面，通过定理3（数学归纳法）来证明<span
class="math inline">\(T=\mathbf{N}\)</span>。首先显然有<span
class="math inline">\(\varnothing \in T\)</span>，然后假设<span
class="math inline">\(k \in T\)</span>，根据定理5，有<span
class="math inline">\(\bigcup (k++) = k \subseteq
k++\)</span>，所以<span
class="math inline">\(k++\)</span>是一个传递集，即<span
class="math inline">\(k++ \in T\)</span>，因此集合<span
class="math inline">\(T\)</span>是一个归纳集合，满足定理3。<span
class="math inline">\(\square\)</span></p>
<p><font color=green><strong>推论</strong>：如果自然数<span
class="math inline">\(n++=m++\)</span>，那么<span
class="math inline">\(n=m\)</span>。</font></p>
<p><code>证明</code>：如果<span class="math inline">\(n++=m++ \in
\mathbf{N}\)</span>，则<span
class="math inline">\(\bigcup(n++)=\bigcup(m++)\)</span>。根据定理6，可知<span
class="math inline">\(n++\)</span>和<span
class="math inline">\(m++\)</span>都是传递集，根据定理5，则有<span
class="math inline">\(\bigcup(n++)=n\)</span>和<span
class="math inline">\(\bigcup(m++)=m\)</span>，所以<span
class="math inline">\(n=m\)</span>。</p>
<p><font color=blue><strong>定理7</strong>：自然数集<span
class="math inline">\(\mathbf{N}\)</span>是一个传递集。</font></p>
<p><code>证明</code>：即需要证明<span class="math inline">\(\forall n
\in \mathbf{N} : n
\subseteq  \mathbf{N}\)</span>。根据分类公理，存在一个集合<span
class="math inline">\(T=\lbrace n \in \mathbf{N} | n
\subseteq  \mathbf{N}\rbrace\)</span>。显然<span
class="math inline">\(\varnothing \in T\)</span>，然后假设<span
class="math inline">\(k \in T\)</span>，则有<span
class="math inline">\(k \subseteq \mathbf{N}\)</span>，同时<span
class="math inline">\(\lbrace k\rbrace \subseteq
\mathbf{N}\)</span>，因此<span class="math inline">\(k \cup \lbrace
k\rbrace \subseteq \mathbf{N}\)</span>，即<span
class="math inline">\(k++ \in T\)</span>。所以集合<span
class="math inline">\(T\)</span>是一个归纳集合，根据定理3（数学归纳法）可知<span
class="math inline">\(T=\mathbf{N}\)</span>。<span
class="math inline">\(\square\)</span></p>
<h2 id="四运算">四、运算</h2>
<p>上面通过纯粹集合论的构造，已经证明了自然数集的存在以及唯一性了，同时一般的Peano公理五条都成立。为了将自然数扩充到整数，需要引入加法、乘法、减法等运算，而严格的定义“运算”需要使用集合论的笛卡尔积，所以这里先回到集合论。</p>
<h3 id="关系有序对笛卡尔积函数">1）关系（有序对、笛卡尔积、函数）</h3>
<p><strong>定义（有序对）</strong>：<span
class="math inline">\(&lt;x,y&gt;\)</span>定义为<span
class="math inline">\(\lbrace \lbrace x \rbrace,\lbrace x,y\rbrace
\rbrace\)</span>。</p>
<p><font color=green><strong>推论</strong>：<span
class="math inline">\(&lt;u,v&gt;=&lt;x,y&gt;\)</span>当且仅当<span
class="math inline">\(u=x\)</span>且<span
class="math inline">\(v=y\)</span>。</font></p>
<p><code>证明</code>：首先，当<span
class="math inline">\(u=x\)</span>且<span
class="math inline">\(v=y\)</span>，根据有序对的定义和相等公理，显然有<span
class="math inline">\(&lt;u,v&gt;=&lt;x,y&gt;\)</span>。</p>
<p>然后证明另一个方向，假设<span
class="math inline">\(&lt;u,v&gt;=&lt;x,y&gt;\)</span>，即<span
class="math inline">\(\lbrace \lbrace u \rbrace,\lbrace u,v\rbrace
\rbrace = \lbrace \lbrace x \rbrace,\lbrace x,y\rbrace
\rbrace\)</span>。</p>
<p>根据外延公理，有<span class="math inline">\(\lbrace u \rbrace \in
\lbrace \lbrace x \rbrace,\lbrace x,y\rbrace \rbrace\)</span>且<span
class="math inline">\(\lbrace u,v \rbrace \in \lbrace \lbrace x
\rbrace,\lbrace x,y\rbrace \rbrace\)</span>。</p>
<p>对<span class="math inline">\(\lbrace u \rbrace \in \lbrace \lbrace x
\rbrace,\lbrace x,y\rbrace \rbrace\)</span>，有（a）<span
class="math inline">\(\lbrace u \rbrace = \lbrace x
\rbrace\)</span>或者（b）<span class="math inline">\(\lbrace u \rbrace =
\lbrace x,y \rbrace\)</span>；</p>
<p>对<span class="math inline">\(\lbrace u,v \rbrace \in \lbrace \lbrace
x \rbrace,\lbrace x,y\rbrace \rbrace\)</span>，有（c）<span
class="math inline">\(\lbrace u,v \rbrace = \lbrace x
\rbrace\)</span>或者（d）<span class="math inline">\(\lbrace u,v \rbrace
= \lbrace x,y \rbrace\)</span>。</p>
<p>对（a）（b）（c）（d）分情况讨论:</p>
<p>首先，假设（b）成立，则<span
class="math inline">\(u=x=y\)</span>，所以（c）和（d）是等价的，并且有<span
class="math inline">\(u=v=x=y\)</span>。这种情况下，推论成立。</p>
<p>同理，假设（c）成立，这种情况跟（b）是对称的，推论也成立。</p>
<p>然后，假设（b）和（c）都不成立，即（a）和（d）同时成立时，根据（a）有<span
class="math inline">\(u=x\)</span>，根据（d）有<span
class="math inline">\(u=y\)</span>或者<span
class="math inline">\(v=y\)</span>，当<span
class="math inline">\(u=y\)</span>时（b）就成立，与假设矛盾，所以只能<span
class="math inline">\(v=y\)</span>，即推论成立。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（笛卡尔积）</strong>：对两个集合<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>，将它们的元素<span
class="math inline">\(x \in A\)</span>和<span class="math inline">\(y
\in B\)</span>所组成的全体有序对<span
class="math inline">\(&lt;x,y&gt;\)</span>称作集合<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>的笛卡尔积（Cartesian
product），记作<span class="math inline">\(A \times B\)</span>：<span
class="math display">\[A \times B = \lbrace &lt;x,y&gt;|x \in A \wedge y
\in B \rbrace\]</span></p>
<p>注意，这里有一个问题，我们还没有证明笛卡尔积的存在性，即没有从集合论公理出发，证明存在一个更大的集合包含了集合<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>的笛卡尔积。</p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>都是集合<span
class="math inline">\(C\)</span>的元素，那么有序对<span
class="math inline">\(&lt;x,y&gt;\)</span>属于<span
class="math inline">\(C\)</span>的幂集的幂集，即<span
class="math inline">\(\forall x \in C, y \in C: &lt;x,y&gt; \in
\mathcal{P}(\mathcal{P}(C))\)</span>。</font></p>
<p><code>证明</code>：根据子集的定义，<span class="math inline">\(x \in
C\)</span>和<span class="math inline">\(y \in C\)</span>，有子集<span
class="math inline">\(\lbrace x \rbrace \subseteq C\)</span>和<span
class="math inline">\(\lbrace x,y \rbrace \subseteq
C\)</span>。根据幂集公理，则有<span class="math inline">\(\lbrace x
\rbrace \in \mathcal{P}(C)\)</span>和<span class="math inline">\(\lbrace
x,y \rbrace \in \mathcal{P}(C)\)</span>，所以<span
class="math inline">\(\lbrace \lbrace x \rbrace, \lbrace x,y \rbrace
\rbrace \subseteq \mathcal{P}(C)\)</span>。再由幂集公理，有<span
class="math inline">\(\lbrace \lbrace x \rbrace, \lbrace x,y \rbrace
\rbrace \in
\mathcal{P}(\mathcal{P}(C))\)</span>，根据有序对的定义，即<span
class="math inline">\(&lt;x,y&gt; \in
\mathcal{P}(\mathcal{P}(C))\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=green><strong>推论</strong>：对任意的集合<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>，存在一个集合，它的元素恰是任意<span
class="math inline">\(x \in A\)</span>和<span class="math inline">\(y
\in B\)</span>的有序对<span
class="math inline">\(&lt;x,y&gt;\)</span>。</font></p>
<p><code>证明</code>：根据子集公理，构造一个集合<span
class="math inline">\(\lbrace w \in \mathcal{P}(\mathcal{P}(A \cup B))|w
= &lt;x,y&gt; \iff x \in A \wedge y \in B
\rbrace\)</span>。首先，显然这个集合只包含有序对。同时，根据引理，有序对<span
class="math inline">\(&lt;x,y&gt;\)</span>都是这个集合的元素。通过这个推论，即完成了笛卡尔积的定义。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（关系）</strong>：关系是有序对组成的集合，即集合<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>的关系是笛卡尔积<span
class="math inline">\(A \times B\)</span>的子集，记作<span
class="math inline">\(R\)</span>。有时，也把<span
class="math inline">\(&lt;x,y&gt; \in R\)</span>，记作<span
class="math inline">\(xRy\)</span>。</p>
<p><strong>定义（定义域和值域）</strong>：关系<span
class="math inline">\(R\)</span>的定义域，记作<span
class="math inline">\(dom(R)\)</span>，为<span class="math inline">\(x
\in dom(R) \iff \exists y:&lt;x,y&gt; \in R\)</span>；关系<span
class="math inline">\(R\)</span>的值域，记作<span
class="math inline">\(ran(R)\)</span>，为<span class="math inline">\(y
\in ran(R) \iff \exists x:&lt;x,y&gt; \in R\)</span>；关系<span
class="math inline">\(R\)</span>的域，记作<span
class="math inline">\(fld(R)\)</span>，为<span
class="math inline">\(dom(R) \cup ran(R)\)</span>。</p>
<p><strong>定义（等价关系）</strong>：如果集合<span
class="math inline">\(A\)</span>上的二元关系<span
class="math inline">\(R\)</span>满足以下条件：</p>
<ol type="1">
<li>（自反性）<span class="math inline">\(\forall x \in A:
xRx\)</span></li>
<li>（对称性）<span class="math inline">\(\forall x,y \in A: xRy
\implies yRx\)</span></li>
<li>（传递性）<span class="math inline">\(\forall x,y,z \in A: (xRy
\wedge yRz) \implies xRz\)</span></li>
</ol>
<p>则称<span class="math inline">\(R\)</span>是一个定义在<span
class="math inline">\(A\)</span>上的等价关系。习惯上把等价关系记作符号<span
class="math inline">\(\sim\)</span>。</p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\(R\)</span>是满足对称性和传递性的关系，那么<span
class="math inline">\(R\)</span>是域<span
class="math inline">\(fld(R)\)</span>上的等价关系。</font></p>
<p><code>证明</code>：首先，任意关系<span
class="math inline">\(R\)</span>都是<span
class="math inline">\(fld(R)\)</span>上的二元关系，因为<span
class="math inline">\(R \subseteq dom(R)\times ran(R) \subseteq
fld(R)\times fld(R)\)</span>。只需要证明<span
class="math inline">\(R\)</span>在<span
class="math inline">\(fld(R)\)</span>上满足自反性，根据对称性和传递性，对定义域上的某个元素有
<span class="math display">\[x \in dom(R) \implies xRy \implies xRy
\wedge yRx \implies xRx \]</span> 对值域同理。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（等价类）</strong>：如果<span
class="math inline">\(R\)</span>是一个等价关系且<span
class="math inline">\(x\in fld(R)\)</span>，那么称集合<span
class="math inline">\([x]_R = \lbrace t \in fld(R) | xRt
\rbrace\)</span>为<span
class="math inline">\(x\)</span>的等价类。如果关系<span
class="math inline">\(R\)</span>的涵义能够从上下文得到，可以简记为<span
class="math inline">\([x]\)</span>。</p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的等价关系，那么<span
class="math inline">\([x]_R=[y]_R\)</span>当且仅当<span
class="math inline">\(xRy\)</span>。</font></p>
<p><code>证明</code>：首先假设<span
class="math inline">\([x]_R=[y]_R\)</span>，来证明<span
class="math inline">\(xRy\)</span>。根据自反性，<span
class="math inline">\(y \in [y]_R\)</span>，因为<span
class="math inline">\([x]_R=[y]_R\)</span>，所以<span
class="math inline">\(y \in [x]_R\)</span>，根据等价类的定义，则有<span
class="math inline">\(xRy\)</span>。然后假设<span
class="math inline">\(xRy\)</span>，来证明<span
class="math inline">\([x]_R=[y]_R\)</span>。根据传递性，对任意的<span
class="math inline">\(t \in [y]_R \implies yRt \implies xRt \implies t
\in [x]_R\)</span>，所以<span class="math inline">\([y]_R \subseteq
[x]_R\)</span>；对称地，同理可得<span class="math inline">\([x]_R
\subseteq [y]_R\)</span>，所以<span
class="math inline">\([x]_R=[y]_R\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（划分）</strong>：定义集合<span
class="math inline">\(A\)</span>的划分<span
class="math inline">\(\Pi\)</span>是一个<span
class="math inline">\(A\)</span>的非空子集的集合，使得这些子集是互不相交的且无遗漏的，即：</p>
<ol type="1">
<li><span class="math inline">\(\Pi\)</span>中的任意两个不同元素（<span
class="math inline">\(A\)</span>的非空子集）没有共同元素（交集为空）；</li>
<li>集合<span class="math inline">\(A\)</span>的任意元素都是<span
class="math inline">\(\Pi\)</span>中某个元素的元素。</li>
</ol>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的等价关系，那么所有等价类组成的集合<span
class="math inline">\(\lbrace [x]_R | x \in A
\rbrace\)</span>是集合<span
class="math inline">\(A\)</span>的一个划分。</font></p>
<p><code>证明</code>：因为存在<span class="math inline">\(x \in
[x]_R\)</span>，所以任意等价类<span
class="math inline">\([x]_R\)</span>是非空集合。因为<span
class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的等价关系，根据等价类的定义，所以任意<span
class="math inline">\([x]_R\)</span>是集合<span
class="math inline">\(A\)</span>的子集。只需要证明不同的等价类没有共同元素：假设<span
class="math inline">\([x]_R\)</span>和<span
class="math inline">\([y]_R\)</span>有一个共同元素<span
class="math inline">\(t\)</span>，那么有<span
class="math inline">\(xRt\)</span>且<span
class="math inline">\(yRt\)</span>，因此<span
class="math inline">\(xRy\)</span>，根据上面的引理有<span
class="math inline">\([x]_R=[y]_R\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（函数）</strong>：函数是一种关系<span
class="math inline">\(F\)</span>，满足对定义域<span
class="math inline">\(dom(R)\)</span>中的任意元素<span
class="math inline">\(x\)</span>，有且仅有一个<span
class="math inline">\(y\)</span>，使得<span
class="math inline">\(xFy\)</span>。</p>
<p>对于一个函数<span class="math inline">\(F\)</span>和一个元素<span
class="math inline">\(x\)</span>（从几何的角度，即“点”），这个唯一满足<span
class="math inline">\(xFy\)</span>的<span
class="math inline">\(y\)</span>称为<span
class="math inline">\(F\)</span>在<span
class="math inline">\(x\)</span>处的值，记作<span
class="math inline">\(F(x)\)</span>。</p>
<p>数学中有很多表述函数的方式，例如说<span
class="math inline">\(F\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的函数，或者说<span
class="math inline">\(F\)</span>把<span
class="math inline">\(A\)</span>映射到<span
class="math inline">\(B\)</span>（记作<span class="math inline">\(F:A
\rightarrow B\)</span>），都等价于说<span
class="math inline">\(F\)</span>是一个函数，<span
class="math inline">\(dom(F) = A\)</span>并且<span
class="math inline">\(ran(F) \subseteq B\)</span>。</p>
<p>特别地，当<span class="math inline">\(ran(F) = B\)</span>时，称<span
class="math inline">\(F\)</span>为满射。</p>
<p>当对任意的<span class="math inline">\(y \in
ran(F)\)</span>，有且仅有一个<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(xFy\)</span>时，称<span
class="math inline">\(F\)</span>为单射。</p>
<p>当<span
class="math inline">\(F\)</span>即是单射也是满射时，称为双射或一一映射。</p>
<p>对于一个集合<span class="math inline">\(S\)</span>，例如自然数集<span
class="math inline">\(\mathbf{N}\)</span>，一般把函数<span
class="math inline">\(F:S \rightarrow
S\)</span>称为一元运算，例如绝对值、三角函数等；把函数<span
class="math inline">\(F:S \times S \rightarrow
S\)</span>称为二元运算，例如算术中的加减乘除。</p>
<p>对于二元运算，例如加法<span
class="math inline">\(+\)</span>，一般把函数<span
class="math inline">\(+(&lt;x,y&gt;)\)</span>写作<span
class="math inline">\(+(x,y)\)</span>或者<span
class="math inline">\(x+y\)</span>。</p>
<h3 id="加法">2）加法</h3>
<p>为了定义自然数集上的运算（加法和乘法），需要引入序列和递归定义的概念：</p>
<p><strong>定义（序列）</strong>：对集合<span
class="math inline">\(A\)</span>，如果存在一个从<span
class="math inline">\(\lbrace 1,2,\dots,n \rbrace\)</span>到<span
class="math inline">\(A\)</span>的函数，其中<span
class="math inline">\(\forall i \in \lbrace 1,2,\dots,n \rbrace:
f(i)=a_i \in A\)</span>，则把<span
class="math inline">\(n\)</span>元有序对（或称<span
class="math inline">\(n\)</span>元组）<span
class="math inline">\((a_1,a_2,\dots,a_n)\)</span>称为有限序列，简记为<span
class="math inline">\((a_n)\)</span>。把从自然数集<span
class="math inline">\(\mathbf{N}\)</span>到<span
class="math inline">\(A\)</span>的函数所形成的序列<span
class="math inline">\((a_0,a_1,a_2,...,a_n,...)\)</span>，称为无限序列。</p>
<p><font color=blue><strong>引理（递归定义）</strong>：如果对集合<span
class="math inline">\(A\)</span>，<span class="math inline">\(a \in
A\)</span>且存在函数<span class="math inline">\(F: A \rightarrow
A\)</span>，那么存在唯一的函数<span class="math inline">\(h: \mathbf{N}
\rightarrow A\)</span>使得<span
class="math inline">\(h(0)=a\)</span>且对任意的自然数<span
class="math inline">\(n\)</span>有<span
class="math inline">\(h(n++)=F(h(n))\)</span>。即如果使用记号<span
class="math inline">\(a_n=h(n)\)</span>，则（无限）序列<span
class="math inline">\((a_0,a_1,a_2,...,a_n,...)\)</span>存在且唯一。</font></p>
<p><code>证明</code>：<em>这个证明比较繁琐，参见Herbert B.
Enderton的《Elements of Set Theory》第74-75页。</em></p>
<p>把一个函数<span
class="math inline">\(v\)</span>称为“可接受的”（acceptable），当且仅当<span
class="math inline">\(dom(v) \subseteq \mathbf{N} \wedge ran(v)
\subseteq A\)</span>，并且满足以下条件：</p>
<ol type="1">
<li>如果<span class="math inline">\(0 \in dom(v)\)</span>，那么<span
class="math inline">\(v(0)=a\)</span>；</li>
<li>如果<span class="math inline">\(\forall n \in \mathbf{N}:n++ \in
dom(v)\)</span>，那么<span class="math inline">\(n \in
dom(v)\)</span>且<span
class="math inline">\(v(n++)=F(v(n))\)</span>。</li>
</ol>
<p>设<span
class="math inline">\(B\)</span>是所有可接受的函数组成的集合，并且设<span
class="math inline">\(h=\bigcup B\)</span>，因此<span
class="math inline">\(&lt;n,y&gt; \in h\)</span>当且仅当<span
class="math inline">\(&lt;n,y&gt;\)</span>是某个可接受的<span
class="math inline">\(v\)</span>的元素，即<span
class="math inline">\(v(n)=y\)</span>。</p>
<p>那么我们可以证明<span
class="math inline">\(h\)</span>满足引理的要求，即（1）<span
class="math inline">\(h\)</span>是一个函数；（2）<span
class="math inline">\(h\)</span>是可接受的；（3）<span
class="math inline">\(dom(h) = \mathbf{N}\)</span>；（4）<span
class="math inline">\(h\)</span>是唯一的。</p>
<p>（1）根据函数的定义，要证明<span
class="math inline">\(h\)</span>是一个函数，即证明两个可接受的函数如果有定义则值是相同的。</p>
<p>设<span
class="math inline">\(S\)</span>为自然数的集合，且在这个自然数上<span
class="math inline">\(h(n)\)</span>有不多于一个的候选者： <span
class="math display">\[S = \lbrace n \in \mathbf{N} | 对最多一个y,
&lt;n,y&gt; \in h \rbrace\]</span></p>
<p>验证<span
class="math inline">\(S\)</span>是归纳集合。首先，如果有<span
class="math inline">\(&lt;0,y_1&gt; \in h\)</span>和<span
class="math inline">\(&lt;0,y_2&gt; \in
h\)</span>，那么存在可接受的函数<span
class="math inline">\(v_1\)</span>和<span
class="math inline">\(v_2\)</span>使得<span
class="math inline">\(v_1(0)=y_1\)</span>且<span
class="math inline">\(v_1(0)=y_2\)</span>。根据条件1，<span
class="math inline">\(y_1 = a = y_2\)</span>，因此<span
class="math inline">\(0 \in S\)</span>。</p>
<p>然后，假设<span class="math inline">\(k \in S\)</span>，证明<span
class="math inline">\(k++ \in S\)</span>。如果有<span
class="math inline">\(&lt;k++,y_1&gt; \in h\)</span>和<span
class="math inline">\(&lt;k++,y_2&gt; \in
h\)</span>，同理存在可接受的函数<span
class="math inline">\(v_1\)</span>和<span
class="math inline">\(v_2\)</span>使得<span
class="math inline">\(v_1(k++)=y_1\)</span>且<span
class="math inline">\(v_1(k++)=y_2\)</span>。根据条件2，<span
class="math inline">\(y_1=v_1(k++)=F(v_1(k))\)</span>且<span
class="math inline">\(y_2=v_2(k++)=F(v_2(k))\)</span>。根据归纳假设<span
class="math inline">\(k \in S\)</span>，即<span
class="math inline">\(v_1(k)=v_2(k)\)</span>，所以<span
class="math inline">\(y_1=F(v_1(k))=F(v_2(k))=y_2\)</span>，即<span
class="math inline">\(k++ \in S\)</span>。</p>
<p>所以<span class="math inline">\(S\)</span>是归纳集合，即<span
class="math inline">\(S=\mathbf{N}\)</span>，因此<span
class="math inline">\(h\)</span>是一个函数。</p>
<p>（2）要证明<span
class="math inline">\(h\)</span>是可接受的。已经证明了<span
class="math inline">\(h\)</span>是一个函数，并且显然有<span
class="math inline">\(dom(h) \subseteq \mathbf{N} \wedge ran(h)
\subseteq A\)</span>。</p>
<p>首先，证明可接受的条件1。如果<span class="math inline">\(0 \in
dom(h)\)</span>，那么一定存在某个可接受的<span
class="math inline">\(v\)</span>使得<span
class="math inline">\(v(0)=h(0)\)</span>。因为<span
class="math inline">\(v(0)=a\)</span>，所以<span
class="math inline">\(h(0)=a\)</span>。</p>
<p>然后，证明可接受的条件2。假设<span class="math inline">\(n++ \in
dom(h)\)</span>，那么一定存在某个可接受的<span
class="math inline">\(v\)</span>使得<span
class="math inline">\(v(n++)=h(n++)\)</span>。因为<span
class="math inline">\(v\)</span>是可接受的，所以<span
class="math inline">\(n \in dom(v)\)</span>且<span
class="math inline">\(v(n)=h(n)\)</span>，那么<span
class="math inline">\(h(n++)=v(n++)=F(v(n))=F(h(n))\)</span>。</p>
<p>因此<span class="math inline">\(h\)</span>是可接受的。</p>
<p>（3）要证明<span class="math inline">\(dom(h) =
\mathbf{N}\)</span>，即证明<span
class="math inline">\(dom(h)\)</span>是归纳集合。</p>
<p>因为函数<span class="math inline">\(\lbrace &lt;0,a&gt;
\rbrace\)</span>是可接受的，因此<span class="math inline">\(0 \in
dom(h)\)</span>。</p>
<p>假设<span class="math inline">\(k \in dom(h)\)</span>，要证明<span
class="math inline">\(k++ \in dom(h)\)</span>。运用反证法，假设<span
class="math inline">\(k++ \notin dom(h)\)</span>，那么<span
class="math inline">\(v=h \cup \lbrace &lt;k++, F(h(k))&gt;
\rbrace\)</span>是一个函数，且<span class="math inline">\(dom(v)
\subseteq \mathbf{N} \wedge ran(v) \subseteq A\)</span>，下面证明<span
class="math inline">\(v\)</span>是可接受的。</p>
<p>因为<span
class="math inline">\(v(0)=h(0)=a\)</span>，满足条件1。对于条件2，<span
class="math inline">\(n++ \in dom(v)\)</span>可以分两种情况。如果<span
class="math inline">\(n++ \neq k++\)</span>，那么<span
class="math inline">\(n++ \in dom(h)\)</span>且<span
class="math inline">\(v(n++)=h(n++)=F(h(n))=F(v(n))\)</span>。另一方面，如果<span
class="math inline">\(n++ = k++\)</span>，即<span
class="math inline">\(n = k\)</span>，根据归纳假设<span
class="math inline">\(k \in dom(h)\)</span>，因此<span
class="math inline">\(v(k++)=F(h(k))=F(v(k))\)</span>。即满足条件2，所以<span
class="math inline">\(v\)</span>是可接受的。</p>
<p>因为<span class="math inline">\(v \subseteq
h\)</span>，那么实际上<span class="math inline">\(k++ \in
dom(h)\)</span>。所以<span
class="math inline">\(dom(h)\)</span>是归纳集合，因此<span
class="math inline">\(dom(h) = \mathbf{N}\)</span>。</p>
<p>（4）最后要证明<span class="math inline">\(h\)</span>是唯一的。</p>
<p>假设<span class="math inline">\(h_1\)</span>和<span
class="math inline">\(h_2\)</span>都满足定理的结论，设集合<span
class="math inline">\(S = \lbrace n \in \mathbf{N} | h_1(n) = h_2(n)
\rbrace\)</span>，要证明<span
class="math inline">\(S\)</span>是归纳集合。</p>
<p>首先，根据条件1，<span class="math inline">\(h_1(0) = a =
h_2(0)\)</span>，所以<span class="math inline">\(0 \in S\)</span>。</p>
<p>然后，假设<span class="math inline">\(k \in S\)</span>，要证明<span
class="math inline">\(k++ \in S\)</span>。因为已经证明<span
class="math inline">\(dom(h_1) = \mathbf{N}\)</span>和<span
class="math inline">\(dom(h_2) = \mathbf{N}\)</span>，根据条件2，<span
class="math inline">\(h_1(k++)=F(h_1(k))=F(h_2(k))=h_2(k++)\)</span>。</p>
<p>因此<span class="math inline">\(S\)</span>是归纳集合，<span
class="math inline">\(S = \mathbf{N}\)</span>即<span
class="math inline">\(h_1 = h_2\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（加法）</strong>：定义二元运算“<span
class="math inline">\(+\)</span>”，满足对任意自然数<span
class="math inline">\(m\)</span>，有<span
class="math inline">\(0+m=m\)</span>；并且对任意自然数<span
class="math inline">\(n\)</span>和<span
class="math inline">\(m\)</span>，有<span
class="math inline">\((n++)+m=(n+m)++\)</span>。</p>
<p>固定<span class="math inline">\(m\)</span>的值，那么运算<span
class="math inline">\(+\)</span>其实是对<span class="math inline">\(n
\in \mathbf{N}\)</span>定义的函数<span
class="math inline">\(h\)</span>，满足<span
class="math inline">\(h(0)=m\)</span>且<span
class="math inline">\(h(n++)=h(n)++\)</span>。通过递归定义的引理，可以看到加法是良定义的。</p>
<p><font color=green><strong>推论</strong>：加法运算是封闭的，即<span
class="math inline">\(+: \mathbf{N} \times \mathbf{N} \rightarrow
\mathbf{N}\)</span>。</font></p>
<p><code>证明</code>：固定<span
class="math inline">\(m\)</span>，对<span
class="math inline">\(n\)</span>使用数学归纳法。首先<span
class="math inline">\(n=0\)</span>时，<span
class="math inline">\(0+m=m\)</span>是自然数；然后假设<span
class="math inline">\(n+m\)</span>是自然数，那么<span
class="math inline">\((n++)+m=(n+m)++\)</span>是<span
class="math inline">\(n+m\)</span>的后继，当然也是自然数。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：对任意自然数<span
class="math inline">\(m\)</span>，<span
class="math inline">\(m+0=m\)</span>。</font></p>
<p><code>证明</code>：数学归纳法。首先当<span
class="math inline">\(m=0\)</span>时，根据加法的定义，<span
class="math inline">\(0+0=0\)</span>；然后假设对自然数<span
class="math inline">\(m\)</span>，满足<span
class="math inline">\(m+0=m\)</span>，需证明<span
class="math inline">\((m++)+0=m++\)</span>。根据加法的定义，<span
class="math inline">\((m++)+0=(m+0)++\)</span>，根据归纳假设<span
class="math inline">\(m+0=m\)</span>，所以<span
class="math inline">\((m++)+0=m++\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：对任意自然数<span
class="math inline">\(n\)</span>和<span
class="math inline">\(m\)</span>，满足<span
class="math inline">\(n+(m++)=(n+m)++\)</span>。</font></p>
<p><code>证明</code>：固定<span
class="math inline">\(m\)</span>，对<span
class="math inline">\(n\)</span>使用数学归纳法。首先当<span
class="math inline">\(n=0\)</span>时，根据引理，左边<span
class="math inline">\(0+(m++)=m++\)</span>且右边<span
class="math inline">\((0+m)++=m++\)</span>，所以<span
class="math inline">\(0+(m++)=(0+m)++\)</span>；然后假设对自然数<span
class="math inline">\(n\)</span>，满足<span
class="math inline">\(n+(m++)=(n+m)++\)</span>，需证明<span
class="math inline">\((n++)+(m++)=((n++)+m)++\)</span>。左边根据加法的定义<span
class="math inline">\((n++)+(m++)=(n+(m++))++\)</span>，根据归纳假设<span
class="math inline">\((n+(m++))++=((n+m)++)++\)</span>，而右边根据加法的定义<span
class="math inline">\(((n++)+m)++=((n+m)++)++\)</span>，所以<span
class="math inline">\((n++)+(m++)=((n++)+m)++\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=green><strong>推论</strong>：对任意自然数<span
class="math inline">\(n\)</span>，<span
class="math inline">\(n++=n+1\)</span></font></p>
<p><code>证明</code>：根据定义<span
class="math inline">\(1=0++\)</span>，所以<span
class="math inline">\(n+1=(n+0)++=n++\)</span>。<span
class="math inline">\(\square\)</span></p>
<p>所以自然数的后继（增量运算），可以通过加法来表示。</p>
<p><font color=blue><strong>加法交换律</strong>：<span
class="math inline">\(a+b=b+a\)</span></font></p>
<p><code>证明</code>：固定<span
class="math inline">\(b\)</span>，对<span
class="math inline">\(a\)</span>使用数学归纳法。首先当<span
class="math inline">\(a=0\)</span>时，根据加法的定义和引理，<span
class="math inline">\(0+b=b\)</span>且<span
class="math inline">\(b+0=b\)</span>，所以<span
class="math inline">\(0+b=b+0\)</span>；然后假设对自然数<span
class="math inline">\(a\)</span>，满足<span
class="math inline">\(a+b=b+a\)</span>，需证明<span
class="math inline">\((a++)+b = b+(a++)\)</span>。根据加法的定义<span
class="math inline">\((a++)+b = (a+b)++\)</span>，根据引理<span
class="math inline">\(b+(a++)=(b+a)++\)</span>，根据归纳假设<span
class="math inline">\(a+b=b+a\)</span>，所以<span
class="math inline">\((a+b)++=(b+a)++\)</span>，即<span
class="math inline">\((a++)+b = b+(a++)\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>加法结合律</strong>：<span
class="math inline">\((a+b)+c=a+(b+c)\)</span></font></p>
<p><code>证明</code>：固定<span class="math inline">\(a\)</span>和<span
class="math inline">\(c\)</span>，对<span
class="math inline">\(b\)</span>使用数学归纳法。首先当<span
class="math inline">\(b=0\)</span>时，根据引理<span
class="math inline">\((a+0)+c=a+c\)</span>，根据加法的定义<span
class="math inline">\(a+(0+c)=a+c\)</span>，所以<span
class="math inline">\((a+0)+c=a+(0+c)\)</span>；然后假设对自然数<span
class="math inline">\(b\)</span>，满足<span
class="math inline">\((a+b)+c=a+(b+c)\)</span>，需证明<span
class="math inline">\((a+(b++))+c=a+((b++)+c)\)</span>。左边<span
class="math inline">\((a+(b++))+c=((a+b)++)+c=((a+b)+c)++\)</span>，右边<span
class="math inline">\(a+((b++)+c)=a+((b+c)++)=(a+(b+c))++\)</span>，根据归纳假设<span
class="math inline">\((a+b)+c=a+(b+c)\)</span>，所以<span
class="math inline">\(((a+b)+c)++=(a+(b+c))++\)</span>，即<span
class="math inline">\((a+(b++))+c=a+((b++)+c)\)</span>。<span
class="math inline">\(\square\)</span></p>
<p>根据加法结合律，在连续的加法中，可以省略括号而不会产生歧义。</p>
<p><font color=blue><strong>加法消去律</strong>：对自然数<span
class="math inline">\(a,b,c\)</span>，如果<span
class="math inline">\(a+b=a+c\)</span>，那么<span
class="math inline">\(b=c\)</span>。</font></p>
<p><code>证明</code>：固定<span class="math inline">\(b\)</span>和<span
class="math inline">\(c\)</span>，对<span
class="math inline">\(a\)</span>使用数学归纳法。首先当<span
class="math inline">\(a=0\)</span>时，<span
class="math inline">\(0+b=0+c\)</span>，根据加法的定义有<span
class="math inline">\(b=c\)</span>；然后假设<span
class="math inline">\(a+b=a+c \implies b=c\)</span>，需证明<span
class="math inline">\((a++)+b=(a++)+c \implies
b=c\)</span>。根据加法的定义<span
class="math inline">\((a++)+b=(a+b)++\)</span>且<span
class="math inline">\((a++)+c=(a+c)++\)</span>，即<span
class="math inline">\((a+b)++=(a+c)++\)</span>，根据Peano公理第四条，有<span
class="math inline">\(a+b=a+c\)</span>，根据归纳假设，即<span
class="math inline">\(b=c\)</span>。<span
class="math inline">\(\square\)</span></p>
<h3 id="乘法">3）乘法</h3>
<p><strong>定义（乘法）</strong>：定义二元运算“<span
class="math inline">\(\times\)</span>”，满足对任意自然数<span
class="math inline">\(m\)</span>，有<span class="math inline">\(0 \times
m=0\)</span>；并且对任意自然数<span
class="math inline">\(n\)</span>和<span
class="math inline">\(m\)</span>，满足<span
class="math inline">\((n++)\times m=n \times m+m\)</span>。</p>
<p>与加法类似，乘法也是递归定义的。</p>
<p><font color=green><strong>推论</strong>：乘法运算是封闭的，即<span
class="math inline">\(\times: \mathbf{N} \times \mathbf{N} \rightarrow
\mathbf{N}\)</span>。</font></p>
<p><code>证明</code>：固定<span
class="math inline">\(m\)</span>，对<span
class="math inline">\(n\)</span>使用数学归纳法。首先<span
class="math inline">\(n=0\)</span>时，<span
class="math inline">\(0\times m=0\)</span>是自然数；然后假设<span
class="math inline">\(n\times m\)</span>是自然数，那么<span
class="math inline">\((n++)\times m=(n\times
m)+m\)</span>是两个自然数相加，根据加法的定义，也是自然数。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：对任意自然数<span
class="math inline">\(m\)</span>，<span class="math inline">\(m \times
0=0\)</span>。</font></p>
<p><code>证明</code>：数学归纳法。首先当<span
class="math inline">\(m=0\)</span>时，根据乘法的定义，<span
class="math inline">\(0 \times 0=0\)</span>；然后假设对自然数<span
class="math inline">\(m\)</span>，满足<span class="math inline">\(m
\times 0=0\)</span>，需证明<span class="math inline">\((m++) \times
0=0\)</span>。根据乘法的定义，<span class="math inline">\((m++)\times
0=m \times 0+0\)</span>，根据归纳假设<span class="math inline">\(m
\times 0=0\)</span>，所以<span class="math inline">\((m++)\times
0=0+0=0\)</span>。<span class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：对任意自然数<span
class="math inline">\(n\)</span>和<span
class="math inline">\(m\)</span>，满足<span class="math inline">\(n
\times (m++)=n \times m+n\)</span>。</font></p>
<p><code>证明</code>：固定<span
class="math inline">\(m\)</span>，对<span
class="math inline">\(n\)</span>使用数学归纳法。首先当<span
class="math inline">\(n=0\)</span>时，根据引理，左边<span
class="math inline">\(0 \times (m++)=0\)</span>且右边<span
class="math inline">\((0 \times m)+0=0+0=0\)</span>，所以<span
class="math inline">\(0 \times (m++)=0 \times
m+0\)</span>；然后假设对自然数<span
class="math inline">\(n\)</span>，满足<span class="math inline">\(n
\times (m++)=n \times m+n\)</span>，需证明<span
class="math inline">\((n++) \times (m++)=(n++) \times
m+(n++)\)</span>。左边根据乘法、加法的定义和归纳假设<span
class="math inline">\((n++) \times (m++)=n \times (m++)+(m++)=(n \times
(m++)+m)++=(n \times m
+n+m)++\)</span>，而右边根据乘法的定义和加法的引理<span
class="math inline">\((n++) \times m+(n++)=(n \times m +m)+(n++)=(n
\times m+m+n)++\)</span>，根据加法交换律<span
class="math inline">\(n+m=m+n\)</span>，所以<span
class="math inline">\((n++) \times (m++)=(n++) \times
m+(n++)\)</span>。<span class="math inline">\(\square\)</span></p>
<p>按照代数的惯例，在不造成歧义时，可以省略乘号<span
class="math inline">\(\times\)</span>，即将<span class="math inline">\(n
\times m\)</span>简写为<span class="math inline">\(mn\)</span>。</p>
<p><font color=blue><strong>乘法交换律</strong>：<span
class="math inline">\(ab=ba\)</span></font></p>
<p><code>证明</code>：固定<span
class="math inline">\(b\)</span>，对<span
class="math inline">\(a\)</span>使用数学归纳法。首先当<span
class="math inline">\(a=0\)</span>时，根据乘法的定义和引理，<span
class="math inline">\(0\times b=0\)</span>且<span
class="math inline">\(b\times 0=0\)</span>，所以<span
class="math inline">\(0\times b=b\times
0\)</span>；然后假设对自然数<span
class="math inline">\(a\)</span>，满足<span
class="math inline">\(ab=ba\)</span>，需证明<span
class="math inline">\((a++)b = b(a++)\)</span>。根据乘法的定义<span
class="math inline">\((a++)b = ab+b\)</span>，根据引理<span
class="math inline">\(b(a++)=ba+b\)</span>，根据归纳假设<span
class="math inline">\(ab=ba\)</span>，所以<span
class="math inline">\((a++)b = b(a++)\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=green><strong>推论</strong>：对任意自然数<span
class="math inline">\(n\)</span>，<span class="math inline">\(n\times
1=1\times n=n\)</span>。</font></p>
<p><code>证明</code>：利用乘法交换律，只需证明<span
class="math inline">\(n\times 1=n\)</span>。根据定义和引理，<span
class="math inline">\(n\times 1=n\times (0++)=n\times 0 +
n=0+n=n\)</span>。<span class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>乘法分配律</strong>：<span
class="math inline">\(a(b+c)=ab+ac\)</span></font></p>
<p><code>证明</code>：固定<span class="math inline">\(a\)</span>和<span
class="math inline">\(c\)</span>，对<span
class="math inline">\(b\)</span>使用数学归纳法。首先当<span
class="math inline">\(b=0\)</span>时，<span
class="math inline">\(a(0+c)=ac\)</span>而<span class="math inline">\(a
\times 0+ac = 0+ac = ac\)</span>，所以<span
class="math inline">\(a(0+c)=a \times
0+ac\)</span>；然后假设对自然数<span
class="math inline">\(b\)</span>，满足<span
class="math inline">\(a(b+c)=ab+ac\)</span>，需证明<span
class="math inline">\(a((b++)+c)=a(b++)+ac\)</span>。左边根据加法的定义、乘法的引理和归纳假设<span
class="math inline">\(a((b++)+c)=a((b+c)++)=a(b+c)+a=ab+ac+a\)</span>，右边乘法的引理和加法交换律<span
class="math inline">\(a(b++)+ac=ab+a+ac=ab+ac+a\)</span>，所以<span
class="math inline">\(a((b++)+c)=a(b++)+ac\)</span>。<span
class="math inline">\(\square\)</span></p>
<p>同样地，可以证明<span class="math inline">\((a+b)c=ac+bc\)</span></p>
<p><font color=blue><strong>乘法结合律</strong>：<span
class="math inline">\((ab)c=a(bc)\)</span></font></p>
<p><code>证明</code>：固定<span class="math inline">\(a\)</span>和<span
class="math inline">\(c\)</span>，对<span
class="math inline">\(b\)</span>使用数学归纳法。首先当<span
class="math inline">\(b=0\)</span>时，根据引理<span
class="math inline">\((a \times 0)c=0 \times
c=0\)</span>，根据乘法的定义<span class="math inline">\(a(0\times c)=a
\times 0=0\)</span>，所以<span class="math inline">\((a\times
0)c=a(0\times c)\)</span>；然后假设对自然数<span
class="math inline">\(b\)</span>，满足<span
class="math inline">\((ab)c=a(bc)\)</span>，需证明<span
class="math inline">\((a(b++))c=a((b++)c)\)</span>。左边根据乘法的引理和乘法分配律<span
class="math inline">\((a(b++))c=(ab+a)c=(ab)c+ac\)</span>，右边<span
class="math inline">\(a((b++)c)=a(bc+c)=a(bc)+ac\)</span>，根据归纳假设<span
class="math inline">\((ab)c=a(bc)\)</span>，所以<span
class="math inline">\((ab)c+ac=a(bc)+ac\)</span>，即<span
class="math inline">\((a(b++))c=a((b++)c)\)</span>。<span
class="math inline">\(\square\)</span></p>
<h3 id="序关系">4）序关系</h3>
<p><strong>定义（正的）</strong>：一个自然数是正的，当且仅当它不等于0，即正自然数，简称正数。</p>
<p><font color=green><strong>推论</strong>：对正数<span
class="math inline">\(a\)</span>和自然数<span
class="math inline">\(b\)</span>，<span
class="math inline">\(a+b\)</span>是正的</font></p>
<p><code>证明</code>：固定<span
class="math inline">\(a\)</span>，对<span
class="math inline">\(b\)</span>使用数学归纳法。首先当<span
class="math inline">\(b=0\)</span>时，<span
class="math inline">\(a+0=a\)</span>是正的；然后假设<span
class="math inline">\(a+b\)</span>是正的，需证明<span
class="math inline">\(a+(b++)\)</span>是正的。因为<span
class="math inline">\(a+(b++)=(a+b)++\)</span>，根据Peano公理第三条，<span
class="math inline">\((a+b)++ \neq 0\)</span>，所以<span
class="math inline">\(a+(b++)\)</span>是正的。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（序）</strong>：对任意自然数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>，如果存在一个自然数<span
class="math inline">\(c\)</span>，满足<span
class="math inline">\(a=b+c\)</span>，则称<span
class="math inline">\(a\)</span>大于等于<span
class="math inline">\(b\)</span>，记作<span class="math inline">\(a \geq
b\)</span>或<span class="math inline">\(b \leq a\)</span>；当<span
class="math inline">\(a \geq b\)</span>且<span class="math inline">\(a
\neq b\)</span>时，称<span
class="math inline">\(a\)</span>（严格）大于<span
class="math inline">\(b\)</span>，记作<span class="math inline">\(a &gt;
b\)</span>或<span class="math inline">\(b &lt; a\)</span>。</p>
<p><strong>自然数的序的性质</strong>：设<span
class="math inline">\(a,b,c\)</span>是自然数，那么：</p>
<ol type="1">
<li>（序是自反的）<span class="math inline">\(a \geq a\)</span>；</li>
<li>（序是传递的）如果<span class="math inline">\(a \geq
b\)</span>且<span class="math inline">\(b \geq c\)</span>，那么<span
class="math inline">\(a \geq c\)</span>；</li>
<li>（序是反对称的）如果<span class="math inline">\(a \geq
b\)</span>且<span class="math inline">\(b \geq a\)</span>，那么<span
class="math inline">\(a = b\)</span>；</li>
<li>（加法保序）<span class="math inline">\(a \geq
b\)</span>当且仅当<span class="math inline">\(a+c \geq
b+c\)</span>；</li>
<li>（乘法保序）如果<span class="math inline">\(a &lt; b\)</span>且<span
class="math inline">\(c\)</span>是正的，那么<span
class="math inline">\(ac &lt; bc\)</span></li>
<li><span class="math inline">\(a &lt; b\)</span>当且仅当<span
class="math inline">\(a++ \leq b\)</span>；</li>
<li><span class="math inline">\(a &lt; b\)</span>当且仅当存在正数<span
class="math inline">\(c\)</span>，<span
class="math inline">\(b=a+c\)</span>。</li>
</ol>
<p><code>证明</code>：</p>
<ol type="1">
<li>因为<span class="math inline">\(a=a+0\)</span>，所以<span
class="math inline">\(a \geq a\)</span>；</li>
<li>如果<span class="math inline">\(a \geq b\)</span>且<span
class="math inline">\(b \geq c\)</span>，则存在自然数<span
class="math inline">\(d\)</span>和<span
class="math inline">\(e\)</span>，满足<span
class="math inline">\(a=b+d\)</span>和<span
class="math inline">\(b=c+e\)</span>，代入并根据加法结合律有<span
class="math inline">\(a=(c+e)+d=c+(e+d)\)</span>且<span
class="math inline">\((e+d)\)</span>是自然数，所以<span
class="math inline">\(a \geq c\)</span>；</li>
<li>如果<span class="math inline">\(a \geq b\)</span>且<span
class="math inline">\(b \geq a\)</span>，则存在自然数<span
class="math inline">\(d\)</span>和<span
class="math inline">\(e\)</span>，满足<span
class="math inline">\(a=b+d\)</span>和<span
class="math inline">\(b=a+e\)</span>，代入有<span
class="math inline">\(a=a+e+d\)</span>，根据加法消去律有<span
class="math inline">\(0=e+d\)</span>，根据正数与自然数相加是正的，所以<span
class="math inline">\(e\)</span>和<span
class="math inline">\(d\)</span>都不是正数，即<span
class="math inline">\(e=d=0\)</span>，所以<span
class="math inline">\(a=b\)</span>；</li>
<li><span class="math inline">\(a \geq b \iff \exists d \in \mathbf{N}:
a = b+d \iff a+c = b+d+c = b+c+d \iff a+c \geq b+c\)</span>；</li>
<li>对<span class="math inline">\(a &lt; b\)</span>，存在正自然数<span
class="math inline">\(d\)</span>，满足<span
class="math inline">\(a=b+d\)</span>，所以<span
class="math inline">\(ac=bc+dc\)</span>。只需要证明正数<span
class="math inline">\(d\)</span>和正数<span
class="math inline">\(c\)</span>的乘积<span
class="math inline">\(dc\)</span>仍是正的。因为存在<span
class="math inline">\(e++=c\)</span>，所以<span
class="math inline">\(dc=d(e++)=de+d\)</span>，其中<span
class="math inline">\(de\)</span>是自然数、<span
class="math inline">\(d\)</span>是一个正数，所以<span
class="math inline">\(dc\)</span>是正的；</li>
<li><span class="math inline">\(a &lt; b\)</span>当且仅当存在正数<span
class="math inline">\(c\)</span>满足<span
class="math inline">\(b=a+c\)</span>，即存在自然数<span
class="math inline">\(d\)</span>满足<span
class="math inline">\(d++=c\)</span>，所以等价于<span
class="math inline">\(b=a+(d++)=(a++)+d\)</span>，即<span
class="math inline">\(a++ \leq b\)</span>；</li>
<li><span class="math inline">\(a &lt; b \iff \exists c \in \mathbf{N}:
b=a+c \wedge b \neq a\)</span>。如果<span
class="math inline">\(c=0\)</span>，那么<span
class="math inline">\(b=a\)</span>，矛盾，所以<span
class="math inline">\(b \neq a\)</span>时<span
class="math inline">\(c\)</span>是正数。反之，如果<span
class="math inline">\(b=a\)</span>，那么<span
class="math inline">\(b=b+0=a+c\)</span>，根据加法消去律，有<span
class="math inline">\(0=c\)</span>，所以<span
class="math inline">\(c\)</span>是正数时<span class="math inline">\(b
\neq a\)</span>。<span class="math inline">\(\square\)</span></li>
</ol>
<p><strong>自然数的序的三歧性</strong>：对自然数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>，下列三个命题中有且仅有一个是真的：</p>
<ol type="1">
<li><span class="math inline">\(a &lt; b\)</span>；</li>
<li><span class="math inline">\(a = b\)</span>；</li>
<li><span class="math inline">\(a &gt; b\)</span>。</li>
</ol>
<p><code>证明</code>：首先证明三个命题中最多有一个成立。如果<span
class="math inline">\(a &lt; b\)</span>，根据定义有<span
class="math inline">\(a \neq b\)</span>；如果<span
class="math inline">\(a &gt; b\)</span>，根据定义有<span
class="math inline">\(a \neq b\)</span>；如果<span
class="math inline">\(a &lt; b\)</span>且<span class="math inline">\(a
&gt; b\)</span>，根据自然数的序的性质第3条有<span
class="math inline">\(a =
b\)</span>，矛盾。然后，再证明至少有一个命题成立。</p>
<p>固定<span class="math inline">\(b\)</span>，对整个命题对<span
class="math inline">\(a\)</span>使用数学归纳法。当<span
class="math inline">\(a=0\)</span>时，因为<span
class="math inline">\(b=0+b\)</span>，所以<span
class="math inline">\(0\leq b\)</span>对任意自然数<span
class="math inline">\(b\)</span>成立，因此有<span
class="math inline">\(0&lt;b\)</span>或<span
class="math inline">\(0=b\)</span>，满足整体命题成立。假设整体命题对<span
class="math inline">\(a\)</span>成立，需要证明对<span
class="math inline">\(a++\)</span>也成立。从<span
class="math inline">\(a &lt; b\)</span>，<span class="math inline">\(a =
b\)</span>和<span class="math inline">\(a &gt; b\)</span>出发： 1.
如果<span class="math inline">\(a &gt; b\)</span>，即存在正数<span
class="math inline">\(c\)</span>满足<span
class="math inline">\(a=b+c\)</span>，所以<span
class="math inline">\(a++=(b+c)++=b+(c++)\)</span>，由<span
class="math inline">\(c++\)</span>一定是正的，有<span
class="math inline">\(a++ &gt; b\)</span>； 2. 如果<span
class="math inline">\(a = b\)</span>，由<span
class="math inline">\(a++=a+1=b+1\)</span>，可得<span
class="math inline">\(a++ &gt; b\)</span>； 3. 如果<span
class="math inline">\(a &lt;
b\)</span>，由自然数的序的性质第6条，有<span class="math inline">\(a++
\leq b\)</span>，所以<span
class="math inline">\(a++&lt;b\)</span>或<span
class="math inline">\(a++=b\)</span>。 即整体命题的归纳假设成立。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>乘法消去率</strong>：对自然数<span
class="math inline">\(a,b,c\)</span>，如果<span
class="math inline">\(ac=bc\)</span>且<span class="math inline">\(c \neq
0\)</span>，那么<span class="math inline">\(a=b\)</span>。</font></p>
<p><code>证明</code>：因为<span class="math inline">\(c \neq
0\)</span>，所以存在唯一的自然数<span
class="math inline">\(d\)</span>满足<span
class="math inline">\(d++=c\)</span>，则命题等价为如果<span
class="math inline">\(a(d++)=b(d++)\)</span>，那么<span
class="math inline">\(a=b\)</span>。固定<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>，对<span
class="math inline">\(d\)</span>使用数学归纳法。首先当<span
class="math inline">\(d=0\)</span>时，<span
class="math inline">\(a(0++)=a\times 0+a=a\)</span>且<span
class="math inline">\(b(0++)=b\)</span>，所以<span
class="math inline">\(a=b\)</span>；然后假设<span
class="math inline">\(a(d++)=b(d++) \implies a=b\)</span>，需证明<span
class="math inline">\(a((d++)++)=b((d++)++) \implies
a=b\)</span>。根据乘法的定义和引理<span
class="math inline">\(a((d++)++)=a(d++)+a\)</span>且<span
class="math inline">\(b((d++)++)=b(d++)+b\)</span>，通过归纳假设<span
class="math inline">\(a(d++)=b(d++)\)</span>，根据加法消去律得到<span
class="math inline">\(a=b\)</span>。<span
class="math inline">\(\square\)</span></p>
<p>上述用归纳法的证明，在使用归纳假设上有问题。从陶哲轩的书上看，需要通过序的三歧性来证明。因为序相关的证明并没有使用到乘法消去率，所以不构成循环论证。</p>
<p><code>证明</code>：如果<span class="math inline">\(a \neq
b\)</span>，根据自然数的序的三歧性，有<span class="math inline">\(a &lt;
b\)</span>或者<span class="math inline">\(a &gt; b\)</span>。如果<span
class="math inline">\(a &lt; b\)</span>，并且<span
class="math inline">\(c \neq 0\)</span>即<span
class="math inline">\(c\)</span>是正的，根据乘法保序的性质，那么<span
class="math inline">\(ac &lt; bc\)</span>，与<span
class="math inline">\(ac=bc\)</span>矛盾。同理<span
class="math inline">\(a &gt; b\)</span>也矛盾。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（指数运算）</strong>：定义二元运算“<span
class="math inline">\(\exp\)</span>”，满足对任意自然数<span
class="math inline">\(m\)</span>，有<span
class="math inline">\(\exp(m,0)=1\)</span>，记作<span
class="math inline">\(m^0=1\)</span>；并且对任意自然数<span
class="math inline">\(n\)</span>和<span
class="math inline">\(m\)</span>，满足<span
class="math inline">\(\exp(m,n++)=\exp(m,n) \times m\)</span>，记作<span
class="math inline">\(m^{n++}=m^n \times m\)</span>。</p>
<h2 id="五整数">五、整数</h2>
<p>严格来说，对限定在自然数上的初等数论可以不需要构造出整数，即只使用自然数及其加法、乘法的定义对证明算术基本定理就足够了。但是，为了在证明上方便地使用减法，并且在Tao的《陶哲轩实分析》一书中，通过形式减法构造整数、通过形式除法构造有理数、最后通过形式极限构造实数等数系是全书的一大精髓，所以这里保留整数的内容，但再不对每个结论做出详细证明。</p>
<h3 id="形式化整数">1）形式化整数</h3>
<p><strong>定义（整数）</strong>：一个整数是一个形如<span
class="math inline">\(a\ominus b\)</span>的表达式，其中<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>自然数。<span
class="math inline">\(\ominus\)</span>代表形式减法，使得两个整数是相等的<span
class="math inline">\(a\ominus b=c\ominus d\)</span>当且仅当<span
class="math inline">\(a+d=c+b\)</span>。用<span
class="math inline">\(\mathbf{Z}\)</span>代表全体整数的集合。</p>
<p><font color=blue><strong>定理</strong>：对有序对<span
class="math inline">\(&lt;a,b&gt;\in \mathbf{N} \times
\mathbf{N}\)</span>，形式减法<span
class="math inline">\(\ominus\)</span>是一个等价关系，所以形式减法构成一个划分，即整数是由形式减法<span
class="math inline">\(\ominus\)</span>的全体等价类（<span
class="math inline">\(\mathbf{N} \times
\mathbf{N}\)</span>的非空子集）构成的一个集合。</font></p>
<p><code>证明</code>：根据形式减法的定义，显然满足自反性。证明对称性，假设<span
class="math inline">\(a\ominus b=c\ominus d\)</span>，即<span
class="math inline">\(a+d=c+b\)</span>，根据相等的对称公理有<span
class="math inline">\(c+b=a+d\)</span>，所以<span
class="math inline">\(c\ominus d=a\ominus
b\)</span>。证明传递性，假设<span class="math inline">\(a\ominus
b=c\ominus d\)</span>且<span class="math inline">\(c\ominus d=e\ominus
f\)</span>，即<span class="math inline">\(a+d=c+b\)</span>且<span
class="math inline">\(c+f=e+d\)</span>，两边对应相加即<span
class="math inline">\(a+d+c+f=c+b+e+d\)</span>，根据加法交换律、结合律和消去律，有<span
class="math inline">\(a+f=b+e=e+b\)</span>，所以<span
class="math inline">\(a\ominus b=e\ominus f\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（整数的加法）</strong>：两个整数的和<span
class="math inline">\((a\ominus b)+(c\ominus
d)\)</span>，定义为整数<span class="math inline">\((a + c)\ominus(b +
d)\)</span>。</p>
<p><strong>定义（整数的乘法）</strong>：两个整数的积<span
class="math inline">\((a\ominus b)\times (c\ominus
d)\)</span>，定义为整数<span class="math inline">\((ac + bd)\ominus(ad +
bc)\)</span>。</p>
<p><font color=green><strong>推论</strong>：整数<span
class="math inline">\(a\ominus 0\)</span>与自然数<span
class="math inline">\(a\)</span>等价（同构）。</font></p>
<h3 id="整数的运算法则">2）整数的运算法则</h3>
<p><strong>定义（整数的负运算）</strong>：如果<span
class="math inline">\(a\ominus
b\)</span>是一个整数，定义它的负数为整数<span
class="math inline">\(b\ominus a\)</span>，记作<span
class="math inline">\(-(a\ominus b)\)</span>。特别地，如果<span
class="math inline">\(n=n\ominus 0\)</span>是正自然数，那么它的负数<span
class="math inline">\(-n=0\ominus n\)</span>，称为负整数。</p>
<p><strong>整数的三歧性</strong>：对整数<span
class="math inline">\(x\)</span>，下列三个命题中有且仅有一个是真的：</p>
<ol type="1">
<li><span class="math inline">\(x = 0\)</span>；</li>
<li><span class="math inline">\(x\)</span>等于一个正自然数<span
class="math inline">\(n\)</span>；</li>
<li><span class="math inline">\(x\)</span>是一个正自然数的负数<span
class="math inline">\(-n\)</span>。</li>
</ol>
<p><strong>整数的运算法则</strong>：设<span
class="math inline">\(x,y,z\)</span>是整数，那么：</p>
<ol type="1">
<li><span class="math inline">\(x+y=y+x\)</span></li>
<li><span class="math inline">\((x+y)+z=x+(y+z)\)</span></li>
<li><span class="math inline">\(x+0=0+x=x\)</span></li>
<li><span class="math inline">\(x+(-x)=(-x)+x=0\)</span></li>
<li><span class="math inline">\(xy=yx\)</span></li>
<li><span class="math inline">\((xy)z=x(yz)\)</span></li>
<li><span class="math inline">\(x1=1x=x\)</span></li>
<li><span class="math inline">\(x(y+z)=xy+xz\)</span></li>
<li><span class="math inline">\((y+z)x=yx+zx\)</span></li>
</ol>
<p>在抽象代数中，上面9条恒等式判定了全体整数构成了一个交换环。</p>
<p><strong>定义（减法运算）</strong>：两个整数<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的减法运算定义为<span
class="math inline">\(x-y=x+(-y)\)</span>。</p>
<p>根据整数的加法和负运算，可知减法运算是良定义的。</p>
<p><font color=green><strong>推论</strong>：<span
class="math inline">\(a-b=a+(-b)=(a\ominus 0)+(0\ominus b)=a\ominus
b\)</span>，所以整数的减法运算与前面定义的形式减法是等价的。</font></p>
<p><font color=blue><strong>引理</strong>：对整数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>，如果<span
class="math inline">\(ab=0\)</span>，那么<span class="math inline">\(a=0
\vee b=0\)</span>。</font></p>
<p><strong>定义（序）</strong>：对任意整数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>，如果存在一个自然数<span
class="math inline">\(c\)</span>，满足<span
class="math inline">\(a=b+c\)</span>，则称<span
class="math inline">\(a\)</span>大于等于<span
class="math inline">\(b\)</span>，记作<span class="math inline">\(a \geq
b\)</span>或<span class="math inline">\(b \leq a\)</span>；当<span
class="math inline">\(a \geq b\)</span>且<span class="math inline">\(a
\neq b\)</span>时，称<span
class="math inline">\(a\)</span>（严格）大于<span
class="math inline">\(b\)</span>，记作<span class="math inline">\(a &gt;
b\)</span>或<span class="math inline">\(b &lt; a\)</span>。</p>
<p><strong>整数的序的性质</strong>：设<span
class="math inline">\(a,b,c\)</span>是整数，那么：</p>
<ol type="1">
<li><span class="math inline">\(a &gt;
b\)</span>当且仅当存在正自然数<span
class="math inline">\(c\)</span>，<span
class="math inline">\(a=b+c\)</span>，即当且仅当<span
class="math inline">\(a-b\)</span>是正自然数；</li>
<li>（加法保序）<span class="math inline">\(a \geq
b\)</span>当且仅当<span class="math inline">\(a+c \geq
b+c\)</span>；</li>
<li>（正数乘法保序）如果<span class="math inline">\(a &gt;
b\)</span>且<span class="math inline">\(c\)</span>是正的，那么<span
class="math inline">\(ac &gt; bc\)</span>；</li>
<li>（负运算反序）如果<span class="math inline">\(a &gt;
b\)</span>，那么<span class="math inline">\(-a &lt; -b\)</span>；</li>
<li>（序的传递性）如果<span class="math inline">\(a &gt;
b\)</span>且<span class="math inline">\(b &gt; c\)</span>，那么<span
class="math inline">\(a &gt; c\)</span>；</li>
<li>（序的三歧性）命题中<span class="math inline">\(a &gt;
b\)</span>，<span class="math inline">\(a = b\)</span>，<span
class="math inline">\(a &lt; b\)</span>有且仅有一个成立。</li>
</ol>
<h2 id="六初等数论">六、初等数论</h2>
<p><font color=blue><strong>定理</strong>：对自然数<span
class="math inline">\(n\)</span>和正自然数<span
class="math inline">\(q\)</span>，存在自然数<span
class="math inline">\(m\)</span>和<span
class="math inline">\(r\)</span>，使得<span class="math inline">\(0 \leq
r &lt; q\)</span>且<span
class="math inline">\(n=mq+r\)</span>。</font></p>
<p><code>证明</code>：固定正数<span
class="math inline">\(q\)</span>，对自然数<span
class="math inline">\(n\)</span>使用数学归纳法。首先当<span
class="math inline">\(n=0\)</span>时，存在<span
class="math inline">\(m=r=0\)</span>且<span class="math inline">\(0 \leq
r &lt; q\)</span>使得<span class="math inline">\(0=0\times q +
0\)</span>。假设命题在<span
class="math inline">\(n\)</span>时成立，则对<span
class="math inline">\(n++\)</span>有<span
class="math inline">\(n++=(mq+r)++=mq+(r++)\)</span>，因为<span
class="math inline">\(r &lt; q\)</span>，所以<span
class="math inline">\(r++ \leq q\)</span>，如果<span
class="math inline">\(r++ &lt; q\)</span>，则命题成立；如果<span
class="math inline">\(r++ = q\)</span>，那么<span
class="math inline">\(n++=mq+q=(m+1)q\)</span>，命题也成立。<span
class="math inline">\(\square\)</span></p>
<p><font color=green><strong>推论</strong>：对整数<span
class="math inline">\(n\)</span>和正自然数<span
class="math inline">\(q\)</span>，存在整数<span
class="math inline">\(m\)</span>和自然数<span
class="math inline">\(r\)</span>，使得<span class="math inline">\(0 \leq
r &lt; q\)</span>且<span
class="math inline">\(n=mq+r\)</span>。</font></p>
<p><code>证明</code>：当整数<span class="math inline">\(n \geq
0\)</span>时，即<span
class="math inline">\(n\)</span>是自然数，上面的定理已经证明了。当整数<span
class="math inline">\(n &lt; 0\)</span>时，可知它的负数<span
class="math inline">\(-n\)</span>为自然数，满足上面的定理，则<span
class="math inline">\(-n=mq+r\)</span>，即<span
class="math inline">\(n=-(mq+r)=(-m)q+(-r)\)</span>。当<span
class="math inline">\(r=0\)</span>时，得证；当<span
class="math inline">\(r\neq 0\)</span>时，因为<span
class="math inline">\(0 &lt; r &lt; q\)</span>，可得<span
class="math inline">\(0 &lt; (q-r) &lt; q\)</span>，所以有<span
class="math inline">\(n=(-m-1)q+(q-r)\)</span>，得证。<span
class="math inline">\(\square\)</span></p>
<h3 id="整除">1）整除</h3>
<p><strong>定义（整除、因数）</strong>：对整数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>，如果存在整数<span
class="math inline">\(c\)</span>，使得<span
class="math inline">\(a=bc\)</span>，那么称<span
class="math inline">\(a\)</span>被<span
class="math inline">\(b\)</span>整除、<span
class="math inline">\(b\)</span>整除<span
class="math inline">\(a\)</span>、<span
class="math inline">\(b\)</span>是<span
class="math inline">\(a\)</span>的因数、<span
class="math inline">\(a\)</span>是<span
class="math inline">\(b\)</span>的倍数，记作<span
class="math inline">\(b\mid a\)</span>。当<span
class="math inline">\(b\)</span>不整除<span
class="math inline">\(a\)</span>时，记作<span
class="math inline">\(b\nmid a\)</span>。</p>
<p><font color=blue><strong>引理（整除的性质）</strong>：<span
class="math inline">\(b\mid a \iff (-b)\mid a \iff b\mid (-a) \iff
(-b)\mid (-a)\)</span></font></p>
<p><code>证明</code>：由<span
class="math inline">\(a=bc=(-b)(-c)\)</span>以及<span
class="math inline">\(-a=-(bc)=(-b)c=b(-c)\)</span>，即证。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\(b\mid a\)</span>且<span
class="math inline">\(c\mid b\)</span>，那么<span
class="math inline">\(c\mid a\)</span>。</font></p>
<p><code>证明</code>：根据整除的定义，存在整数<span
class="math inline">\(d\)</span>和<span
class="math inline">\(e\)</span>，使得<span
class="math inline">\(a=bd\)</span>且<span
class="math inline">\(b=ce\)</span>，即<span
class="math inline">\(a=(ce)d=c(ed)\)</span>，所以<span
class="math inline">\(c\mid a\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（绝对值）</strong>：整数<span
class="math inline">\(a\)</span>的绝对值<span
class="math inline">\(|a|\)</span>，定义为当<span
class="math inline">\(a &gt; 0\)</span>时，<span
class="math inline">\(|a|=a\)</span>；当<span class="math inline">\(a =
0\)</span>时，<span class="math inline">\(|a|=0\)</span>；当<span
class="math inline">\(a &lt; 0\)</span>时，<span
class="math inline">\(|a|=-a\)</span>。</p>
<p><font color=green><strong>推论</strong>：如果<span
class="math inline">\(|a| &lt; |b| \wedge |b| \mid
|a|\)</span>，那么<span class="math inline">\(a=0\)</span>。</font></p>
<p><code>证明</code>：根据绝对值的定义，易知整数的绝对值为自然数。由<span
class="math inline">\(|b| \mid |a|\)</span>，可知存在整数<span
class="math inline">\(c\)</span>，使得<span
class="math inline">\(|a|=|b|c\)</span>，易知<span
class="math inline">\(c\geq 0\)</span>。但是当<span
class="math inline">\(c &gt; 0\)</span>即<span class="math inline">\(c
\geq 1\)</span>时，<span class="math inline">\(|a| &lt; |b| \leq
|b|c\)</span>，与<span
class="math inline">\(|a|=|b|c\)</span>矛盾。因此只能有<span
class="math inline">\(c = 0\)</span>，此时<span
class="math inline">\(|a|=|b|\times 0 =
0\)</span>，根据绝对值的定义，即<span class="math inline">\(a =
0\)</span>。<span class="math inline">\(\square\)</span></p>
<p><font color=green><strong>推论</strong>：如果对自然数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>，<span class="math inline">\(b\mid a
\wedge a\neq 0\)</span>，那么<span class="math inline">\(0 &lt; b \leq
a\)</span>。即一个正整数的因数小于等于其自身。</font></p>
<p><code>证明</code>：因为<span
class="math inline">\(b\)</span>是自然数，所以<span
class="math inline">\(b \geq 0\)</span>。如果<span
class="math inline">\(b = 0\)</span>，由整除的定义，有<span
class="math inline">\(a=0\)</span>，矛盾，所以<span
class="math inline">\(b &gt; 0\)</span>。假设<span
class="math inline">\(b &gt; a\)</span>，根据上一个推论，可得<span
class="math inline">\(a=0\)</span>，矛盾，所以<span
class="math inline">\(0 &lt; b \leq a\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=green><strong>推论</strong>：对整数<span
class="math inline">\(n\)</span>和正自然数<span
class="math inline">\(q\)</span>，使得<span class="math inline">\(0 \leq
r &lt; q\)</span>且<span
class="math inline">\(n=mq+r\)</span>的整数<span
class="math inline">\(m\)</span>和自然数<span
class="math inline">\(r\)</span>是唯一的。</font></p>
<p><code>证明</code>：假设还存在一组整数<span
class="math inline">\(m&#39;\)</span>和自然数<span
class="math inline">\(r&#39;\)</span>也满足<span
class="math inline">\(n=m&#39;q+r&#39;\)</span>。则有<span
class="math inline">\(mq+r=m&#39;q+r&#39;\)</span>，即<span
class="math inline">\((m-m&#39;)q=r&#39;-r\)</span>，所以<span
class="math inline">\(q \mid
(r&#39;-r)\)</span>。根据引理和绝对值的定义有<span
class="math inline">\(q \mid |r&#39;-r|\)</span>，根据<span
class="math inline">\(0 \leq r,r&#39; &lt; q\)</span>，易知<span
class="math inline">\(|r&#39;-r| &lt; q\)</span>，又因为<span
class="math inline">\(q\)</span>是正自然数有<span
class="math inline">\(q=|q|\)</span>，所以根据上面的推论有<span
class="math inline">\(r&#39;-r = 0\)</span>，即<span
class="math inline">\(r&#39;=r\)</span>。所以<span
class="math inline">\((m-m&#39;)q=r&#39;-r=0\)</span>，因为<span
class="math inline">\(q\)</span>是正自然数，所以只能是<span
class="math inline">\(m-m&#39; = 0\)</span>，即<span
class="math inline">\(m=m&#39;\)</span>。<span
class="math inline">\(\square\)</span></p>
<h3 id="质数">2）质数</h3>
<p><strong>定义（质数）</strong>：如果<span
class="math inline">\(a\)</span>是一个大于<span
class="math inline">\(1\)</span>的整数（当然也是自然数），除了1和此数自身外，无法被其他自然数整除（其他自然数都不是<span
class="math inline">\(a\)</span>的因数），则称<span
class="math inline">\(a\)</span>为质数，又称素数。</p>
<p><strong>定义（合数）</strong>：如果<span
class="math inline">\(a\)</span>是一个大于<span
class="math inline">\(1\)</span>的整数，且<span
class="math inline">\(a\)</span>不是质数，则称<span
class="math inline">\(a\)</span>为合数。因此，合数<span
class="math inline">\(a\)</span>存在除了<span
class="math inline">\(1\)</span>和<span
class="math inline">\(a\)</span>外的其他因数。</p>
<p><font color=green><strong>推论</strong>：对自然数<span
class="math inline">\(a\)</span>，下面三个命题有且仅有一个成立：（1）<span
class="math inline">\(a=1\)</span>；（2）<span
class="math inline">\(a\)</span>是质数；（3）<span
class="math inline">\(a\)</span>是合数。</font></p>
<p><strong>定义（质因数）</strong>：如果<span
class="math inline">\(a\)</span>的因数<span
class="math inline">\(b\)</span>是质数，那么称<span
class="math inline">\(b\)</span>是<span
class="math inline">\(a\)</span>的质因数。</p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\(a\)</span>是一个大于<span
class="math inline">\(1\)</span>的整数，那么<span
class="math inline">\(a\)</span>的大于<span
class="math inline">\(1\)</span>的最小因数一定是质数。</font></p>
<p><code>证明</code>：因为<span
class="math inline">\(a\)</span>是一个大于<span
class="math inline">\(1\)</span>的整数，所以<span
class="math inline">\(a\)</span>要么是质数、要么是合数。如果<span
class="math inline">\(a\)</span>是质数，则<span
class="math inline">\(a\)</span>只有因数<span
class="math inline">\(1\)</span>和自身<span
class="math inline">\(a\)</span>，所以大于<span
class="math inline">\(1\)</span>的最小因数就是<span
class="math inline">\(a\)</span>，是质数；如果<span
class="math inline">\(a\)</span>是合数，假设大于<span
class="math inline">\(1\)</span>的最小因数<span
class="math inline">\(b\)</span>不是质数而是合数，那么根据合数的定义，<span
class="math inline">\(b\)</span>存在不等于<span
class="math inline">\(1\)</span>和其自身的因数<span
class="math inline">\(c\)</span>，又因为自然数的因数小于等于其自身，同时<span
class="math inline">\(b\)</span>的因数<span
class="math inline">\(c\)</span>也是<span
class="math inline">\(a\)</span>的因数，即<span
class="math inline">\(a\)</span>存在比<span
class="math inline">\(b\)</span>更小的大于<span
class="math inline">\(1\)</span>的因数，与假设矛盾，所以<span
class="math inline">\(b\)</span>是质数。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>定理</strong>：有无限多个质数。</font></p>
<p><code>证明</code>：（欧几里得证明）假设有限个质数的集合<span
class="math inline">\(\lbrace p_1, \dots, p_r
\rbrace\)</span>，考虑<span class="math inline">\(n=p_1 p_2 \dots p_r +
1\)</span>，其中<span class="math inline">\(p_1 p_2 \dots
p_r\)</span>是从<span class="math inline">\(p_1\)</span>到<span
class="math inline">\(p_r\)</span>的连乘积（遍历集合）。取<span
class="math inline">\(n\)</span>的质因数<span
class="math inline">\(p\)</span>，可以证明<span
class="math inline">\(p\)</span>不属于集合<span
class="math inline">\(\lbrace p_1, \dots, p_r
\rbrace\)</span>，否则<span class="math inline">\(p\)</span>是<span
class="math inline">\(p_1 p_2 \dots p_r\)</span>的因数，那么也是<span
class="math inline">\(n-p_1 p_2 \dots p_r =
1\)</span>的因数，矛盾。从而任何有限集合<span
class="math inline">\(\lbrace p_1, \dots, p_r
\rbrace\)</span>不可能包括所有的素数。<span
class="math inline">\(\square\)</span></p>
<p>这个定理，也是《数学天书中的证明》中的第一个证明，该书中还给出了其他五种证明方法，有兴趣的可以看一看。</p>
<p><strong>定义（公因数、最大公因数）</strong>：如果正整数<span
class="math inline">\(c\)</span>即是<span
class="math inline">\(a\)</span>的因数又是<span
class="math inline">\(b\)</span>的因数，那么称<span
class="math inline">\(c\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公因数，又称公约数。<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公因数中最大的数，称为最大公因数，记作<span
class="math inline">\(gcd(a,b)\)</span>，简记为<span
class="math inline">\((a,b)\)</span>。</p>
<p>对多个整数的最大公因数记为<span
class="math inline">\((a_1,a_2,\dots,a_n)\)</span>或<span
class="math inline">\(gcd(a_1,a_2,\dots,a_n)\)</span>。</p>
<p><font color=blue><strong>引理（欧几里得算法、辗转相除法）</strong>：如果<span
class="math inline">\(a=bq+r\)</span>，那么<span
class="math inline">\((a,b)=(b,r)\)</span>。</font></p>
<p><code>证明</code>：设<span class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的最大公因数为<span
class="math inline">\(c\)</span>，则存在整数<span
class="math inline">\(a&#39;\)</span>和<span
class="math inline">\(b&#39;\)</span>满足<span
class="math inline">\(a=ca&#39;\)</span>和<span
class="math inline">\(b=cb&#39;\)</span>，代入<span
class="math inline">\(a=bq+r\)</span>有<span
class="math inline">\(ca&#39;=cb&#39;q+r\)</span>，即<span
class="math inline">\(r=ca&#39;-cb&#39;q=c(a&#39;-b&#39;q)\)</span>，所以<span
class="math inline">\(c\)</span>是<span
class="math inline">\(r\)</span>的因数，也是<span
class="math inline">\(b\)</span>和<span
class="math inline">\(r\)</span>的公因数。假设<span
class="math inline">\(c\)</span>不是<span
class="math inline">\(b\)</span>和<span
class="math inline">\(r\)</span>的最大公因数，那么还存在正整数<span
class="math inline">\(c&#39;&gt;c\)</span>是<span
class="math inline">\(b\)</span>和<span
class="math inline">\(r\)</span>的最大公因数，由<span
class="math inline">\(a=bq+r\)</span>可知<span
class="math inline">\(c&#39;\)</span>也是<span
class="math inline">\(a\)</span>的因数，同时也是<span
class="math inline">\(b\)</span>的因数，这与<span
class="math inline">\(c\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的最大公因数矛盾。<span
class="math inline">\(\square\)</span></p>
<p><strong>定义（互质）</strong>：如果<span
class="math inline">\((a,b)=1\)</span>，那么称整数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>互质。</p>
<p><strong>定义（公倍数、最小公倍数）</strong>：如果正整数<span
class="math inline">\(c\)</span>即是<span
class="math inline">\(a\)</span>的倍数又是<span
class="math inline">\(b\)</span>的倍数，那么称<span
class="math inline">\(c\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公倍数。<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公倍数中最小的数，称为最小公倍数，记作<span
class="math inline">\(lcm(a,b)\)</span>，简记为<span
class="math inline">\(\lbrace a,b\rbrace\)</span>。</p>
<p><font color=green><strong>推论</strong>：最小公倍数是公倍数的因数。</font></p>
<p><code>证明</code>：设<span class="math inline">\(m = \lbrace
a,b\rbrace\)</span>和公倍数<span class="math inline">\(m&#39; \geq
m\)</span>，存在整数<span class="math inline">\(q\)</span>和<span
class="math inline">\(r\)</span>满足<span
class="math inline">\(m&#39;=qm+r\)</span>且<span
class="math inline">\(0\leq r &lt; m\)</span>。假设<span
class="math inline">\(r\neq 0\)</span>，因为<span
class="math inline">\(a\)</span>即是<span
class="math inline">\(m\)</span>的因数又是<span
class="math inline">\(m&#39;\)</span>的因数，所以<span
class="math inline">\(a\)</span>也是<span
class="math inline">\(r=m&#39;-qm\)</span>的因数，同理<span
class="math inline">\(b\)</span>也是<span
class="math inline">\(r\)</span>的因数，即<span
class="math inline">\(r\)</span>也是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公倍数且<span class="math inline">\(r
&lt; m\)</span>，与<span
class="math inline">\(m\)</span>是最小公倍数矛盾。所以<span
class="math inline">\(r = 0\)</span>，<span
class="math inline">\(m&#39;=qm\)</span>即<span
class="math inline">\(m\)</span>是任意公倍数<span
class="math inline">\(m&#39;\)</span>的因数。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的最大公因数是<span
class="math inline">\(d\)</span>、最小公倍数是<span
class="math inline">\(m\)</span>，那么有<span
class="math inline">\(ab=dm\)</span>。</font></p>
<p><code>证明</code>：因为<span class="math inline">\(ab\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公倍数，所以最小公倍数<span
class="math inline">\(m \mid ab\)</span>，即存在整数<span
class="math inline">\(q\)</span>，使得<span class="math inline">\(ab =
qm\)</span>。下面证明<span
class="math inline">\(q\)</span>即最大公因数是<span
class="math inline">\(d\)</span>。首先对最小公倍数<span
class="math inline">\(m\)</span>，存在整数<span
class="math inline">\(a&#39;\)</span>和<span
class="math inline">\(b&#39;\)</span>，使得<span class="math inline">\(m
= aa&#39;\)</span>且<span class="math inline">\(m =
bb&#39;\)</span>，所以<span class="math inline">\(ab = qm = qaa&#39; =
qbb&#39;\)</span>，即<span class="math inline">\(a =
qb&#39;\)</span>且<span class="math inline">\(b =
qa&#39;\)</span>，所以<span class="math inline">\(q\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公因数。然后对<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的任意公因数<span
class="math inline">\(c\)</span>，有<span
class="math inline">\(a=cc&#39;\)</span>及<span
class="math inline">\(b=cc&#39;&#39;\)</span>，设整数<span
class="math inline">\(t=cc&#39;c&#39;&#39;=ac&#39;&#39;=bc&#39;\)</span>，所以<span
class="math inline">\(t\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公倍数。根据最小公倍数是公倍数的因数，即存在<span
class="math inline">\(t&#39; \geq 1\)</span>使得<span
class="math inline">\(t=mt&#39;\)</span>，由<span
class="math inline">\(ab = qm\)</span>得<span
class="math inline">\(abt&#39; = qmt&#39; = qt\)</span>且<span
class="math inline">\(abt&#39; = cc&#39;cc&#39;&#39;t&#39; =
ctt&#39;\)</span>，即<span
class="math inline">\(ct&#39;=q\)</span>，所以对任意公因数<span
class="math inline">\(c\)</span>都有<span class="math inline">\(c \leq
q\)</span>，即<span class="math inline">\(q\)</span>是最大公因数。<span
class="math inline">\(\square\)</span></p>
<h3 id="算术基本定理">3）算术基本定理</h3>
<p><font color=blue><strong>定理（强归纳法）</strong>：令<span
class="math inline">\(P(n)\)</span>表示对自然数的任意一个命题，如果<span
class="math inline">\(P(0)\)</span>为真且当<span
class="math inline">\(\forall n \leq m: P(n)\)</span>为真时有<span
class="math inline">\(P(m++)\)</span>也为真，那么对任意自然数<span
class="math inline">\(n\)</span>，都有<span
class="math inline">\(P(n)\)</span>为真。</font></p>
<p><code>证明</code>：当<span class="math inline">\(\forall n \leq m:
P(n)\)</span>为真时，显然有<span
class="math inline">\(P(m)\)</span>为真，根据数学归纳法有强归纳法成立。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>定理（超限归纳法）</strong>：令<span
class="math inline">\(P(n)\)</span>表示对自然数的任意一个命题，如果当<span
class="math inline">\(\forall n &lt; m: P(n)\)</span>为真时有<span
class="math inline">\(P(m)\)</span>也为真，那么对任意自然数<span
class="math inline">\(n\)</span>，都有<span
class="math inline">\(P(n)\)</span>为真。</font></p>
<p><code>证明</code>：当<span
class="math inline">\(m=0\)</span>时，自然数<span
class="math inline">\(n&lt;0\)</span>是一个恒假命题，所以<span
class="math inline">\(\forall n &lt; 0: P(n) \implies
P(0)\)</span>恒为真。因此超限归纳法与强归纳法在命题上是等价的。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：每一个大于<span
class="math inline">\(1\)</span>的整数<span
class="math inline">\(a\)</span>都可以分解成质因数的连乘积。</font></p>
<p><code>证明</code>：超限归纳法，假设<span
class="math inline">\(\forall a &lt; n\)</span>时，大于<span
class="math inline">\(1\)</span>的整数<span
class="math inline">\(a\)</span>都可以分解成质因数的连乘积，考虑<span
class="math inline">\(a=n\)</span>。如果<span
class="math inline">\(n\)</span>是质数<span
class="math inline">\(p\)</span>，则<span
class="math inline">\(n=p\)</span>就满足了分解成质因数的连乘积形式。如果<span
class="math inline">\(n\)</span>是合数，则<span
class="math inline">\(n\)</span>存在大于<span
class="math inline">\(1\)</span>的最小质因数<span
class="math inline">\(p_1\)</span>，即存在整数<span
class="math inline">\(b\)</span>使得<span class="math inline">\(n= p_1
b\)</span>，显然有<span class="math inline">\(b &lt;
n\)</span>，所以根据归纳假设，<span
class="math inline">\(b\)</span>可以分解成质因数的连乘积<span
class="math inline">\(b = p_2 \dots p_r\)</span>，而<span
class="math inline">\(p_1\)</span>是质数，所以<span
class="math inline">\(n=p_1 p_2 \dots
p_r\)</span>也可以分解成质因数的连乘积。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：对质数<span
class="math inline">\(p\)</span>，<span class="math inline">\(p \nmid a
\iff (p,a)=1\)</span>。</font></p>
<p><code>证明</code>：如果<span class="math inline">\(p \nmid
a\)</span>，即<span class="math inline">\(p\)</span>不是<span
class="math inline">\(a\)</span>因数，因为质数<span
class="math inline">\(p\)</span>只有两个因数<span
class="math inline">\(1\)</span>和自身<span
class="math inline">\(p\)</span>，所以<span
class="math inline">\(a\)</span>和<span
class="math inline">\(p\)</span>只有一个公因数<span
class="math inline">\(1\)</span>，即<span
class="math inline">\((p,a)=1\)</span>；如果<span
class="math inline">\((p,a)=1\)</span>，那么运用反证法，可知质数<span
class="math inline">\(p\)</span>不是<span
class="math inline">\(a\)</span>的因数，所以<span
class="math inline">\(p \nmid a\)</span>。</p>
<p>也可以证明等价的逆否命题：<span class="math inline">\(p \mid a \iff
(p,a)\neq 1\)</span>。如果<span class="math inline">\(p \mid
a\)</span>，那么<span class="math inline">\(p\)</span>是<span
class="math inline">\(a\)</span>的因数且显然<span
class="math inline">\(p\)</span>是<span
class="math inline">\(p\)</span>的因数，所以<span
class="math inline">\(p\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(p\)</span>的公因数，即<span
class="math inline">\((p,a)\neq 1\)</span>；如果<span
class="math inline">\((p,a)\neq 1\)</span>，设<span
class="math inline">\((p,a) = q\)</span>，则<span
class="math inline">\(q\)</span>是<span
class="math inline">\(p\)</span>的因数，根据质数的定义，<span
class="math inline">\(p\)</span>的因数除了<span
class="math inline">\(1\)</span>就是<span
class="math inline">\(p\)</span>，所以<span
class="math inline">\(q=p\)</span>，即<span
class="math inline">\(p\)</span>也是<span
class="math inline">\(a\)</span>的因数，所以<span
class="math inline">\(p \mid a\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\((a,b)=1\)</span>且<span class="math inline">\(a
\mid bc\)</span>，那么<span class="math inline">\(a \mid
c\)</span>。</font></p>
<p><code>证明</code>：因为<span
class="math inline">\((a,b)=1\)</span>，根据<span
class="math inline">\(ab=(a,b)\lbrace a,b
\rbrace\)</span>，可得最小公倍数<span class="math inline">\(\lbrace a,b
\rbrace = ab\)</span>。同时，根据<span class="math inline">\(a \mid
bc\)</span>且<span class="math inline">\(b \mid bc\)</span>，所以<span
class="math inline">\(bc\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公倍数。由最小公倍数是公倍数的因数，即存在整数<span
class="math inline">\(d\)</span>，使得<span
class="math inline">\(bc=abd\)</span>，利用乘法消去律，即<span
class="math inline">\(c=ad\)</span>，所以<span class="math inline">\(a
\mid c\)</span>。<span class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：当<span
class="math inline">\(a \mid b_1 \dots b_n\)</span>且<span
class="math inline">\(a\)</span>与任意<span
class="math inline">\(b_1,\dots,b_{n-1}\)</span>互质，那么<span
class="math inline">\(a \mid b_n\)</span>。</font></p>
<p><code>证明</code>：因为<span
class="math inline">\((a,b_1)=1\)</span>且<span class="math inline">\(a
\mid b_1(b_2\dots b_n)\)</span>，所以<span class="math inline">\(a \mid
b_2\dots b_n\)</span>。对<span
class="math inline">\(b_2,\dots,b_{n-1}\)</span>依次运用引理，因为<span
class="math inline">\(n\)</span>是有限的，最终可以得到<span
class="math inline">\(a \mid b_n\)</span>。</p>
<p>现在大家肯定觉得这样证明不够严谨，因为我们没有定义什么叫“依次”。所以可以把引理改写为：当<span
class="math inline">\(a \mid b_1 \dots b_n q\)</span>且<span
class="math inline">\(a\)</span>与任意<span
class="math inline">\(b_1,\dots,b_n\)</span>互质，那么<span
class="math inline">\(a \mid q\)</span>。对<span
class="math inline">\(n\)</span>使用数学归纳法，首先当<span
class="math inline">\(n=0\)</span>时，即<span class="math inline">\(b_1
\dots b_n q = q\)</span>，直接得证<span class="math inline">\(a \mid
q\)</span>；假设当<span
class="math inline">\(n\)</span>时命题成立，考虑<span
class="math inline">\(n+1\)</span>，即<span class="math inline">\(a \mid
b_1 \dots b_n b_{n+1} q\)</span>，根据归纳假设，可知<span
class="math inline">\(a \mid b_{n+1} q\)</span>，因为<span
class="math inline">\(a\)</span>与<span
class="math inline">\(b_{n+1}\)</span>互质，根据上面的引理，可得<span
class="math inline">\(a \mid q\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\((a,b)=1\)</span>且<span class="math inline">\(c
\mid a\)</span>，那么<span
class="math inline">\((b,c)=1\)</span>。</font></p>
<p><code>证明</code>：反证法，假设<span class="math inline">\((b,c)=m
\neq 1\)</span>。那么<span class="math inline">\(m\)</span>是<span
class="math inline">\(c\)</span>的因数，因为<span
class="math inline">\(c \mid a\)</span>，所以<span
class="math inline">\(m\)</span>也是<span
class="math inline">\(a\)</span>的因数，即<span class="math inline">\(m
&gt; 1\)</span>是<span class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的公因数，这与<span
class="math inline">\((a,b)=1\)</span>矛盾。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：如果<span
class="math inline">\((a,b)=1\)</span>，那么<span
class="math inline">\((a,bc)=(a,c)\)</span>。</font></p>
<p><code>证明</code>：设<span
class="math inline">\((a,bc)=d\)</span>，因为<span
class="math inline">\((a,b)=1\)</span>且<span class="math inline">\(d
\mid a\)</span>，则<span
class="math inline">\((d,b)=1\)</span>，同时<span
class="math inline">\(d \mid bc\)</span>，则<span
class="math inline">\(d \mid c\)</span>，所以<span
class="math inline">\(d\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(c\)</span>的公因数。设<span
class="math inline">\((a,c)=t\)</span>，因为<span
class="math inline">\(t \mid c\)</span>，则<span class="math inline">\(t
\mid bc\)</span>，所以<span class="math inline">\(t\)</span>是<span
class="math inline">\(a\)</span>和<span
class="math inline">\(bc\)</span>的公因数。根据最大公因数的定义，有<span
class="math inline">\(d \leq t\)</span>且<span class="math inline">\(t
\leq d\)</span>，所以<span class="math inline">\(d=t\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：<span
class="math inline">\(a\)</span>与任意<span
class="math inline">\(b_1,\dots,b_n\)</span>互质，则<span
class="math inline">\(a\)</span>与<span class="math inline">\(b_1,
\dots, b_n\)</span>的连乘积互质。</font></p>
<p><code>证明</code>：因为<span
class="math inline">\((a,b_1)=1\)</span>，所以<span
class="math inline">\((a,b_1 b_2\dots b_n)=(a,b_2\dots
b_n)\)</span>。对<span
class="math inline">\(b_2,\dots,b_{n-1}\)</span>依次运用引理，因为<span
class="math inline">\(n\)</span>是有限的，最终可以得到<span
class="math inline">\((a,b_1 \dots b_n)=(a,b_n)=1\)</span>。</p>
<p>同样地，更严谨地可以对<span
class="math inline">\(n\)</span>使用超限归纳法证明<span
class="math inline">\(\forall n:(a,b_n)=1 \implies (a, b_1 b_2\dots
b_n)=1\)</span>。假设当<span
class="math inline">\(n&lt;m\)</span>时命题成立，考虑<span
class="math inline">\(n=m\)</span>，根据归纳假设<span
class="math inline">\((a,b_1 \dots
b_{m-1})=1\)</span>，根据上一条引理，可知<span
class="math inline">\((a,b_1 \dots b_{m-1}b_m)=(a,b_m)=1\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：如果质数<span
class="math inline">\(p\)</span>整除<span class="math inline">\(a_1,
\dots, a_n\)</span>的连乘积，那么存在一个<span
class="math inline">\(a_r\)</span>能被<span
class="math inline">\(p\)</span>整除（<span class="math inline">\(1 \leq
r \leq n\)</span>）。</font></p>
<p><code>证明</code>：反证法，假设不存在<span
class="math inline">\(a_r\)</span>能被<span
class="math inline">\(p\)</span>整除，所以任意<span
class="math inline">\(a_r\)</span>与<span
class="math inline">\(p\)</span>互质。根据上面的引理，可知<span
class="math inline">\(p\)</span>与<span class="math inline">\(a_1,
\dots, a_n\)</span>的连乘积互质，这与质数<span
class="math inline">\(p\)</span>整除<span class="math inline">\(a_1,
\dots, a_n\)</span>的连乘积矛盾。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>引理</strong>：如果质数<span
class="math inline">\(p\)</span>整除质数<span
class="math inline">\(p,\dots,p_n\)</span>的连乘积，那么存在一个<span
class="math inline">\(p_r=p\)</span>（<span class="math inline">\(1 \leq
r \leq n\)</span>）。</font></p>
<p><code>证明</code>：根据上面的引可知存在一个<span
class="math inline">\(p_r\)</span>能被<span
class="math inline">\(p\)</span>整除，因为<span
class="math inline">\(p_r\)</span>和<span
class="math inline">\(p\)</span>都是质数，根据质数的定义，只能有<span
class="math inline">\(p_r=p\)</span>。<span
class="math inline">\(\square\)</span></p>
<p><font color=blue><strong>定理（算术基本定理）</strong>：不计质因数的次序，则只有唯一的方式将大于<span
class="math inline">\(1\)</span>的整数分解为质因数的连乘积。</font></p>
<p><code>证明</code>：将整数分解为质因数的连乘积<span
class="math inline">\(a=p_1 \dots p_n\)</span>。假设存在另一种将<span
class="math inline">\(a\)</span>分解为不同质因数的连乘积，设为<span
class="math inline">\(a=q_1 \dots q_m\)</span>，即 <span
class="math display">\[p_1 \dots p_n=q_1 \dots q_m\]</span> 所以<span
class="math inline">\(p_1 \mid q_1 \dots
q_m\)</span>，根据上一条引理，存在一个<span
class="math inline">\(q_r=p_1\)</span>，因为不考虑分解的次序，不失一般性，可以设这个<span
class="math inline">\(q_r\)</span>就是<span
class="math inline">\(q_1\)</span>，则有<span class="math inline">\(p_2
\dots p_n=q_2 \dots q_m\)</span>。这样依次运用引理，且<span
class="math inline">\(n\)</span>和<span
class="math inline">\(m\)</span>是有限的，最后肯定得到<span
class="math inline">\(p_n=q_m\)</span>且<span
class="math inline">\(n=m\)</span>。</p>
<p>更严谨地，可以使用集合论的语言。定义质数集为<span
class="math inline">\(\mathbf{P}\)</span>，因为可以把整数<span
class="math inline">\(n\)</span>分解为质因数的连乘积，这些质因数的集合设为<span
class="math inline">\(A = \lbrace p \in \mathbf{P} | p \mid a \rbrace =
\lbrace p_1,\dots,p_r
\rbrace\)</span>，注意到某个质因数可能在分解的连乘积中出现多次，同时考虑到这个集合是有限的，所以可以将质因数从小到大排列，即<span
class="math inline">\(p_1 &lt; \dots &lt;
p_r\)</span>，运用指数运算可以将分解式表示为：<span
class="math inline">\(a=p_1 ^{\alpha_1} \dots p_r
^{\alpha_r}\)</span>，其中<span
class="math inline">\(\alpha_1,\dots,\alpha_r\)</span>是正自然数。</p>
<p>为了方便，先证明一个引理：质数<span
class="math inline">\(p\)</span>的<span
class="math inline">\(\alpha\)</span>次方（<span
class="math inline">\(\alpha \geq 1\)</span>）整除<span
class="math inline">\(a\)</span>，当且仅当分解的连乘积<span
class="math inline">\(a=p_1 ^{\alpha_1} \dots p_n
^{\alpha_n}\)</span>中，存在一个<span
class="math inline">\(p_r=p\)</span>且<span class="math inline">\(\alpha
\leq \alpha_r\)</span>（<span class="math inline">\(1 \leq r \leq
n\)</span>）。首先，当存在<span
class="math inline">\(p_r=p\)</span>且<span class="math inline">\(\alpha
\leq \alpha_r\)</span>时，显然有<span class="math inline">\(p^{\alpha}
\mid a\)</span>。然后，根据<span class="math inline">\(p^{\alpha} \mid
a\)</span>且<span class="math inline">\(p \mid
p^{\alpha}\)</span>（<span class="math inline">\(\alpha \geq
1\)</span>），有<span class="math inline">\(p \mid
a\)</span>，所以根据上面的引理存在一个<span class="math inline">\(p_r =
p\)</span>。假设<span class="math inline">\(\alpha &gt;
\alpha_r\)</span>，则根据整除的定义，存在一个整数<span
class="math inline">\(b\)</span>使得<span
class="math inline">\(a=bp^{\alpha}=bp_r ^{\alpha} = p_1 ^{\alpha_1}
\dots p_n ^{\alpha_n}\)</span>，利用乘法消去律，左右消去<span
class="math inline">\(p_r^{\alpha_r}\)</span>，有<span
class="math inline">\(bp_r ^{\alpha - \alpha_r} = p_1 ^{\alpha_1} \dots
p_{r-1} ^{\alpha_{r-1}} p_{r+1} ^{\alpha_{r+1}} \dots p_n
^{\alpha_n}\)</span>且<span class="math inline">\(\alpha - \alpha_r \geq
1\)</span>，即<span class="math inline">\(p_r ^{\alpha - \alpha_r} \mid
p_1 ^{\alpha_1} \dots p_{r-1} ^{\alpha_{r-1}} p_{r+1} ^{\alpha_{r+1}}
\dots p_n ^{\alpha_n}\)</span>，所以仍然存在一个<span
class="math inline">\(p_i=p\)</span>（<span class="math inline">\(1 \leq
i \leq n\)</span>且<span class="math inline">\(i \neq
r\)</span>），这与分解的连乘积中的质因数两两不等矛盾，所以<span
class="math inline">\(\alpha \leq \alpha_r\)</span>。</p>
<p>构造集合<span class="math inline">\(B = \lbrace &lt;p, \alpha&gt; \in
\mathbf{P}\times \mathbf{N} | \forall p \in \mathbf{P},\forall \alpha
\in \mathbf{N} \wedge \alpha \geq 1: p^{\alpha} \mid a \wedge
p^{\alpha+1} \nmid a \rbrace\)</span>，即集合<span
class="math inline">\(B\)</span>的元素是由满足质因数<span
class="math inline">\(p\)</span>的<span
class="math inline">\(\alpha\)</span>次方整除<span
class="math inline">\(a\)</span>但<span
class="math inline">\(p\)</span>的<span
class="math inline">\(\alpha+1\)</span>次方不整除<span
class="math inline">\(a\)</span>的有序对<span
class="math inline">\(&lt;p, \alpha&gt;\)</span>组成的。</p>
<p>现在要证明质因数的连乘积分解式<span class="math inline">\(a=p_1
^{\alpha_1} \dots p_r ^{\alpha_r}\)</span>右边的指数项，与集合<span
class="math inline">\(B\)</span>中的元素是一一对应的。</p>
<p>首先对任意一个质因数<span class="math inline">\(p_i \in
A\)</span>，根据连乘积分解式，显然满足<span class="math inline">\(p_i
^{\alpha_i} \mid a\)</span>。如果假设<span class="math inline">\(p_i
^{\alpha_i+1} \mid a\)</span>，利用引理可知存在矛盾，所以分解式<span
class="math inline">\(a=p_1 ^{\alpha_1} \dots p_r
^{\alpha_r}\)</span>右边的任意一个指数项<span class="math inline">\(p_i
^{\alpha_i}\)</span>所对应的有序对<span class="math inline">\(&lt;p_i,
\alpha_i&gt;\)</span>都是集合<span
class="math inline">\(B\)</span>的元素。</p>
<p>然后，要证明集合<span class="math inline">\(B\)</span>的任意元素<span
class="math inline">\(&lt;p, \alpha&gt;\)</span>所对应的所有指数项<span
class="math inline">\(p ^{\alpha}\)</span>的积等于<span
class="math inline">\(a\)</span>，即集合<span
class="math inline">\(B\)</span>中不存在多余的元素<span
class="math inline">\(&lt;q, \beta&gt;\)</span>其对应的指数项<span
class="math inline">\(q ^{\beta}\)</span>不在连乘积的分解式<span
class="math inline">\(a=p_1 ^{\alpha_1} \dots p_r
^{\alpha_r}\)</span>中。</p>
<p>我们假设集合<span
class="math inline">\(B\)</span>存在这样多余的元素<span
class="math inline">\(&lt;q, \beta&gt;\)</span>。根据集合<span
class="math inline">\(B\)</span>的定义<span
class="math inline">\(q^{\beta} \mid a\)</span>，根据引理即存在一个<span
class="math inline">\(p_i = q\)</span>且<span
class="math inline">\(\beta \leq \alpha_i\)</span>。又根据集合<span
class="math inline">\(B\)</span>的定义，有<span
class="math inline">\(q^{\beta+1} \nmid a\)</span>即<span
class="math inline">\(p_i^{\beta+1} \nmid
a\)</span>，所以根据引理的逆否命题，有<span
class="math inline">\(\beta+1 &gt; \alpha_i\)</span>，即<span
class="math inline">\(\beta \geq \alpha_i\)</span>，因此<span
class="math inline">\(\beta = \alpha_i\)</span>。</p>
<p>因此，质因数的连乘积分解式<span class="math inline">\(a=p_1
^{\alpha_1} \dots p_r ^{\alpha_r}\)</span>右边的指数项，与集合<span
class="math inline">\(B\)</span>中的元素是一一对应的。根据分类公理，可知集合<span
class="math inline">\(B\)</span>是唯一的，所以不计质因数的次序，将大于<span
class="math inline">\(1\)</span>的整数分解为质因数的连乘积的方式就是唯一。<span
class="math inline">\(\square\)</span></p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Elementary Math</tag>
        <tag>Set Theory</tag>
        <tag>Elementary Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令整理</title>
    <url>/2017/01/01/Git/</url>
    <content><![CDATA[<h2 id="git初始化">Git初始化</h2>
<p>Command line instructions 本地Git全局设置（Git global setup）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;your@email&quot;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>克隆新仓库（Create a new repository）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://your.repository.address.git</span><br><span class="line">cd repo</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>对于已经存在的文件夹（Existing folder）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin http://your.repository.address.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>对于本地已经存在的仓库（Existing Git repository）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote add origin http://your.repository.address.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure>
<h2 id="git忽略的文件">Git忽略的文件</h2>
<h3 id="查看所有被git忽略的文件">1. 查看所有被Git忽略的文件</h3>
<p>Git 1.6+:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git ls-files --others -i --exclude-standard</span><br></pre></td></tr></table></figure>
<p>Git 1.4, 1.5:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git ls-files --others -i \</span><br><span class="line">--exclude-from=&quot;`git rev-parse --git-dir`/info/exclude&quot; \</span><br><span class="line">--exclude-per-directory=.gitignore</span><br></pre></td></tr></table></figure>
<h3 id="清除所有被git忽略的文件或文件夹小心">2.
清除所有被Git忽略的文件或文件夹(小心)</h3>
<ul>
<li>查看在清理之前会做的操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clean -Xn</span><br></pre></td></tr></table></figure>
<ul>
<li>清除文件或文件夹， -f 选项强制删除，-d删除目录（小心）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clean -Xdf</span><br></pre></td></tr></table></figure>
<h2 id="git变更远程仓库地址">Git变更远程仓库地址</h2>
<h3 id="通过命令直接修改远程地址">1. 通过命令直接修改远程地址</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote // 查看所有远程仓库</span><br><span class="line">git remote set-url origin http://your.repository.address.git</span><br></pre></td></tr></table></figure>
<h3 id="通过命令先删除再添加远程仓库">2.
通过命令先删除再添加远程仓库</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote // 查看所有远程仓库</span><br><span class="line">git remote rm origin</span><br><span class="line">git remote add origin http://your.repository.address.git</span><br></pre></td></tr></table></figure>
<h2 id="git撤销已同步的远程提交">Git撤销已同步的远程提交</h2>
<p>先在本地回退到指定版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog // 查看commits记录</span><br><span class="line">git reset --hard &lt;版本号&gt; // 注意使用 --hard 参数会抛弃当前工作区的修改</span><br><span class="line">// git reset HEAD~1 // 撤回至上一个commit</span><br><span class="line">git push origin &lt;分支名&gt; --force</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title>超级账本Fabric 1.0 多节点集群的部署</title>
    <url>/2017/11/06/Fabric-Multiple-Nodes/</url>
    <content><![CDATA[<p><em>发布者: 币学院 发表于: 2017-7-4 16:40 原作者: 张海宁、陈家豪来自:
亨利笔记</em></p>
<h4 id="概述">1. 概述</h4>
<p>本文将介绍如何使用 Docker
容器技术来建立起一个多节点<code>Fabric</code>集群，并且描述在集群上如何进行基本的操作，如<code>chaincode</code>的生命周期维护等。文中采用Fabric
1.0的端到端（e2e_cli）示例作为基础来说明原理。本文提供是手动配置的方法，后续将介绍利用容器平台（如
K8s 等）自动部署超级账本的方式。</p>
<span id="more"></span>
<img src="/2017/11/06/Fabric-Multiple-Nodes/4peer1orderLocal.jpg" class="" title="单节点下的Fabric网络结构图">
<p>Fabric
源码中包含一个简单的e2e单机部署示例，方便用户理解、研究和开发应用。如图1.1所示，在单个机器节点上通过
docker-compose 建立了5个节点的Fabric网络，每个节点都是由单独的 Docker
容器来模拟。其中 peer0 和 peer1 是同属于 org1 的节点，peer2 和 peer3
是同属于 org2 的节点，它们都加入了相同的 channel 中，并在该 channel
中进行交易，而 orderer 则为该 channel 中的交易提供排序服务。</p>
<img src="/2017/11/06/Fabric-Multiple-Nodes/4peer1order.jpg" class="" title="多节点下的Fabric网络结构图">
<p>虽然e2e_cli的示例比较简单，但它把多个节点混合部署在一起，无法区分哪些配置对应哪个节点。另外，在实际场景中，Fabric
节点可能会由不同的组织分别拥有和维护，peers 和 orderer
必然会分布在不同的物理节点上，因此多节点的Fabric
部署成为需要解决的问题</p>
<h4 id="单机运行hyperledger-fabric实例">2. 单机运行Hyperledger
Fabric实例</h4>
<p>需要安装Go，并下载Fabric源码 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install golang</span><br><span class="line">mkdir gocode/src/github.com/hyperledger/</span><br><span class="line">cd gocode/src/github.com/hyperledger/</span><br><span class="line">git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure> 记得配置环境变量
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ~/.profile</span><br><span class="line">export GOPATH=$HOME/gocode</span><br></pre></td></tr></table></figure> 下载docker
image，在<code>gocode/src/github.com/hyperledger/fabric</code>下执行
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make docker</span><br></pre></td></tr></table></figure> 可能需要执行 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch --all</span><br><span class="line">git fetch</span><br><span class="line">make clean</span><br><span class="line">make dist-clean</span><br><span class="line">make configtxgen</span><br><span class="line">make docker</span><br><span class="line">make peer-docker</span><br><span class="line">make orderer-docker</span><br><span class="line">make couchdb</span><br></pre></td></tr></table></figure> PS:
如果<code>make docker</code>运行错误，重新输入<code>make docker</code>运行</p>
<!-- 也可以用docker命令手动安装相关镜像，注意`fabric`相关镜像没有`latest`版本
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull hyperledger/fabric-orderer:x86_64-1.0.1</span><br><span class="line">docker pull hyperledger/fabric-peer:x86_64-1.0.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rename it to <span class="string">&#x27;latest&#x27;</span></span></span><br><span class="line">docker tag hyperledger/fabric-orderer:x86_64-1.0.1 hyperledger/fabric-orderer:latest</span><br><span class="line">docker tag hyperledger/fabric-peer:x86_64-1.0.1 hyperledger/fabric-peer:latest </span><br></pre></td></tr></table></figure>
<p>--&gt;</p>
<p>也可以进入到<code>fabric/examples/e2e_cli</code>目录下，运行<code>./download-dockerimages.sh</code>来下载必要镜像。镜像下载完成后，就可以通过
<code>docker save</code>
命令把镜像打包成压缩文件，传送到各个VM。当VM接收到压缩文件后，可以通过
<code>docker load</code>
来解压和导入镜像。如果有私有的容器镜像仓库registry，如 Harbor
等，也可以把镜像推送到私有registry，再从各个机器中拉取。</p>
<p>通过以下命令来保存所有 <code>tag</code> 含有 <code>fabric</code>
标识的镜像到名字为 <code>images</code> 的压缩文件中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save $(docker images | grep fabric | awk &#123;‘print $1’&#125; ) -o images</span><br></pre></td></tr></table></figure> 生成
<code>images</code>
文件后，就可以通过scp把它拷贝到还没有镜像的其他节点中，例如，地址为
10.112.122.6
的节点需要安装以上镜像，可以通过以下命令把<code>images</code> 远程拷贝到
10.112.122.6 的home目录下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp images root@10.112.122.6:~</span><br></pre></td></tr></table></figure> 然后在 10.112.112.6
这台主机的home目录上运行： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load -i images</span><br></pre></td></tr></table></figure> 等待一段时间后, 通过
<code>docker images</code> 命令就能查看到相关镜像的信息。</p>
<p>测试安装结果 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd examples/e2e_cli</span><br><span class="line">./network_setup.sh up</span><br></pre></td></tr></table></figure> 进入到 <code>fabric/example/e2e_cli</code>
文件夹中，<code>network_setup.sh</code> 是一键测试脚本，该脚本启动了6个
docker 容器，其中有4个容器运行 peer 节点和1个容器运行 orderer
节点，它们组成一个Fabric集群。另外, 还有一个 cli 容器用于执行创建
channel 、加入 channel 、安装和执行chaincode 等操作。测试用的 chaincode
定义了两个变量，在实例化的时候给这两个变量赋予了初值，通过invoke操作可以使两个变量的值发生变化。</p>
<p>如果正常则显示如下内容，即在单机运行4+1的Fabric实例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=== All GOOD，End-2-End execution completed ===</span><br></pre></td></tr></table></figure>
许多的调试信息具体可参考 e2e_cli 目录下的 <code>script/script.sh</code>
文件。</p>
<p>可以关闭Fabric网络 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./network_setup.sh down</span><br></pre></td></tr></table></figure></p>
<h4 id="把单节点e2e_cli范例改为多节点的大致步骤">3.
把单节点e2e_cli范例改为多节点的大致步骤</h4>
<ol type="1">
<li>准备环境</li>
</ol>
<p>运行Fabric节点需要依赖以下工具：</p>
<ol type="a">
<li><p>Docker：用于管理Fabric镜像以及运行 peer 和 orderer
等组件</p></li>
<li><p>Docker-compose： 用于配置 Fabric 容器</p></li>
<li><p>Fabric源码：源码提供了用于生成证书和配置 channel
的工具和测试代码</p></li>
<li><p>Go语言开发环境：源码的工具编译依赖于 Go 语言</p></li>
</ol>
<ol start="2" type="1">
<li>配置多节点Fabric集群</li>
</ol>
<p>在单节点e2e_cli示例中，所有节点部署在同一个 docker-compose
的内部网络中，通过容器的7051端口进行通信。但是在多节点的情况下，容器之间不能进行直接通讯，因此需要把容器的7051端口映射到宿主机上，通过各个宿主机的7051端口来实现节点间通信。我们在每个节点中修改
docker-compose.yaml 中的 service 定义，在不同节点只启动需要的
service。例如，在节点1中只启动peer0 的 service，在节点5中仅启动 orderer
等。</p>
<ol start="3" type="1">
<li>启动多节点Fabric集群</li>
</ol>
<p>在各个节点上配置好 Fabric
的启动环境后，需要依次登录到节点上通过docker-compose up的方式启动 Fabric
节点。由于启动环境有依赖关系，如 peer1 以 peer0
作为发现节点，因此需要先启动 peer0 再启动 peer1 。</p>
<ol start="4" type="1">
<li>配置channel</li>
</ol>
<p>在 Fabric 中，channel
代表了一个私有的广播通道，保证了消息的隔离性和私密性，它由 orderer
来管理。channel 中的成员共享该 channel
的账本，并且只有通过验证的用户才能在 channel 中进行交易，与一个 channel
相关的属性记录在该channel的初始区块中，可通过 reconfiguration
交易进行更改。channel的初始区块由 create channel 交易生成，peer 向
orderer 发送该交易时会带有的 config.tx 文件，该文件定义 channel
的相关属性。</p>
<ol start="5" type="1">
<li>发布chaincode</li>
</ol>
<p>chaincode 是开发人员按照特定接口编写的智能合约，通过 SDK 或者 CLI 在
Fabric 的网络上安装并且初始化后，该应用就能访问网络中的共享账本。</p>
<p>chaincode 的生命周期如下:</p>
<ol type="a">
<li>Install（安装）</li>
</ol>
<p>chaincode 要在 Fabric 网络上运行，必须要先安装在网络中的 peer
上，安装同时注明版本号保证应用的版本控制。</p>
<ol start="2" type="a">
<li>Instantiate（实例化）</li>
</ol>
<p>在 peer 上安装 chaincode 后，还需要实例化才能真正激活该 chaincode
。在实例化的过程中，chaincode
就会被编译并打包成容器镜像，然后启动运行。若 chaincode
在实例化的过程中更新了数据状态，如给某个变量赋予初始值，则该状态变化会被记录在共享账本中。每个应用只能被实例化一次，实例化可在任意一个已安装该
chaincode 的 peer 上进行。</p>
<ol start="3" type="a">
<li>Invoke和query （调用和查询）</li>
</ol>
<p>chaincode 在实例化后，用户就能与它进行交互，其中 query
查询与应用相关的状态（即只读），而 invoke 则可能会改变其状态。</p>
<ol start="4" type="a">
<li>Upgrade（升级）</li>
</ol>
<p>在 chaincode 添加新功能或出现 bug 需要升级时，可以通过 upgrade
交易来实现。这时需要把新的代码通过install交易安装到正在运行该
chaincode的 peer
上，安装时需注明比先前版本更高的版本号，接下来只需要向任意一个安装了新代码的
peer 发送 upgrade 交易就能更新 chaincode ，chaincode
在更新前的状态也会得到保留。</p>
<h4 id="部署hyperledger-fabric-v1.0多节点集群文档一">4. 部署Hyperledger
Fabric v1.0多节点集群（文档一）</h4>
<ol type="1">
<li>准备工作</li>
</ol>
<p>先在5台计算机（虚拟机）上按上面步骤布置好Hyperledger
Fabric环境，并确认<code>ssh server</code>开启 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br></pre></td></tr></table></figure>
如果没有安装server端，可以 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>
虚拟机可以直接克隆生成五个新的虚拟机。其中4台虚拟机运行 peer
节点，另外一台运行 orderer 节点，为其他的四个节点提供order服务。</p>
<p>在<code>VirtualBox</code>中<code>控制&gt;设置&gt;网络</code>选择<code>Host-Only</code>模式</p>
<p>在控制台中输入 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure> 可以查看本机IP地址</p>
<p>将5台虚拟机分别作为<code>order</code> <code>peer0.org1</code>
<code>peer1.org1</code> <code>peer0.org2</code>
<code>peer1.org2</code>节点，并记住对应的IP地址，假设依次为
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.99.101</span><br><span class="line">192.168.99.102</span><br><span class="line">192.168.99.103</span><br><span class="line">192.168.99.104</span><br><span class="line">192.168.99.105</span><br></pre></td></tr></table></figure> 2. 生成公私钥、证书、创世区块</p>
<p>在任意VM上运行 <code>fabric/examples/e2e_cli</code> 目录下的
<code>generateArtifacts.sh</code> 脚本 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd examples/e2e.cli</span><br><span class="line">./generateArtifacts.sh mychannel</span><br></pre></td></tr></table></figure>
可生成两个目录，它们分别为 <code>channel-artifacts/</code> 和
<code>crypto-config/</code>，两个目录的结构分别如下: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-channel-artifacts</span><br><span class="line">    -channel.tx</span><br><span class="line">    -genesis.block</span><br><span class="line">    -Org1MSPanchors.tx</span><br><span class="line">    -Org2MSPanchors.tx</span><br></pre></td></tr></table></figure>
上述目录里的文件用于 <code>orderer</code> 创建 <code>channel</code> ,
它们根据 <code>configtx.yaml</code> 的配置生成。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-crypto-config</span><br><span class="line">    -ordererOrganizations</span><br><span class="line">    -peerOrganizations</span><br></pre></td></tr></table></figure>
上述目录里面有 <code>orderer</code> 和 <code>peer</code>
的证书、私钥和以及用于通信加密的<code>tls</code>证书等文件，它通过
<code>configtx.yaml</code> 配置文件生成。</p>
<p>该命令只需在某个VM上运行一次，其他VM上就不需要运行。</p>
<ol start="2" type="1">
<li><code>order</code>节点设置</li>
</ol>
<p>设置节点的<code>docker-compose</code>文件</p>
<p>e2e_cli中提供了多个yaml文件，我们可以基于docker-compose-cli.yaml文件创建：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp docker-compose-cli.yaml docker-compose-peer.yaml</span><br></pre></td></tr></table></figure>
然后修改docker-compose-peer.yaml，去掉orderer的配置，只保留一个peer和cli，因为我们要多级部署，节点与节点之前又是通过主机名通讯，所以需要修改容器中的host文件，也就是extra_hosts设置，修改后的peer配置如下：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">peer0.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">    <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;orderer.example.com:192.168.99.102&quot;</span></span><br></pre></td></tr></table></figure>
同样，cli也需要能够和各个节点通讯，所以cli下面也需要添加extra_hosts设置，去掉无效的依赖，并且去掉<code>command</code>这一行，每个peer都会有个对应的客户端，也就是cli，所以只需要去手动执行一次命令，而不是自动运行。修改后的cli配置如下：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cli:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cli</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-tools</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">GOPATH=/opt/gopath</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ID=cli</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;orderer.example.com:192.168.99.101&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer0.org1.example.com:192.168.99.102&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer1.org1.example.com:192.168.99.103&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer0.org2.example.com:192.168.99.104&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer1.org2.example.com:192.168.99.105&quot;</span></span><br></pre></td></tr></table></figure>
在单机模式下，4个peer会映射主机不同的端口，但是我们在多机部署的时候是不需要映射不同端口的，所以需要修改<code>base/docker-compose-base.yaml</code>文件，将所有peer的端口映射都改为相同的：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7051</span><span class="string">:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7052</span><span class="string">:7052</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7053</span><span class="string">:7053</span></span><br></pre></td></tr></table></figure>
设置orderer节点的docker-compose文件,与创建peer的配置文件类似，复制一个yaml文件出来进行修改：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp docker-compose-cli.yaml docker-compose-orderer.yaml</span><br></pre></td></tr></table></figure>
<code>orderer</code>服务器上只需要保留order设置，其他peer和cli设置都可以删除。orderer可以不设置extra_hosts</p>
<ol start="3" type="1">
<li>分发配置文件</li>
</ol>
<p>前面操作都是在<code>orderer</code>节点上完成的，接下来需要将这些文件分发到另外4台服务器上</p>
<p>先登录<code>peer0.org1</code>节点，将本地的e2e_cli文件夹删除：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm e2e_cli –R</span><br></pre></td></tr></table></figure>
然后再登录到<code>orderer</code>服务器上，退回到<code>examples</code>文件夹
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r e2e_cli UserName@192.168.99.102:/gocode/src/github.com/hyperledger/fabric/examples/</span><br></pre></td></tr></table></figure>
我们在前面配置的就是<code>peer0.org1</code>上的节点，所以复制过来后不需要做任何修改。</p>
<p>再次运行scp命令，复制到<code>peer1.org1</code>上，然后我们需要对docker-compose-peer.yaml做一个小小的修改，将启动的容器改为peer1.org1.example.com，并且添加peer0.org1.example.com的IP映射，对应的cli中也改成对peer1.org1.example.com的依赖(各种文件索引位置都要修改)。这是修改后的peer1.org1.example.com上的配置文件：
复制代码 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">        <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">        <span class="attr">service:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;orderer.example.com:192.168.99.101&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;peer0.org1.example.com:192.168.99.102&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">cli:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cli</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-tools</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">GOPATH=/opt/gopath</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_ID=cli</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/server.crt</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/server.key</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;orderer.example.com:192.168.99.101&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer0.org1.example.com:192.168.99.102&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer1.org1.example.com:192.168.99.103&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer0.org2.example.com:192.168.99.104&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer1.org2.example.com:192.168.99.105&quot;</span></span><br></pre></td></tr></table></figure>
接下来继续使用<code>scp</code>命令将orderer上的文件夹传送给<code>peer0.org2</code>和<code>peer1.org2</code>，然后也是修改一下docker-compose-peer.yaml文件，使得其启动对应的<code>peer</code>节点。</p>
<ol start="4" type="1">
<li>启动<code>Fabric</code></li>
</ol>
<p>现在所有文件都已经准备完毕，可以启动我们的Fabric网络了。</p>
<p>首先启动<code>orderer</code>节点，在<code>orderer</code>服务器上运行：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose-orderer.yaml up –d</span><br></pre></td></tr></table></figure>
运行完毕后我们可以使用<code>docker ps</code>看到运行了一个名字为<code>orderer.example.com</code>的节点。</p>
<p>然后启动<code>peer</code>节点，切换到<code>peer0.org1.example.com</code>服务器，启动本服务器的peer节点和cli：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose-peer.yaml up –d</span><br></pre></td></tr></table></figure> 运行完毕后使用docker
ps应该可以看到2个正在运行的容器。</p>
<p>接下来依次在另外3台服务器运行启动peer节点容器的命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose-peer.yaml up –d</span><br></pre></td></tr></table></figure>
现在整个<code>Fabric</code>
4+1服务器网络已经成型，接下来是创建<code>channel</code>和运行<code>ChainCode</code>。</p>
<p>切换到<code>peer0.org1.example.com</code>服务器上，使用该服务器上的cli来运行创建<code>Channel</code>和运行<code>ChainCode</code>的操作</p>
<p>首先进入cli容器： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> 进入容器后,可以看到命令提示变为：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@b41e67d40583:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br></pre></td></tr></table></figure>
说明已经以root的身份进入到cli容器内部。官方已经提供了完整的创建<code>Channel</code>和测试<code>ChainCode</code>的脚本，并且已经映射到cli容器内部，所以只需要在cli内运行如下命令：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/script.sh mychannel</span><br></pre></td></tr></table></figure>
那么该脚本就可以一步一步的完成创建通道，将其他节点加入通道，更新锚节点，创建<code>ChainCode</code>，初始化账户，查询，转账，再次查询等链上代码的各个操作都可以自动化实现。直到最后，系统提示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===================== All GOOD, End-2-End execution completed =====================</span><br></pre></td></tr></table></figure>
说明4+1的<code>Fabric</code>多机部署成功了。我们现在是在<code>peer0.org1.example.com</code>的cli容器内，我们也可以切换到<code>peer0.org2.example.com</code>服务器，运行<code>docker ps</code>命令，可以看到本来是2个容器的，现在已经变成了3个容器</p>
<h4 id="部署hyperledger-fabric-v1.0多节点集群文档二">5. 部署Hyperledger
Fabric v1.0多节点集群（文档二）</h4>
<p>此文档和上一节的方法基本相同，细节之处可做参考选择，方便理解。</p>
<p>以下各VM的工作目录为： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">GOPATH/src/github.com/hyperledger/fabric/examples/e2e_cli</span></span><br></pre></td></tr></table></figure>
可在任意VM上运行以下命令，生成构建 Fabric 网络所需的成员证书等必要材料：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash generateArtifacts.sh</span><br></pre></td></tr></table></figure> 该命令只需在某个VM上运行一次，其他VM上就不需要运行。</p>
<p>在运行该命令的VM中会生成 <code>channel-artifacts</code> 和
<code>crypto-config</code> 目录，需要把它们拷贝到其他VM的 e2e_cli
目录下，如果在VM中已经存在该目录，则先把目录删除。当每个VM中都有统一的
<code>channel-artifacts</code> 和 <code>crypto-config</code>
目录后接下来就开始配置 compose 文件。</p>
<p>I. VM1的配置：</p>
<ol type="1">
<li>修改 <code>/etc/hosts</code> 的映射关系</li>
</ol>
<p>因为容器内部通过域名的方式访问 orderer , 因此需要通过修改 /etc/hosts
把orderer 的域名和 ip 地址对应起来，在文件中添加: <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.69</span>   <span class="string">orderer.example.com</span></span><br></pre></td></tr></table></figure> 2.
修改<code>docker-compose-cli.yaml</code></p>
<p>在默认的情况下，<code>docker-compose-cli.yaml</code>会启动6个service（容器），它们分别为
<code>peer0.org1.example.com</code>、
<code>peer1.org1.example.com</code>、
<code>peer0.org2.example.com</code>、
<code>peer1.org2.example.com</code>、 <code>orderer.example.com</code>
和
<code>cli</code>，因为每台机器只运行与之对应的一个节点，因此需要注释掉无需启动的
service。</p>
<ol type="1">
<li><p>除 peer0.org1.example.com 和 cli service 外，其他 service
全部注释。</p></li>
<li><p>在 cli 的 volumes 中加入映射关系： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">-./peer/:/opt/gopath/src/github.com/hyperledger/fabric/peer/</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>注释 cli 中的 depends_on 和 command : <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line">  <span class="comment">#- orderer.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">  <span class="comment">#- peer1.org1.example.com</span></span><br><span class="line">  <span class="comment">#- peer0.org2.example.com</span></span><br><span class="line">  <span class="comment">#- peer1.org2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#command: /bin/bash -c &#x27;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#x27;</span></span><br></pre></td></tr></table></figure>
之前我们把容器中的工作目录挂载到宿主机的 <code>e2e_cli/peer</code>
目录下, 是因为在执行 create channel 的过程中，orderer 会返回一个
mychannel.block 作为 peer 加入 channel 的依据，其他的 peer
要加入到相同的 channel 中必须先获取该 mychannel.block
文件。因此，通过挂载目录从宿主机就能方便获得 mychannel.block
，并且把它传输到其他的 VM 上。</p></li>
</ol>
<p>挂载 <code>/etc/hosts</code> 的目的是把主机中 orderer.exmaple.com 与
IP 地址10.112.122.69 的映射关系带入容器中,目的是让 cli 能通过域名访问
orderer 。在实际环境中，建议通过配置 DNS 而不是修改
<code>/etc/hosts</code> 文件（下同）。</p>
<ol start="3" type="1">
<li>修改 <code>base/peer-base.yaml</code>，添加 volumes： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure>
这样 peer 容器能通过域名访问orderer了。</li>
</ol>
<ol start="2" type="I">
<li>VM2配置：</li>
</ol>
<ol type="1">
<li>修改 /etc/hosts 的映射关系</li>
</ol>
<p>peer1.org1.example.com 使用了 peer0.org1.example.com
作为它的初始化节点，因此需要在主机中还需要加入 VM1 的 ip 地址。
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.69</span>   <span class="string">orderer.example.com</span></span><br><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.144</span>  <span class="string">peer0.org1.example.com</span></span><br></pre></td></tr></table></figure> 2. 修改docker-compose-cli.yaml</p>
<ol type="1">
<li><p>类似VM1，除 peer1.org1.example.com 和 cli service 外，其他
service 全部注释。</p></li>
<li><p>在 cli 的 volumes 中加入映射关系： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">-./peer/:/opt/gopath/src/github.com/hyperledger/fabric/peer/</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>注释cli中的 depends_on 和 command: <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line"> <span class="comment">#- orderer.example.com</span></span><br><span class="line"> <span class="comment">#- peer0.org1.example.com</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line"> <span class="comment">#- peer0.org2.example.com</span></span><br><span class="line"> <span class="comment">#- peer1.org2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#command:/bin/bash -c &#x27;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改cli中的环境变量 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<ol start="3" type="1">
<li>修改base/peer-base.yaml，同VM1的修改。</li>
</ol>
<ol start="3" type="I">
<li>VM3配置：</li>
</ol>
<ol type="1">
<li>修改 /etc/hosts 的映射关系 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.69</span>      <span class="string">orderer.example.com</span></span><br></pre></td></tr></table></figure></li>
<li>修改docker-compose-cli.yaml</li>
</ol>
<ol type="1">
<li><p>VM3 上运行 peer2 节点，因此除 peer0.org2.example.com 和 cli
service 外,其他 service 全部注释。</p></li>
<li><p>在cli的 volumes 中加入映射关系： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">-./peer/:/opt/gopath/src/github.com/hyperledger/fabric/peer/</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>注释cli中的 depends_on 和 command : <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line"> <span class="comment">#- orderer.example.com</span></span><br><span class="line"> <span class="comment">#- peer0.org1.example.com</span></span><br><span class="line"> <span class="comment">#- peer1.org1.example.com</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line"> <span class="comment">#- peer1.org2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#command:/bin/bash -c &#x27;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改cli中的环境变量 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;</span></span><br><span class="line"><span class="string">CORE_PEER_ADDRESS=peer0.org2.example.com:7051</span></span><br><span class="line"><span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<ol start="3" type="1">
<li>修改base/peer-base.yaml，同VM1。</li>
</ol>
<ol start="4" type="I">
<li>VM4配置：</li>
</ol>
<ol type="1">
<li>修改/etc/hosts的映射关系</li>
</ol>
<p>peer1.org2.example.com 使用了 peer0.org2.example.com
作为它的初始化节点，因此需要在映射关系中加入 VM3 的 ip 地址
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.69</span>       <span class="string">orderer.example.com</span></span><br><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.12</span>       <span class="string">peer0.org2.example.com</span></span><br></pre></td></tr></table></figure> 2. 修改docker-compose-cli.yaml</p>
<ol type="1">
<li><p>VM4运行peer3，因此除peer1.org2.example.com和cliservice
外,其他service全部注释</p></li>
<li><p>在cli的volumes中加入映射关系： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">-./peer/:/opt/gopath/src/github.com/hyperledger/fabric/peer/</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改cli中的 depends_on 和 command: <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line"><span class="comment">#command:/bin/bash -c &#x27;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改cli中的环境变量 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;</span></span><br><span class="line"><span class="string">CORE_PEER_ADDRESS=peer1.org2.example.com:7051</span></span><br><span class="line"><span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<ol start="3" type="1">
<li>修改base/peer-base.yaml，同VM1。</li>
</ol>
<p>V. VM5配置如下：</p>
<ol type="1">
<li>修改docker-compose-cli.yaml</li>
</ol>
<p>除orderer外的其他 service 全部注释，即只启动 orderer 。</p>
<ol start="6" type="I">
<li>启动多节点Fabric集群</li>
</ol>
<ol type="1">
<li>启动orderer</li>
</ol>
<p>进入到 VM5 的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure>
此时终端会出现大量记录，当出现<code>Beginning to service requests</code>时，orderer启动完成。有了
<code>orderer</code> 之后，就可以通过它来管理 <code>channel</code>
。</p>
<ol start="2" type="1">
<li>启动 org1的第一个节点 peer0 ，即 peer0.org1.example.com</li>
</ol>
<p>进入到 VM1 的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure> 此时通过docker ps -a 命令可以看到成功启动了
peer0.org1.example.com 和 cli 两个容器。</p>
<p>接下来实现创建 channel 、加入 channel 和安装 chanicode
。首先进入到cli容器内： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> cli 与 orderer 之间的通讯使用 tls
加密，设置环境变量 ORDERER_CA 以作建立握手的凭证： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/cacerts/ca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure>
注：以下所有涉及到 ORDERER_CA 环境变量的命令都需预先给该变量赋值。</p>
<p>进入到 cli 容器后会自动跳转到
/opt/gopath/src/github.com/hyperledger/fabric/peer
目录，即工作目录，通过compose文件的配置，该目录映射为宿主机的
/e2e_cli/peer 。</p>
<p>在工作目录下输入以下命令，创建名为 mychannel 的 channel ：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls --cafile $ORDERER_CA</span><br></pre></td></tr></table></figure> <code>channel</code>
创建成功后，会在当前目录下生成<code>mychannel.block</code>文件。每个peer
在向 orderer 发送 <code>join channel</code>
交易的时候，需要提供这个文件才能加入到 <code>mychannel</code>
中，因此运行在其他 VM 上的 peer 需要得到 <code>mychannel.block</code>
文件来加入到 <code>mychannel</code> 中。由于之前的文件映射关系，
<code>mychannel.block</code> 文件可在宿主机的 <code>e2e_cli/peer</code>
目录下获取，这时可以通过宿主机把 <code>mychannel.block</code> 拷贝到
VM2, VM3, VM4的 <code>e2e_cli/peer</code> 目录下。</p>
<p>把 peer0.org1.example.com 加入到 mychannel 中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure> 更新
mychannel 中 org1 的 anchor peer 的信息： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile $ORDERER_CA</span><br></pre></td></tr></table></figure> 安装 chaincode
示例 chaincode_example02 到 peer0.org1.example.com 中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode install -nmycc -v 1.0 -p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure>
这时候 chaincode 代码已经安装到了 peer0
节点上，但并未实例化运行。接下来先配置好其他节点。</p>
<ol start="3" type="1">
<li>启动 org1 的第二个节点 peer1，即 peer1.org1.example.com</li>
</ol>
<p>进入到VM2的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure> 进入到 cli 容器内部： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> 由于前面已经把
mychannel.block 拷贝到了 VM2 的 e2e_cli/peer 目录下，因此
mychannel.block 可通过容器内的
<code>/opt/gopath/src/github.com/hyperledger/fabric/peer</code>
目录访问。</p>
<p>把 peer1.org1.example.com 加入到 mychannel 中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure> 安装
chaincode_example02 到 peer1.org1.example.com 中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode install -nmycc -v 1.0 –p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure> 4.
启动 org2 的第一个节点 peer2，即 peer0.org2.example.com</p>
<p>进入到 VM3 的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose-f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure> 进入到cli容器内部： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure>
把peer0.org2.example.com加入到mychannel中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure> 更新
mychannel 中 org2 的 anchor peer 的信息： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile $ORDERER_CA</span><br></pre></td></tr></table></figure> 安装
chaincode_example02 到 peer0.org2.example.com 中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode install -nmycc -v 1.0 -p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure> 5.
启动org2的第二个节点peer3 ，即 peer1.org2.example.com</p>
<p>进入到 VM4 的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose-f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure> 首先进入到cli容器内部： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> 把
peer1.org2.example.com 加入到 mychannel 中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure> 安装
chaincode_example02 到 peer1.org2.example.com 中： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode install -nmycc -v 1.0 -p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure> 6.
运行chaincode</p>
<p>通过前面的步骤，整个多节点Fabric网络已经运行起来了，每个peer都加入到了标识为
<code>mychannel</code> 的 channel 中，并且都安装了一个简单的 chaincode
(该 chaincode 在安装时被标识为 <code>mycc</code> ) 。下面步骤运行和维护
chaincode。</p>
<ol type="1">
<li>实例化chaincode</li>
</ol>
<p>chaincode 的实例化可在任意 peer 上进行，并且 <strong>chaincode
只能被实例化一次</strong>，下面以在 peer0.org2.example.com 上实例化
chaincode 为例。</p>
<p>首先登录VM3并进入到cli容器内部运行： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile $ORDERER_CA -C mychannel-nmycc -v 1.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]&#125;&#x27; -P &quot;OR     (&#x27;Org1MSP.member&#x27;,&#x27;Org2MSP.member&#x27;)&quot;</span><br></pre></td></tr></table></figure>
这时候会构建一个新的容器来运行chaincode，通过<code>docker ps -a</code>
命令可以看到新容器： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev-peer0.org2.example.com-mycc-1.0</span><br></pre></td></tr></table></figure>
上述实例化中，我们对两个变量‘a’和‘b’分别赋予初值100和200，通过 channel
它们的值被同步到了其他peer的账本上，即使其他peer还没有构建运行 chaincode
的容器。</p>
<ol start="2" type="1">
<li>执行 chaincode 的 query 交易</li>
</ol>
<p>由于 chaincode 已经被 peer0.org2.example.com 实例化了，因此其他 peer
不需要再次实例化它了，但是 chaincode 的状态（world
state）却是已经记录在各个peer的账本上的。</p>
<p>接下来我们在peer0.org1.example.com上查看chaincode的状态，登录到VM1上并进入cli容器内部执行：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode query -C mychannel -nmycc -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> 上面的命令查看 mycc 中变量 a 的值，由于在 peer 跟
chaincode 发生互动之前还不存在运行 chaincode
的容器，因此第一次交互的时候需要先构建运行 chaincode
的容器，等待一段时间后返回结果：100 。</p>
<p>此时通过 <code>docker ps -a</code> 命令能看到新容器： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev-peer0.org1.example.com-mycc-1.0</span><br></pre></td></tr></table></figure>
该值与实例化时的赋值一致，说明 peer0.org1 和 peer0.org2 两个 peer
可以相互通信。</p>
<ol start="3" type="1">
<li>执行chaincode的invoke交易</li>
</ol>
<p>接下来，我们执行一个 invoke 交易，使得变量 a 向变量 b 转帐
20，得到最终值为["a":"80","b":"220"]。</p>
<p>登录到VM2并进入到cli容器中中通过以下命令查询mycc的状态：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> 稍作等待后返回结果为100，下面执行 invoke 交易，改变 a
的值为 80 ： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode invoke -oorderer.example.com:7050  --tls --cafile $ORDERER_CA -C mychannel -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;20&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> (4) 再次执行 chaincode 的 query 交易</p>
<p>在peer1.org1.example.com 上重复以上查看 chaincode
的步骤，得到返回结果为 80
，说明测试通过，至此，Fabric网络构建完毕，各个部件工作正常。</p>
<ol start="7" type="1">
<li>更新chaincode</li>
</ol>
<p>通过 <code>channel upgrade</code> 命令可以使得 <code>chaincode</code>
更新到最新的版本，而低版本 chaincode 将不能再使用。</p>
<p>登录到VM1的 cli 容器中再次安装 chaincode_example02
，但赋予它更高的版本号 2.0： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode install -n mycc -v 2.0 -p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure> 在 VM1 的 cli 容器升级
chaincode ,添加两个变量 ‘c’和‘d’: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode upgrade -o  orderer.example.com:7050 --tls --cafile $ORDERER_CA -n mycc -v 2.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;c&quot;, &quot;10&quot;,&quot;d&quot;,&quot;20&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure>
等待一段时间后，可以通过<code>docker ps -a</code>
来查看新容器构建的容器,该容器的名称为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev-peer0.org1.example.com-mycc-2.0</span><br></pre></td></tr></table></figure>
通过以下命令查询c的变量： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode -n mycc -C mychannel -v 2.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;c&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> 返回结果为10</p>
<p>再次查询a的变量： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peer chaincode -n mycc -C mychannel -v 2.0 -c&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> 返回结果为80，说明更新 chaincode
成功。</p>
<p>这时候对账本的修改会通过 orderer 同步到其他 peer 上，但是在其他 peer
上将无法查看或更改 chaincode 的状态，因为它们还在使用旧版的 chaincode
，所以其他 peer 要想正常访问还需再次安装 chaincode
，并且设置相同的版本号 ( chaincode
代码没发生改变，只是安装时版本号更新为 2.0 )，命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">peerchaincode install -n mycc -v 2.0 –p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Cello笔记</title>
    <url>/2018/05/17/Hyperledger-Cello/</url>
    <content><![CDATA[<p>Cello 遵循典型的"主-从"工作体系结构。群集中有两种类型的节点：</p>
<ul>
<li>Master Node：Cello服务通过Worker
Nodes提供的API接口管理（create/delete等）在Worker Nodes上的链，Master
Node 提供web 面板(port 8080) and RESTful APIs (port 80).</li>
<li>Worker Node：
Cello支持从单个服务器到集群的多种类型的工作节点。以Docker主机或Swarm集群为例，Worker
Nodes提供的API接口应该可以从主节点访问（通常在端口2375）</li>
</ul>
<span id="more"></span>
<img src="/2018/05/17/Hyperledger-Cello/cello.png" class="" title="Cello网络结构图">
<h2 id="master-node-安装">Master Node 安装</h2>
<p>Master Node包括如下服务：</p>
<ul>
<li>operator dashboard: 为操作者提供Web UI.</li>
<li>engine: 为chain consumers提供RESTful APIs.</li>
<li>watchdog: Watch for health checking.</li>
</ul>
<p>系统要求：</p>
<ul>
<li>Hardware: 8c16g100g</li>
<li>Docker engine: 1.10.0~1.13.0 (Docker 17.0+ support is
experimental)</li>
<li>docker-compose: 1.8.0~1.12.0</li>
</ul>
<p>两步安装</p>
<ol type="1">
<li><p>拉取源码 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://gerrit.hyperledger.org/r/cello &amp;&amp; cd cello</span><br></pre></td></tr></table></figure></p></li>
<li><p>首次运行时，设置主节点，可以多次运行，结束后log out然后log in
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make setup-master</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="mater-node-使用">Mater Node 使用</h2>
<p>启动全部服务 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make start</span><br></pre></td></tr></table></figure></p>
<p>碰到了<code>unauthorized</code>的错误，必须手动<code>sudo</code>
pull镜像 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull hyperledger/cello-user-dashboard</span><br></pre></td></tr></table></figure></p>
<p>停止全部服务 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make stop </span><br></pre></td></tr></table></figure> 重启全部服务 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make restart</span><br></pre></td></tr></table></figure>
单独重启特定服务，比如dashboard <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make redeploy service=dashboard</span><br></pre></td></tr></table></figure> 查看全部日志 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make logs</span><br></pre></td></tr></table></figure>
查看特定服务的日志， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make log service=watchdog</span><br></pre></td></tr></table></figure>
可以打开<code>MASTER_NODE_IP:8080</code>看到网页版的<code>operation dashboard</code></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
        <tag>Cello</tag>
      </tags>
  </entry>
  <entry>
    <title>Hyperledger-Explorer</title>
    <url>/2018/06/04/Hyperledger-Explorer/</url>
    <content><![CDATA[<p>Hyperledger项目提供了一个官方的区块链浏览器（现在只支持Fabric），见<a
href="https://github.com/hyperledger/blockchain-explorer">官方文档</a>。</p>
<p>Explorer项目最早使用的是MySQL的数据库，但现在又切换成了PostgresSQL。官方项目没有提供docker部署的方式，这里提供一种用docker-compose部署的方法，则可以不需要安装node和npm了。</p>
<span id="more"></span>
<h2 id="git下载源码">git下载源码</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hyperledger/blockchain-explorer.git</span><br><span class="line">cd blockchain-explorer</span><br></pre></td></tr></table></figure>
<h2 id="创建dockerfile文件">创建<code>Dockerfile</code>文件</h2>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">6.9</span>.<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /home/explorer/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/explorer/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /home/explorer/</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /home/explorer/crypto-config/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install &amp;&amp; <span class="built_in">cd</span> /home/explorer/client/ &amp;&amp; npm install &amp;&amp; npm run build</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node /home/explorer/main.js</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>可以创建一个<code>.dockerignore</code>文件避免docker打包不必要的文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Dockerfile</span><br><span class="line">.git/</span><br><span class="line">docker-compose.yaml</span><br></pre></td></tr></table></figure>
<p>这样可以将blockchain-explorer打包成docker镜像，注意修改<code>config.json</code>中的配置，也可以在启动容器是将<code>config.json</code>进行挂载。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;network-config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;org1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;peerOrg1&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;mspid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Org1MSP&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;peer1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;requests&quot;</span><span class="punctuation">:</span> <span class="string">&quot;grpcs://peer0.org1.example.com:7051&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;events&quot;</span><span class="punctuation">:</span> <span class="string">&quot;grpcs://peer0.org1.example.com:7053&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;server-hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;peer0.org1.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;tls_cacerts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;peer2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;requests&quot;</span><span class="punctuation">:</span> <span class="string">&quot;grpcs://peer1.org1.example.com:7051&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;events&quot;</span><span class="punctuation">:</span> <span class="string">&quot;grpcs://peer1.org1.example.com:7053&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;server-hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;peer1.org1.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;tls_cacerts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/keystore&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;cert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;org2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;peerOrg2&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;mspid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Org2MSP&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;peer1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;requests&quot;</span><span class="punctuation">:</span> <span class="string">&quot;grpcs://peer0.org2.example.com:7051&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;events&quot;</span><span class="punctuation">:</span> <span class="string">&quot;grpcs://peer0.org2.example.com:7053&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;server-hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;peer0.org2.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;tls_cacerts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;peer2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;requests&quot;</span><span class="punctuation">:</span> <span class="string">&quot;grpcs://peer1.org2.example.com:7051&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;events&quot;</span><span class="punctuation">:</span> <span class="string">&quot;grpcs://peer1.org2.example.com:7053&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;server-hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;peer1.org2.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;tls_cacerts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crt&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/keystore&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;cert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/signcerts&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8080&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;channel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mychannel&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;keyValueStore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/tmp/fabric-client-kvs&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;eventWaitTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30000&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;users&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">		   <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">		   <span class="attr">&quot;secret&quot;</span><span class="punctuation">:</span><span class="string">&quot;adminpw&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	 <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;pg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span><span class="string">&quot;db&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5432&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;database&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fabricexplorer&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;postgres&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;passwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apache-2.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2
id="创建docker-compose.yaml文件">创建<code>docker-compose.yaml</code>文件</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copyright 2018 He Sheng. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">   <span class="attr">byfn:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">     <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=password</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./app/db/:/docker-entrypoint-initdb.d/</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;5432:5432&quot;</span></span><br><span class="line">     <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">explorer:</span></span><br><span class="line">     <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">     <span class="attr">container_name:</span> <span class="string">explorer</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">$&#123;NETWORK&#125;/crypto-config/:/home/explorer/crypto-config/</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">./config.json:/home/explorer/config.json</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">     <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line">     <span class="attr">links:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">postgres:db</span></span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./app/db/:/docker-entrypoint-initdb.d/</span></span><br></pre></td></tr></table></figure>
<p>可以使<code>postgres</code>容器启动后自动运行<code>app/db/</code>里的数据库文件<code>explorerpg.sql</code>和<code>updatepg.sql</code>。</p>
<p>注意修改<code>$&#123;NETWORK&#125;</code>为部署Fabric网络对应的证书文件夹位置。</p>
<h2 id="使用docker-compose部署">使用<code>docker-compose</code>部署</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose.yaml up</span><br></pre></td></tr></table></figure>
<p>会自动拉取最新的<code>postgres</code>镜像和生成<code>explorer</code>的镜像。</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
        <tag>Explorer</tag>
      </tags>
  </entry>
  <entry>
    <title>Pell方程的解法</title>
    <url>/2023/05/25/PellEquation/</url>
    <content><![CDATA[<p>整理自John Stillwell的《Mathematics and Its
History》（2010）的Chapter 5。</p>
<h2 id="pell方程的描述">Pell方程的描述</h2>
<p>Pell方程（Pell's Equation）是一种特殊的丢番图方程（Diophantine
Equation）。</p>
<p>即在整数域<span
class="math inline">\(\mathbb{Z}\)</span>中，求解如下形式方程的问题：</p>
<p><span class="math display">\[ x^2 - N y^2 = 1\]</span></p>
<p>其中<span
class="math inline">\(N\)</span>是一个不为平方数的正整数，使得<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>都为整数。</p>
<span id="more"></span>
<h2 id="pell方程的求解思路">Pell方程的求解思路</h2>
<p>首先，考虑一个比Pell方程更泛化的问题：</p>
<p><span class="math display">\[ x^2 - N y^2 = k\]</span></p>
<p>其中<span
class="math inline">\(k\)</span>为整数。这个问题的一组解可以用一个三元组表示为<span
class="math inline">\((x,y,k)\)</span>。</p>
<p>利用恒等式：</p>
<p><span class="math display">\[(x_1^2 - N y_1^2)(x_2^2 - N y_2^2) =
(x_1 x_2 + N y_1 y_2)^2 - N (x_1y_2 + x_2 y_1)^2\]</span></p>
<p>所以，如果<span class="math inline">\(x_1\)</span>和<span
class="math inline">\(y_1\)</span>是<span class="math inline">\(x^2 - N
y^2 = k_1\)</span>的解，且<span
class="math inline">\(x_2\)</span>和<span
class="math inline">\(y_2\)</span>是<span class="math inline">\(x^2 - N
y^2 = k_2\)</span>的解，那么<span class="math inline">\(x = x_1 x_2 + N
y_1 y_2\)</span>和<span class="math inline">\(y = x_1y_2 + x_2
y_1\)</span>是<span class="math inline">\(x^2 - N y^2 = k_1
k_2\)</span>的解。</p>
<p>用三元组表示，即存在合成法则：由<span
class="math inline">\((x_1,y_1,k_1)\)</span>和<span
class="math inline">\((x_2,y_2,k_2)\)</span>，可以合成<span
class="math inline">\((x_1 x_2 + N y_1 y_2,x_1y_2 + x_2 y_1,k_1
k_2)\)</span>。</p>
<p>为了求解Pell方程，可以先给定两个互素的数<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>（<span
class="math inline">\(\gcd(a,b)=1\)</span>），使得<span
class="math inline">\(a^2 - N b^2 = k\)</span>，即<span
class="math inline">\((a,b,k)\)</span>。</p>
<p>将这个三元组与一个自然的解<span
class="math inline">\((m,1,m^2-N)\)</span>（即<span
class="math inline">\(m^2 - N \times 1^2 = m^2 -
N\)</span>）进行合成，得到<span
class="math inline">\((am+Nb,a+bm,k(m^2-N))\)</span>。</p>
<p>从方程左右约去<span
class="math inline">\(k^2\)</span>，即得到一个（不一定是整数的）三元组：</p>
<p><span
class="math display">\[(\frac{am+Nb}{k},\frac{a+bm}{k},\frac{m^2-N}{k})\]</span></p>
<p>现在，选取一个整数<span class="math inline">\(m\)</span>使得<span
class="math inline">\((a+bm)/k=b_1\)</span>为整数。可以证明，这使得<span
class="math inline">\((am+Nb)/k=a_1\)</span>和<span
class="math inline">\((m^2-N)/k=k_1\)</span>也都为整数。</p>
<p>如果选取的<span class="math inline">\(m\)</span>使得<span
class="math inline">\(m^2-N\)</span>尽可能的小，那么最终三元组<span
class="math inline">\((a_i,b_i,k_i)\)</span>将满足<span
class="math inline">\(k_i = \pm 1,\pm 2,\pm 4\)</span>。</p>
<p>这时，通过多次运用合成法则，就可以求解Pell方程。</p>
<h2 id="示例">示例</h2>
<h3 id="求解x2---61y2-1">求解：<span class="math inline">\(x^2 - 61y^2 =
1\)</span></h3>
<p>解：因为<span class="math inline">\(8^2 - 61 \times 1^2 =
3\)</span>，即得到三元组<span
class="math inline">\((8,1,3)\)</span>。</p>
<p>将<span class="math inline">\((8,1,3)\)</span>与<span
class="math inline">\((m,1,m^2-61)\)</span>合成，得到三元组<span
class="math inline">\((8m+61,8+m,3(m^2-61))\)</span>，即：</p>
<p><span
class="math display">\[(\frac{8m+61}{3},\frac{8+m}{3},\frac{m^2-61}{3})\]</span></p>
<p>选择<span class="math inline">\(m=7\)</span>（使得<span
class="math inline">\(m^2-61\)</span>尽可能的小，且<span
class="math inline">\(8+m\)</span>能被<span
class="math inline">\(3\)</span>整除），得到<span
class="math inline">\((39,5,-4)\)</span>。</p>
<p>从方程左右约去<span class="math inline">\(4\)</span>，得到<span
class="math inline">\((39/2,5/2,-1)\)</span>。</p>
<p>将<span
class="math inline">\((39/2,5/2,-1)\)</span>与其自身合成，得到<span
class="math inline">\((1523/2,195/2,1)\)</span>，然后再次与<span
class="math inline">\((39/2,5/2,-1)\)</span>合成，得到<span
class="math inline">\((29718,3805,-1)\)</span>。</p>
<p>将<span
class="math inline">\((29718,3805,-1)\)</span>与其自身合成，就得到<span
class="math inline">\((1766319049, 226153980, 1)\)</span>。</p>
<p>即Pell方程<span class="math inline">\(x^2 - 61y^2 =
1\)</span>的整数解为<span class="math inline">\(x=1766319049,
y=226153980\)</span>。</p>
<p>事实上，这也是Pell方程<span class="math inline">\(x^2 - 61y^2 =
1\)</span>的最小整数解。</p>
<h2 id="补充">补充</h2>
<h3 id="恒等式的证明">1. 恒等式的证明</h3>
<p>证明恒等式：</p>
<p><span class="math display">\[(x_1^2 - N y_1^2)(x_2^2 - N y_2^2) =
(x_1 x_2 + N y_1 y_2)^2 - N (x_1y_2 + x_2 y_1)^2\]</span></p>
<p>等式左边：</p>
<p><span class="math display">\[(x_1^2 - N y_1^2)(x_2^2 - N y_2^2) =
x_1^2 x_2^2 - N x_1^2 y_2^2 - N x_2^2 y_1^2 + N^2 y_1^2
y_2^2\]</span></p>
<p>等式右边： <span class="math display">\[\begin{aligned}
(x_1 x_2 + N y_1 y_2)^2 - N (x_1y_2 + x_2 y_1)^2 &amp;= (x_1^2 x_2^2 +
2N x_1 x_2 y_1 y_2 + N^2 y_1^2 y_2^2) - N ( x_1^2 y_2^2 + 2 x_1 x_2 y_1
y_2 + x_2^2 y_1^2) \newline
&amp;= x_1^2 x_2^2 - N x_1^2 y_2^2 - N x_2^2 y_1^2 + N^2 y_1^2 y_2^2
\end{aligned}\]</span></p>
<p>左右相等。<span class="math inline">\(\square\)</span></p>
<h3 id="整数解的证明">2. 整数解的证明</h3>
<p>证明选取一个整数<span class="math inline">\(m\)</span>使得<span
class="math inline">\((a+bm)/k\)</span>为整数，则<span
class="math inline">\((am+Nb)/k\)</span>和<span
class="math inline">\((m^2-N)/k\)</span>也都为整数。</p>
<p>假设<span class="math inline">\(a+bm = kl\)</span>（且<span
class="math inline">\(l\)</span>为整数），将一个<span
class="math inline">\(a=kl-bm\)</span>代入方程<span
class="math inline">\(a^2 - Nb^2=k\)</span>，得到:</p>
<p><span class="math display">\[\begin{align}
a (kl - bm) - N b^2 &amp;= k \newline
akl - abm - N b^2 &amp;= k \newline
(al - 1)k &amp;= b(am + Nb)
\end{align}\]</span></p>
<p>因此<span class="math inline">\(k\)</span>整除<span
class="math inline">\(b(am + Nb)\)</span>。</p>
<p>将<span class="math inline">\(bm=kl-a\)</span>代入方程<span
class="math inline">\(a^2 m^2 - Nb^2 m^2=km^2\)</span>，得到： <span
class="math display">\[\begin{align}
a^2 m^2 - N (kl-a)^2 &amp;= km^2 \newline
a^2 m^2 - Nk^2 l^2 + 2Nkla - Na^2 &amp;= km^2 \newline
(m^2 - N)a^2 &amp;= (Nkl^2-2Nla+m^2)k
\end{align}\]</span></p>
<p>因此<span class="math inline">\(k\)</span>整除<span
class="math inline">\(a^2(m^2 - N)\)</span>。</p>
<p>将<span class="math inline">\(a+bm=kl\)</span>代入方程<span
class="math inline">\((am + Nb)^2 - N(a+bm)^2 = k(m^2 -
N)\)</span>，得到： <span class="math display">\[\begin{align}
(am + Nb)^2 - Nk^2 l^2 &amp;= k(m^2 - N) \newline
(am + Nb)^2 &amp;= k(m^2 - N + Nk l^2) \newline
a^2(am + Nb)^2 &amp;= k((m^2 - N)a^2 + Nka^2 l^2) \newline
a^2(am + Nb)^2 &amp;= k^2(Nkl^2-2Nla+m^2 + Na^2 l^2) \newline
\end{align}\]</span></p>
<p>因此<span class="math inline">\(k^2\)</span>整除<span
class="math inline">\(a^2(am + Nb)^2\)</span>，即<span
class="math inline">\(k\)</span>整除<span class="math inline">\(a(am +
Nb)\)</span>。</p>
<p>由<span class="math inline">\(k\)</span>整除<span
class="math inline">\(b(am + Nb)\)</span>和<span
class="math inline">\(k\)</span>整除<span class="math inline">\(a(am +
Nb)\)</span>可以得到<span
class="math inline">\(k\)</span>整除两个数的任意线性组合，即对于任意整数<span
class="math inline">\(r\)</span>和<span
class="math inline">\(s\)</span>有<span
class="math inline">\(k\)</span>整除<span class="math inline">\((ar +
bs)(am + Nb)\)</span>，又因为<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>互素（<span
class="math inline">\(\gcd(a,b)=1\)</span>），所以根据Bezout引理，存在整数<span
class="math inline">\(r\)</span>和<span
class="math inline">\(s\)</span>使得<span class="math inline">\(ar + bs
= 1\)</span>。</p>
<p>因此<span class="math inline">\(k\)</span>整除<span
class="math inline">\(am + Nb\)</span>。</p>
<p>因为<span class="math inline">\((a+bm)/k\)</span>为整数且<span
class="math inline">\((am+Nb)/k\)</span>为整数，所以<span
class="math inline">\((m^2-N)/k = [(a+bm)/k]^2 - N
[(am+Nb)/k]^2\)</span>也为整数。<span
class="math inline">\(\square\)</span></p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Hyperledger Composer安装</title>
    <url>/2017/10/11/Hyperledger-Composer/</url>
    <content><![CDATA[<p>由linux基金会主导的超级账本（<code>HyperLeger Fabric</code>)试图为新一代的事务应用创建一种开放的分布式账本标准，支持许可式区块链。</p>
<p><code>Fabric</code>的开发环境建立在<code>VirtualBox</code>虚拟机上，部署环境可以自建网络，也可以直接部署在<code>BlueMix</code>上，部署方式可<code>docker</code>化，支持用<code>Go</code>和<code>JavaScript</code>开发智能合约。它采用<code>PBFT</code>分布式算法，网络编程方面用gRPC来做<code>P2P</code>通讯，使用
Protocol
Buffer来序列化要传递的数据结构。在架构设计上，<code>Fabric</code>可能与比特币等区块链产品有所不同，但是上述基本组成部分还是不可或缺的。
在多核时代，<code>Go</code>语言备受喜爱，它可以让你用同步方式轻松实现高并发，特别是在分布式系统、网络编程等领域，应用非常广。所以，在区块链开发领域，也有很多使用<code>Go</code>语言的项目。</p>
<span id="more"></span>
<h2 id="hyperledger1"><a
href="https://www.hyperledger.org/">Hyperledger</a></h2>
<p><a
href="https://github.com/hyperledger/hyperledger">GitHub仓库</a>中的 <a
href="https://github.com/hyperledger/fabric">Fabric源码</a></p>
<p><a
href="https://hyperledger.github.io/composer/index.html">Hyperledger
Composer</a></p>
<ul>
<li><a
href="https://hyperledger.github.io/composer/tutorials/tutorials.html">Tutorials</a></li>
<li><a
href="https://hyperledger.github.io/composer/introduction/introduction.html">Docs</a></li>
<li><a
href="https://hyperledger.github.io/composer/support/support-index.html">Community</a></li>
</ul>
<h3 id="hyperledger-fabric-v1.0环境搭建">Hyperledger Fabric
V1.0环境搭建</h3>
<p>流程：WIN主机 -&gt; VBox -&gt; Ubuntu -&gt; Docker -&gt; Fabric
Example</p>
<p>准备：VirtualBox 5.1.8、Ubuntu 16.04 LTS、Git 2.12.2、Go1.8、Docker
CE17、Pip2</p>
<p>步骤：</p>
<h4 id="安装-virtualbox">1. 安装 VirtualBox</h4>
<p>官方下载安装包“<a
href="http://download.virtualbox.org/virtualbox/5.1.18/VirtualBox-5.1.18-114002-Win.exe">VirtualBox-5.1.18-114002-Win.exe</a>”，双击运行按默认方式安装即可。或者在Win7安装<a
href="https://www.docker.com/products/docker-toolbox">Docker
ToolBox</a>自带有Oracle VM VirtualBox。
启动VirtualBox，由于新建虚拟机占用空间较大，调整默认存储位置，如下设置：Vbox&gt;管理&gt;全局设定</p>
<figure>
<img
src="https://sfault-image.b0.upaiyun.com/294/543/2945435109-58f0519cd37f3_articlex"
alt="Vbox&gt;管理&gt;全局设定" />
<figcaption aria-hidden="true">Vbox&gt;管理&gt;全局设定</figcaption>
</figure>
<h4 id="安装-ubuntu">2. 安装 Ubuntu</h4>
<p>官方下载Ubuntu桌面版IOS镜像“<a
href="http://releases.ubuntu.com/16.04.2/ubuntu-16.04.2-desktop-amd64.iso">ubuntu-16.04.2-desktop-amd64.iso</a>”，进入VBox点击新建按钮，弹出窗口名称输入“hyperledger”，类型选择“Linux”版本选择“Ubuntu
(64-bit)；继续下一步，内存大小输入4096MB，默认方式点击下一步，创建，下一步，下一步，虚拟硬盘输入30GB然后点击创建，虚拟机配置基本设置好了。接下来设置光盘启动安装系统，回到Vbox主界面选中刚新建的“hyperledger”项目后点击设置，界面如下：</p>
<figure>
<img
src="https://sfault-image.b0.upaiyun.com/232/484/232484422-58f051ecde40f_articlex"
alt="设置光盘启动安装系统" />
<figcaption aria-hidden="true">设置光盘启动安装系统</figcaption>
</figure>
<p>选择磁盘弹出窗口选择刚下载好的ISO镜像，点击OK回到主界面点击启动，接下来就是Ubuntu系统安装过程了，安装过程按提示安装即可。最后进入Ubuntu系统安装增强工具（分辨率自动适应窗口大小），如下：</p>
<figure>
<img
src="https://sfault-image.b0.upaiyun.com/119/447/1194474056-58f0521aaea82_articlex"
alt="进入Ubuntu系统安装增强工具" />
<figcaption aria-hidden="true">进入Ubuntu系统安装增强工具</figcaption>
</figure>
<p>Vbox增强工具安装好重启系统，接下来工作主要在是Terminal下操作，建议启用root用户来安装后续工具软件。（sudo
passwd更改root密码，后续直接su就可切换至root用户了）</p>
<h4 id="安装配套软件">3. 安装配套软件</h4>
<p><code>Hyperledger</code>的<a
href="https://hyperledger.github.io/composer/installing/development-tools.html">开发工具需要</a>：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Operating Systems: Ubuntu Linux 14.04 / 16.04 LTS (both 64-bit), or Mac OS 10.12</span><br><span class="line">Docker Engine: Version 17.03 or higher</span><br><span class="line">Docker-Compose: Version 1.8 or higher</span><br><span class="line">Node: 6.x (note version 7 is not supported)</span><br><span class="line">npm: v3.x or v5.v</span><br><span class="line">git: 2.9.x or higher</span><br><span class="line">Python: 2.7.x</span><br><span class="line">A code editor of your choice, we recommend VSCode.</span><br></pre></td></tr></table></figure>
但在Ubuntu上直接下载如下命令行脚本并运行（需要root权限）就可以了：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://hyperledger.github.io/composer/prereqs-ubuntu.sh</span><br><span class="line">chmod u+x prereqs-ubuntu.sh</span><br><span class="line">./prereqs-ubuntu.sh</span><br></pre></td></tr></table></figure>
如果没有<code>curl</code>命令或者命令报错需先安装<code>curl</code>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install curl</span><br></pre></td></tr></table></figure>
在安装完成后<strong>必须退出用户再重新登录</strong>，重启Terminal后<code>npm</code>会自动更新，如果更新不成功需按提示赋予权限后再次重启用户。这样不会再出现<code>npm</code>和<code>node</code>无法运行的情况。</p>
<!-- 在我第一次安装时发现`Node`没有正确安装，手动安装如下：

    apt-get install nodejs-legacy

但版本不够新（只有v4.2.6），所以先升级`npm`到最新版本

    apt-get install npm@latest -g

安装用于安装`nodejs`的模块`n`

    npm install -g n

通过`n`模块安装指定版本的`nodejs`(2017年8月23日：`Hyperledger` 还不支持 `Node` v7)

    n latest //安装官方最新版本
    n stable //安装官方稳定版本
    n lts    //安装官方最新LTS版本

当用户账号中`node`版本不合要求时，用

    which node

查看`node`链接位置，再在root下修改链接到需要的版本

    ln -s 版本位置 node位置

-->
<p>运行Hyperledger Composer和Hyperledger Fabric推荐至少4Gb的内存</p>
<h4 id="安装hyperledger开发工具">4. 安装Hyperledger开发工具</h4>
<p>一定要在non-privileged用户（eg non-root）下安装如下开发工具
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g composer-cli</span><br><span class="line">npm install -g generator-hyperledger-composer</span><br><span class="line">npm install -g composer-rest-server</span><br><span class="line">npm install -g yo</span><br></pre></td></tr></table></figure>
在安装中因为版本太旧弹出<code>npm WARN</code>可以不用理会</p>
<p>如出现权限错误： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR!    path: ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
可以通过在root中用<code>chown -R</code>命令赋予用户相关路径的权限来解决：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R UserName:UserName Path</span><br></pre></td></tr></table></figure> 如果只运行本地版Playground，运行 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g composer-playground</span><br></pre></td></tr></table></figure>
运行Hyperledger Fabric前需清空本地版Playground <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker kill $(docker ps -q)</span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line">docker rmi $(docker images dev-* -q)</span><br></pre></td></tr></table></figure>
在文件夹（比如<code>~/fabric-tools</code>）安装zip文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/fabric-tools &amp;&amp; cd ~/fabric-tools</span><br><span class="line"></span><br><span class="line">curl -O https://raw.githubusercontent.com/hyperledger/composer-tools/master/packages/fabric-dev-servers/fabric-dev-servers.zip</span><br><span class="line">unzip fabric-dev-servers.zip</span><br></pre></td></tr></table></figure>
推荐并且默认运行<strong>Hyperledger Fabric
v1.0</strong>版本，如果需要可以显式指定 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export FABRIC_VERSION=hlfv1</span><br></pre></td></tr></table></figure>
所有脚本都在文件夹<code>~/fabric-tools</code>中。一个典型的Hyperledger
Composer使用流程是 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/fabric-tools</span><br><span class="line">./downloadFabric.sh</span><br><span class="line">./startFabric.sh</span><br><span class="line">./createComposerProfile.sh</span><br></pre></td></tr></table></figure>
在用户下运行<code>./downloadFabric.sh</code>时可能出现<code>Docker permission denied</code>的错误，可以在<code>root</code>下运行
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod -a -G docker UserName</span><br></pre></td></tr></table></figure> 或在用户进程下通过<code>sudo</code>命令解决
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G docker $USER</span><br></pre></td></tr></table></figure> 在此之后需要完全退出本用户并重新登录</p>
<p>在开发session结束后 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/fabric-tools</span><br><span class="line">./stopFabric.sh</span><br><span class="line">./teardownFabric.sh</span><br></pre></td></tr></table></figure> #### 5. 新建Hyperledger Composer
Solution 在安装好Hyperledger Composer以后，就可以按<a
href="https://hyperledger.github.io/composer/tutorials/developer-guide.html">Developer
Guide</a>商业网络定义（business network
definition，BND）。BND依次定义了区块链方案的数据模型（data
model）、商业和交易逻辑（business and therein transaction
logic）、权限控制规则（access control rules）。</p>
<p>在非root用户下clone一个sample网络： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hyperledger/composer-sample-networks.git</span><br><span class="line">cp -r ./composer-sample-networks/packages/basic-sample-network/  ./my-network</span><br></pre></td></tr></table></figure> 为了方便可以下载<a
href="https://code.visualstudio.com/">VSCode
editor</a>。安装后打开<code>VSCode</code>选择<code>View &gt; Command Palette...</code>输入<code>extensions</code>，选择<code>Extensions:Install Extensions</code>选项。在<code>Search Extensions in Marketplace</code>输入<code>Composer</code>并安装<code>Hyperledger Composer extension</code>。</p>
<p>根据实例，依次新建project（<code>my-network</code>），更新<code>package.json</code>文件，更新<code>README.md</code>(说明文档)，定义主模型<code>models/sample.cto</code>（可以包括多个文件），编写交易函数<code>lib/sample.js</code>，更新权限控制规则<code>permissions.acl</code>。</p>
<p>生成商业网络档案（Business Network Archive） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd my-network</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<code>composer archive create</code>命令就在<code>dist</code>文件夹中创建了一个文件<code>my-network.bna</code></p>
<p>编写Unit
Tests(测试)，写入<code>test/sample.js</code>文件。然后编写文件<code>features/sample.feature</code>（测试定义文件）。再确认Unit测试通过：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure> 导入Playground并测试。</p>
<p>运行composer-playground的快速方法：</p>
<ol type="1">
<li>拉取composer-playground镜像 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull hyperledger/composer-playground</span><br></pre></td></tr></table></figure></li>
<li>本地启动镜像 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name composer-playground -p 8080:8080 -d hyperledger/composer-playground</span><br></pre></td></tr></table></figure>
然后就可以在浏览器上使用<code>Hyperledger Composer Playground</code>
http://localhost:8080/</li>
<li>结束并关闭容器 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f composer-playground</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="部署到运行中hyperledger-fabric">6.
部署到运行中<code>Hyperledger Fabric</code></h4>
<!-- 在部署前确认`composer`正常，用`apt-get install composer`命令下载的`composer`版本较低，手动安装如下：

    php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
    php composer-setup.php --install-dir=usr/bin --filename=composer --version=1.5.1 --quiet

如果出现错误Failed to decode zlib stream，安装`zlibc`

    apt-get install zlibc

错误理解，此composer非彼composer  -->
<p>可以先试运行<code>composer</code>命令 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer</span><br></pre></td></tr></table></figure>
确认为<code>Hyperledger Composer</code>。如果命令不存在，可能是环境变量问题
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH = $PATH:/安装了composer-cli等工具的路径</span><br></pre></td></tr></table></figure> 将BNA部署到Hyperledger Fabric v1.0上 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd dist</span><br><span class="line">composer network deploy -a my-network.bna -p hlfv1 -i PeerAdmin -s randomString</span><br></pre></td></tr></table></figure>
确认网络已经部署 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer network ping -n my-network -p hlfv1 -i admin -s adminpw</span><br></pre></td></tr></table></figure> #### 7. 生成并测试REST API
登录服务器，在<code>my-network</code>文件夹中输入 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer-rest-server</span><br></pre></td></tr></table></figure>
按如下依次回答问题并设置</p>
<p><img
src="https://hyperledger.github.io/composer/assets/img/tutorials/developer/composer-rest-server.png"
alt="REST API generated" />{:height="100%" width="100%"}</p>
<p>如果运行成功，可以在输出中看到两行网络地址 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Web server listening at: http://localhost:3000</span><br><span class="line">Browse your REST API at http://localhost:3000/explorer</span><br></pre></td></tr></table></figure>
打开浏览器并输入<code>http://localhost:3000/explorer</code>就能看到</p>
<figure>
<img
src="https://hyperledger.github.io/composer/assets/img/tutorials/developer/lb_explorer.png"
alt="LoopBack API Explorer" />
<figcaption aria-hidden="true">LoopBack API Explorer</figcaption>
</figure>
<p>包括<code>Commodity</code>，<code>System</code>，<code>Trade</code>,<code>Trader</code></p>
<h4 id="生成skeleton-web-application">8. 生成Skeleton Web
Application</h4>
<p>关闭<code>composer-rest-server</code>进程，运行 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yo hyperledger-composer</span><br></pre></td></tr></table></figure>
可以看到</p>
<figure>
<img
src="https://hyperledger.github.io/composer/assets/img/tutorials/developer/composer-yo-generator.png"
alt="yo" />
<figcaption aria-hidden="true">yo</figcaption>
</figure>
<p>等待几分钟到应用安装完成，进入新应用目录 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
可以看到<code>composer-rest-server</code>开始运行，Angular打包的网络应用在<code>http://localhost:4200</code>，点击Assets就可以看到存储在Hyperledger
Fabric上的Commodity了。</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to Quantum Computing</title>
    <url>/2024/02/22/QuantumComputing/</url>
    <content><![CDATA[<h2 id="量子计算概述">量子计算概述</h2>
<p>介绍量子计算的关键概念、技术、算法、实施方案以及应用等内容。</p>
<span id="more"></span>
<h3 id="什么是量子计算">什么是量子计算?</h3>
<h4 id="传统计算机与量子计算机的区别">传统计算机与量子计算机的区别</h4>
<p>传统计算机使用二进制比特，每个比特只能是0或1之中的一个状态。量子计算机使用量子比特，每个量子比特可以是0和1的叠加态，表示为<span
class="math inline">\(\alpha|0&gt; + \beta|1&gt;\)</span>，其中<span
class="math inline">\(\alpha\)</span>和<span
class="math inline">\(\beta\)</span>为概率振幅。</p>
<p>传统计算机的每个比特的状态是确定的，量子计算机的量子比特的状态是概率性的，直到测量时才会坍缩到0或1。</p>
<p>传统计算机的比特之间是相互独立的，量子计算机的量子比特可以通过纠缠实现相互关联。</p>
<p>传统计算机依靠扩展物理比特数来实现并行，量子计算机可以利用少量的量子比特就可以代表很大规模的并行状态。</p>
<h4 id="量子比特和叠加态">量子比特和叠加态</h4>
<p>量子比特是量子信息的基本单元，它的状态是一个长度为2的向量，用<span
class="math inline">\(|0&gt;\)</span>和<span
class="math inline">\(|1&gt;\)</span>表示基态和激发态。</p>
<p>量子比特可以处于基态和激发态的叠加态，表示为<span
class="math inline">\(\alpha|0&gt; +
\beta|1&gt;\)</span>，这被称为叠加态。</p>
<p>当观察或测量一个量子比特时，它的叠加态会坍缩到基态或激发态，概率是<span
class="math inline">\(\alpha^2\)</span>和<span
class="math inline">\(\beta^2\)</span>。这被称为观察者效应。</p>
<h4 id="量子叠加和量子纠缠">量子叠加和量子纠缠</h4>
<p>量子叠加：多个量子比特可以处于组合多个基态和激发态的叠加态，这使得少量的量子比特可以代表指数级数量的状态。这是量子计算获得超高并行性的源头。</p>
<p>量子纠缠：多个量子比特之间的一种相互关联，使得多个量子比特构成一个整体，无法将它们的量子态描述为各个量子比特的独立态的叠加。当观察其中一个量子比特时，相互纠缠的其他量子比特的状态也会受到影响。这使得量子比特之间可以瞬间关联和传递信息。</p>
<h3 id="量子计算机构建">量子计算机构建</h3>
<h4 id="量子逻辑门">量子逻辑门</h4>
<p>混沌门（Hadamard门）：将量子比特的状态从<span
class="math inline">\(|0&gt;\)</span>转换成<span
class="math inline">\((|0&gt; +
|1&gt;)/\sqrt{2}\)</span>，实现把基态叠加到激发态的效果。</p>
<p>Pauli门：包括位翻转门X、相位翻转门Y和Z门。用于完成量子比特的旋转和位/相位翻转操作。</p>
<p>受控门（Controlled门）：条件性地对目标量子比特执行操作，实施控制的是控制量子比特。如CNOT门可以将控制量子比特的状态传递给目标量子比特。</p>
<h4 id="量子电路">量子电路</h4>
<p>量子电路是由一系列量子逻辑门按时间顺序构成的计算电路，用于设计和实现量子算法。</p>
<p>量子电路可以对量子寄存器中的多个量子比特执行操作，实现
evoluation（进化） 和 entanglement（纠缠）。</p>
<p>量子电路的构建需要考虑量子比特扰动和误差的影响，需要在超短时间内完成计算以保留量子态相干性。</p>
<h4 id="复杂度和可缩放性">复杂度和可缩放性</h4>
<p>量子电路中的门数目决定了量子算法的复杂度，但不等同于传统算法的时间复杂度。</p>
<p>量子算法可以在理论上实现指数级加速，但实际加速效果依赖于使用的量子比特数，这受限于可构建的量子线路规模和控制精度。</p>
<p>现实中的量子电路误差和噪声会降低量子算法的性能，这也限制了实际可构建的量子线路规模，形成量子计算的可缩放性障碍。</p>
<h3 id="量子算法">量子算法</h3>
<ol type="1">
<li><p>Deutsch-Jozsa算法：用于区分函数是平衡函数还是常数函数，可以在单次调用中解决，而经典算法需要多次调用。这是第一个展示量子计算优势的算法。</p></li>
<li><p>霍夫曼算法：用于搜索具有<span
class="math inline">\(2n\)</span>个节点的树形结构，经典算法需要<span
class="math inline">\(O(n)\)</span>时间，而量子算法只需要<span
class="math inline">\(O(1)\)</span>时间。</p></li>
<li><p>Shor算法：可以在复杂度为<span class="math inline">\(O((log
N)^3)\)</span>时间内因式分解<span
class="math inline">\(N\)</span>，远远超过目前已知的最佳经典算法。这使其可以破解RSA加密，深刻影响现代密码学体系。Shor算法利用量子Fourier变换在复杂度<span
class="math inline">\(O(logN)\)</span>下求出周期，进而求得两个大素数的乘积<span
class="math inline">\(N\)</span>。这表明某些NP难问题在量子计算机上可在多项式时间内解决。</p></li>
<li><p>Grover算法：用于在<span
class="math inline">\(N\)</span>个项目未排序数据库中搜索特定项，其时间复杂度为<span
class="math inline">\(O(N^{0.5})\)</span>，而经典算法为<span
class="math inline">\(O(N)\)</span>。这使量子计算在特定搜索问题上获得了平方级加速。</p></li>
<li><p>量子直方图算法：用于在未排序数据集中计算频率直方图，其时间复杂度为<span
class="math inline">\(O(N^{0.5})\)</span>，优于经典算法的<span
class="math inline">\(O(N)\)</span>。这是另一种量子搜索算法。</p></li>
</ol>
<h3 id="主要的量子计算架构">主要的量子计算架构</h3>
<ol type="1">
<li><p>离子阱量子计算机：利用激光操控空间隔离的离子实现量子运算。具有操作精度高和量子比特跃迁寿命长的优点，但量子比特之间的相互作用较弱，不易扩展。例如IonQ和Honeywell的量子计算机。</p></li>
<li><p>晶体硅量子计算机：利用硅基半导体中的Spin量子比特实现量子算法。控制精度较高但量子比特跃迁寿命较短，难以实现量子纠缠。例如Intel的量子计算机。</p></li>
<li><p>超导量子计算机：利用超导电路中Josephson接点实现的量子比特，并通过微波脉冲实现量子逻辑门操作。量子比特跃迁寿命较长，更易实现大规模集成，但噪声控制难度大。例如Google的Sycamore量子计算机。</p></li>
<li><p>拓扑量子计算机：利用低维拓扑材料中的准粒子（如Majorana零模式）实现量子比特，理论上更加稳定和容错。但量子比特操作和读取较难实现，难度较大。例如Microsoft的量子计算机。</p></li>
<li><p>光学量子计算机：利用光子的量子态实现量子比特和量子运算。光量子比特易于生成和传输但跃迁寿命较短，光学元件难以大规模集成，因而难以构建超大规模量子计算机。</p></li>
</ol>
<p>当前主要的量子计算架构各有其优缺点。未来实用的通用量子计算机很可能集成多种架构的优点，例如超导控制电路与离子阱或光学量子比特相结合等。</p>
<h3 id="量子计算的应用">量子计算的应用</h3>
<ol type="1">
<li><p>素数测试：Shor算法可以对大整数进行素数测试，这可以用于加密算法的破解，对网络安全造成威胁。</p></li>
<li><p>数据库搜索：Grover算法可以实现<span
class="math inline">\(O(N^{0.5})\)</span>的数据库未排序项搜索，这可以大大提高搜索引擎的效率。</p></li>
<li><p>机器学习：量子机器学习算法可以利用量子叠加实现指数级并行，大大提高机器学习的速度和效果。例如量子支撑向量机和量子神经网络等。</p></li>
<li><p>金融预测：量子算法可以应用于量化交易，机器学习和时间序列分析，实现更精确的市场预测和交易决策。这可以带来巨大的经济效益。</p></li>
<li><p>快速解决旅行商问题：某些量子算法可以在多项式时间内解决NP难问题，如旅行商问题和带权二分图匹配问题等。这可以实现一些传统算法难以达到的效果。</p></li>
<li><p>破解现代密码学：Shor算法可以破解RSA和ECC加密算法，这将对基于这些算法的网络安全产生重大影响。后量子密码学的研发成为当务之急。</p></li>
<li><p>量子模拟：量子计算机可以模拟量子系统的动力学过程，用于研究高能物理、化学反应机制和生物系统等现象。这开启了一条新的计算机辅助科研途径。</p></li>
</ol>
<p>考虑到实用通用量子计算机尚未实现和商业化，大多数应用还处于理论探讨阶段。</p>
<h3 id="量子计算面临的挑战">量子计算面临的挑战</h3>
<ol type="1">
<li><p>量子比特的非稳定性：量子比特易受环境噪声和扰动影响发生跃迁或失谐，这限制了量子线路的规模和复杂度。提高量子比特的稳定性和寿命是关键所在。</p></li>
<li><p>量子门的误差：实施量子门操作难以达到理想效果，误差会累积并影响量子算法的正确性。降低量子门误差和提高量子线路的纠错码容错能力是重要挑战。</p></li>
<li><p>量子纠缠的脆弱性：量子纠缠易受环境影响失效，但它是许多量子算法实现量子优势的关键。加强量子纠缠的稳定性和扩大量子纠缠范围是重要目标。</p></li>
<li><p>将来展望：</p>
<ul>
<li>集成多种量子技术的优势实现更稳定和可扩展的量子计算平台。</li>
<li>发展通用量子软件栈和编程环境，让更多软件工程师参与到量子计算的开发和应用中来。</li>
<li>增强量子芯片、控制系统和量子线路的集成和自动优化设计能力。</li>
<li>发展能更好映射到量子计算框架下的机器学习算法和优化方法。</li>
<li>量子计算标准化和商业化道路还很长，需要技术突破和生态系统建设。</li>
<li>防范量子计算带来的安全威胁，后量子密码学和防御技术成为新要点。</li>
</ul></li>
</ol>
<p>实用通用量子计算机需要在量子比特可控性、量子门准确性、量子线路稳定性等方面取得重大突破。与此同时，量子软件栈、算法优化和应用生态建设也同样重要。</p>
<h3 id="参考文献及扩展阅读">参考文献及扩展阅读</h3>
<ol type="1">
<li><p>Michael A. Nielsen， Isaac L. Chuang， 《Quantum Computation and
Quantum Information》， Cambridge University Press，2000.</p></li>
<li><p>John Preskill， 《Quantum Computing since Democritus》，Cambridge
University Press， 2018.</p></li>
<li><p>Eleanor G. Rieffel and Wolfgang H. Polak， 《Quantum Computing：
A Gentle Introduction》， MIT Press， 2011.</p></li>
<li><p>Yanofsky， Noson S. and Mirko Draca， 《Quantum Computing for
Computer Scientists》， Cambridge University Press， 2008.</p></li>
<li><p>Christopher Bernhardt， 《Quantum Computing for Everyone》， MIT
Press， 2019.</p></li>
</ol>
<p>这些参考书籍和网络资源对量子计算技术和发展进行了详尽而系统的介绍，是学习和研究量子计算的重要参考。其中，前3本书是关于量子计算原理和技术的权威教材和导引，后2本书从计算机科学的角度更易于理解，适合初学者。</p>
]]></content>
      <categories>
        <category>Technologies</category>
      </categories>
      <tags>
        <tag>Quantum Computing</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric学习笔记</title>
    <url>/2018/01/28/Hyperledger-Fabric/</url>
    <content><![CDATA[<h2 id="数据持久化">数据持久化</h2>
<p>如果需要对peer或CouchDB容器的数据持久化，一种选择是将容器的相关目录挂载到docker主机。</p>
<p>例如，将下面两行内容放到docker-compose.yaml文件中的对应peer处：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/var/hyperledger/peer0:/var/hyperledger/production</span></span><br></pre></td></tr></table></figure>
<p>将下面两行放到对应的CouchDB处：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/var/hyperledger/couchdb0:/opt/couchdb/data</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell命令整理</title>
    <url>/2017/05/01/Shell/</url>
    <content><![CDATA[<h3 id="加解压缩">加/解压缩</h3>
<p>压缩 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zcvf **.tar.gz **/</span><br></pre></td></tr></table></figure></p>
<p>解压 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvf **.tar.gz </span><br></pre></td></tr></table></figure></p>
<p>文件传输 ``` scp **.tar.gz username@123.456.78.9:/home/...</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Roots Formula of Quadratics, Cubics and Quartics</title>
    <url>/2023/03/27/RootFormula/</url>
    <content><![CDATA[<h2
id="一元二次三次四次方程的求根公式">一元二次、三次、四次方程的求根公式</h2>
<p>整理自Joseph J. Rotman的《Advanced Modern Algebra》（Part
1，2015）的Chapter A-1。</p>
<span id="more"></span>
<h3 id="一元二次方程求根公式">一元二次方程求根公式</h3>
<p>对于一元二次方程：</p>
<p><span class="math display">\[ ax^2+bx+c = 0 \]</span></p>
<p>通过配方可以得到：</p>
<p><span class="math display">\[ (x+b/2a)^2 = -c/a+b^2/4a^2
\]</span></p>
<p>令判别式为：</p>
<p><span class="math display">\[ \Delta = b^2-4ac \]</span></p>
<p>可以得到求根公式为：</p>
<p><span class="math display">\[ x_1 = \frac{-b+\sqrt{\Delta}}{2a}
\]</span> <span class="math display">\[ x_2 =
\frac{-b-\sqrt{\Delta}}{2a} \]</span></p>
<h3 id="一元三次方程求根公式">一元三次方程求根公式</h3>
<p>对于一元三次方程：</p>
<p><span class="math display">\[ ax^3+bx^2+cx+d = 0 \]</span></p>
<p>做变量代换<span class="math inline">\(X =
x-\frac{b}{3a}\)</span>得到不包括二次项的形式：</p>
<p><span class="math display">\[ x^3+qx+r= 0 \]</span></p>
<p>可以得到求根公式为：</p>
<p><span class="math display">\[ x_1 = g+h \]</span> <span
class="math display">\[ x_2 = \omega g + \omega ^2 h\]</span> <span
class="math display">\[ x_3 = \omega ^2 g + \omega h \]</span></p>
<p>其中：</p>
<p><span class="math display">\[ g^3 = \frac{-r+\sqrt{R}}{2} \]</span>
<span class="math display">\[ h = -\frac{q}{3g} \]</span></p>
<p>其中：</p>
<p><span class="math display">\[ R = r^2+\frac{4}{27}q^3 \]</span> <span
class="math display">\[ \omega = -\frac{1}{2}+i\frac{\sqrt{3}}{2}
\]</span></p>
<h3 id="一元四次方程求根公式">一元四次方程求根公式</h3>
<p>对于一元四次方程：</p>
<p><span class="math display">\[ ax^4+bx^3+cx^2+dx+e = 0 \]</span></p>
<p>做变量代换<span class="math inline">\(X =
x-\frac{b}{4a}\)</span>得到不包括三次项的形式：</p>
<p><span class="math display">\[ x^4+qx^2+rx+s = 0 \]</span></p>
<p>左边可以化为一元二次方程的形式：</p>
<p><span class="math display">\[ x^4+qx^2+rx+s = (x^2+jx+l)(x^2-jx+m)
\]</span></p>
<p>可以求得：</p>
<p><span class="math display">\[ l+m-j^2 = q \]</span> <span
class="math display">\[ j(m-l) = r \]</span> <span
class="math display">\[ lm = s \]</span></p>
<p>前两个方程可以得到：</p>
<p><span class="math display">\[ 2m = j^2 + q + r/j \]</span> <span
class="math display">\[ 2l = j^2 + q - r/j \]</span></p>
<p>代入第三个方程，可以得到<span
class="math inline">\(j^2\)</span>的三次方程：</p>
<p><span class="math display">\[ (j^2)^3 + 2q(j^2)^2 + (q^2-4s)j^2 - r^2
= 0 \]</span></p>
<p>通过一元三次方程的求根公式，可以得到<span
class="math inline">\(j^2\)</span>，然后得到<span
class="math inline">\(m\)</span>和<span
class="math inline">\(l\)</span>，再利用一元二次方程的求根公式得到最终的结果。</p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algebra</tag>
        <tag>Roots Formula</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction of Rational Points on Elliptic Curves</title>
    <url>/2022/11/04/RationalPointOnEllipticCurves/</url>
    <content><![CDATA[<h2
id="椭圆曲线上的有理点对introduction的翻译">《椭圆曲线上的有理点》（对Introduction的翻译）</h2>
<p>丢番图方程（Diophantine equations）的理论是数论（number theory
）的一个分支，主要研究多项式方程的整数解或有理数解。这个学科本身是以古希腊最伟大的代数学家之一，亚历山大的丢番图命名的，因为他提出并解决了许多这方面的问题。</p>
<p>大多数读者应该都熟悉费马大定理。这个定理是费马在17世纪提出的，即如果<span
class="math inline">\(n \geq 3\)</span>是一个整数，那么方程： <span
class="math display">\[X^n + Y^n = Z^n\]</span> 没有非零的整数解<span
class="math inline">\(X,Y,Z\)</span>。相应地，这断言了方程： <span
class="math display">\[x^n + y^n = 1\]</span>
在有理数上有解的唯一情况是<span
class="math inline">\(x=0\)</span>或<span
class="math inline">\(y=0\)</span>。</p>
<span id="more"></span>
<p>作为丢番图方程的另一个例子，我们考虑将一个整数写成平方数与立方数之差的问题。换句话说，我们固定一个整数<span
class="math inline">\(c \in \mathbb{Z}\)</span>，然后寻找丢番图方程：
<span class="math display">\[y^2 - x^3 = c\]</span> 在有理数上的解<span
class="math inline">\(x,y \in
\mathbb{Q}\)</span>。在1621年，由Bachet发现了一个重要性质，即这个方程存在一个复制公式：如果<span
class="math inline">\((x,y)\)</span>是方程的有理数解，且<span
class="math inline">\(y\neq 0\)</span>，那么不难验证： <span
class="math display">\[(\frac{x^4-8cx}{4y^2},
\frac{-x^6-20cx^3+8c^2}{8y^3})\]</span>
也是此方程的有理数解。此外，可以证明（尽管Bachet没有做到），如果<span
class="math inline">\(c \notin \lbrace 1,-432
\rbrace\)</span>且原始解满足<span class="math inline">\(xy\neq
0\)</span>，那么这个过程可以不断地重复，从而产生无穷多的不同解。所以除了<span
class="math inline">\(1\)</span>和<span
class="math inline">\(-432\)</span>，如果一个整数可以用非零有理数表示成一个平方数与一个立方数之差，那么它可以有无限多种表示方式。例如，如果我们把解<span
class="math inline">\((3,5)\)</span>代入方程： <span
class="math display">\[y^2-x^3=-2\]</span>
然后使用Bachet的复制公式，我们可以找到一系列的解： <span
class="math display">\[(3,5),\quad
(\frac{129}{10^2},-\frac{383}{10^3}),\quad
(\frac{2340922881}{7660^2},-\frac{113259286337279}{7660^3}),\dots\]</span>
如你所见，分子和分母很快就变得非常大。</p>
<p>接下来，我们对同一个方程： <span class="math display">\[y^2 - x^3 =
c\]</span> 讨论在整数情况下的解<span class="math inline">\(x,y \in
\mathbb{Z}\)</span>。在17世纪50年代，费马向英国数学界提出了一个挑战问题：证明方程<span
class="math inline">\(y^2−x^3 = −2\)</span>只有两个整数解，即<span
class="math inline">\((3,\pm
5)\)</span>。这与有理数解的问题形成了鲜明的对比，因为我们已经知道存在无限多的有理数解。与费马同时代的人似乎都没有解决这个问题，而欧拉在18世纪30年代给出了一个不完整的证明，正确的证明直到150年后才被给出！然后在1908年，Axel
Thue取得了一个巨大的突破：证明了对于任何非零整数<span
class="math inline">\(c\)</span>，方程<span class="math inline">\(y^2 -
x^3 = c\)</span>在整数<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>上只有有限个解。这是对费马挑战问题（在性质上）巨大的一般化，因为它说明了在无限多个有理数的解中，只有有限多个可以是整数。</p>
<p>十七世纪见证了笛卡尔将坐标引入几何。这是一项革命性的发展，使得几何的问题可以用代数的方法来解决，同时代数的问题也可以用几何的方法去研究。例如，如果<span
class="math inline">\(n\)</span>是偶数，那么费马方程<span
class="math inline">\(x^n + y^n = 1\)</span>在<span
class="math inline">\(xy\)</span>平面上的实数解会形成一个几何形状，看起来像一个被压扁的圆。费马定理就等价于断言：在这个被压扁的圆上，唯一具有有理数坐标的点是<span
class="math inline">\((\pm 1, 0)\)</span>和<span
class="math inline">\((0, \pm
1)\)</span>这四个点。当指数为奇数时，费马方程的图像看起来有点不同。指数为<span
class="math inline">\(4\)</span>和<span
class="math inline">\(5\)</span>的费马曲线，如图<span
class="math inline">\(1\)</span>所示。</p>
<img src="/2022/11/04/RationalPointOnEllipticCurves/figure1.png" class="" title="费马曲线">
<p>类似地，我们可以看看Bachet方程<span class="math inline">\(y^2 - x^3 =
c\)</span>，并且绘制在图<span
class="math inline">\(2\)</span>中。回想一下，Bachet发现了一个复制公式，在给定一个有理数解时，可以用来产生一个新的有理数解。Bachet公式相当复杂，人们可能想知道它从何而来。答案是，来自几何学！如图2所示，假设<span
class="math inline">\(P = (x, y)\)</span>是我们的原始解，即<span
class="math inline">\(P\)</span>是曲线上的一个点。接下来，我们在点<span
class="math inline">\(P\)</span>处画出曲线的切线，这是微积分第一学期的一个简单练习。这条切线与曲线相交于另一个点，我们把这个点标记为<span
class="math inline">\(Q\)</span>。然后，如果用代数方法计算出<span
class="math inline">\(Q\)</span>的坐标，就可以得到Bachet复制公式。所以，在代数上看起来复杂的Bachet公式，有一个简单的几何解释，就是切线与曲线的交点。这可能是我们第一次接触到代数、数论和几何之间产生了丰富的相互作用。</p>
<img src="/2022/11/04/RationalPointOnEllipticCurves/figure2.png" class="" title="Bachet方程">
<p>在分类上，最简单的丢番图方程是一元多项式方程： <span
class="math display">\[a_n x^n + a_{n-1}x^{n-1} + \dots + a_1 x + a_0
=0\]</span> 假设其中<span
class="math inline">\(a_0,\dots,a_n\)</span>是整数，我们如何找到所有整数解和所有有理数解呢？高斯引理提供了一个简单的答案。如果用最约化形式<span
class="math inline">\(p/q\)</span>表示有理数解，那么高斯引理告诉我们，<span
class="math inline">\(q\)</span>整除<span
class="math inline">\(a_n\)</span>且<span
class="math inline">\(p\)</span>整除<span
class="math inline">\(a_0\)</span>。这给出了可能存在有理数解的一个小范围列表，我们可以把它们逐个代入方程来确定是不是真正的解。如此看来，一元丢番图方程是很简单的。</p>
<p>当我们转向二元丢番图方程时，情况发生了巨大的改变。假设我们取一个系数为整数的多项式<span
class="math inline">\(f(x, y)\)</span>，然后看方程： <span
class="math display">\[f(x,y) = 0\]</span>
例如，费马方程和Bachet方程都具有这样的形式。很自然地，以下是我们可能会问的一些问题:</p>
<ul>
<li><span class="math inline">\((a)\)</span> 是否存在整数解？</li>
<li><span class="math inline">\((b)\)</span> 是否存在有理数解？</li>
<li><span class="math inline">\((c)\)</span>
是否存在无穷多的整数解？</li>
<li><span class="math inline">\((d)\)</span>
是否存在无穷多的有理数解？</li>
</ul>
<p>在这样概括性的描述下，当前只有问题<span
class="math inline">\((c)\)</span>得到了充分的回答，尽管最近在问题<span
class="math inline">\((d)\)</span>上也取得了很大的进展。</p>
<p>方程<span class="math inline">\(f(x, y) = 0\)</span>的实数解集在<span
class="math inline">\(xy\)</span>平面上形成一条曲线。这样的曲线被称为<em>代数曲线（algebraic
curves）</em>，表示它们是多项式方程的解的集合。为了回答问题<span
class="math inline">\((a) -
(d)\)</span>，我们可以从简单的多项式开始尝试，比如一次多项式（也称线性多项式，因为它们的图形是直线）。对于一个整系数的线性方程：
<span class="math display">\[ax + by = c\]</span>
这些问题都很容易回答，即总存在无穷多个有理数解；如果<span
class="math inline">\(gcd(a, b)\)</span>不能整除<span
class="math inline">\(c\)</span>，就没有整数解，如果<span
class="math inline">\(gcd(a, b)\)</span>能整除<span
class="math inline">\(c\)</span>，就有无穷多个整数解。因此，二元线性方程比一元高阶方程还更容易。</p>
<p>接下来我们来看二阶的情况，也叫二次多项式。它们的图形是圆锥曲线，如果这样的方程存在一个有理数解，那么它就有无穷多个有理数解。用几何方法可以很容易地描述整个解的完整集合。我们将在第1.1节简要地解释这是如何实现的。我们还将简要说明，如何回答关于二次多项式的问题<span
class="math inline">\((b)\)</span>。因此，尽管说二次多项式的问题很容易是太不正确的，但公平地说，它们的解是已经被完全理解的。</p>
<p>这就引出了本书的主题，即有理数和整数在三次多项式方程中的解。这类方程的一个例子是我们之前看到的Bachet方程<span
class="math inline">\(y^2−x^3 =
c\)</span>。在我们的学习过程中，还会出现一些其他的例子： <span
class="math display">\[y^2 = x^3 + ax^2 + bx + c \quad \text{and}
\quad  ax^3 + by^3 = c\]</span>
这些方程的实数解组成的图形，被称为三次曲线或椭圆曲线。与线性方程和二次方程相比，三次方程的有理数解和整数解仍然没有被完全理解。即使在这些情况下，完整的答案是已知的，即证明将涉及到代数、数论和几何方法的微妙融合。本书的主要目的是，通过深入研究丢番图方程中第一种尚未被完全理解的情况，即二元三次方程，向大家介绍丢番图方程这一美妙的主题。为了对将要研究的结果有个大致的了解，我们在此简要说明三次曲线在问题<span
class="math inline">\((a) - (d)\)</span>的已知情况。</p>
<p>首先，Siegel在20世纪20年代证明了三次方程只有有限多个整数解，并且在1970年Baker和Coates以多项式系数形式给出了最大解的显式上界。这为<span
class="math inline">\((a)\)</span>和<span
class="math inline">\((c)\)</span>提供了一个令人满意的答案，尽管Baker-Coates给出的最大解上界通常大得不现实。在第五章中，我们将证明Siegel定理的一个特例，即关于<span
class="math inline">\(ax^3 + by^3 = c\)</span>形式的方程。</p>
<p>其次，三次方程所有可能的无限多个有理解都可以从有限的解集出发，并重复应用类似于Bachet复制公式的几何过程来找到。总是存在一个有限生成解的集合，是由庞加莱在1901年提出的，并由L.J.
Mordell在1923年证明。我们将在第三章证明Mordell定理的一个特例。然而，我们必须指出，Mordell定理并没有真正地回答问题<span
class="math inline">\((b)\)</span>和<span
class="math inline">\((d)\)</span>。正如我们将要看到的，Mordell定理的证明给出了一个过程，它<em>通常</em>允许在有理数的解集中找到一个有限生成解的集合。但这只是推测，尚未得到证实，即Moerdel的方法总能产生一个有限生成解的集合。因此，即使对于特殊类型的三次方程，如<span
class="math inline">\(y^2−x^3 = c\)</span>和<span
class="math inline">\(ax^3 + by^3 =
c\)</span>，目前还没有一种通用的方法（算法）可以确保回答问题<span
class="math inline">\((b)\)</span>或<span
class="math inline">\((d)\)</span>。</p>
<p>我们已经多次提到，丢番图方程的研究涉及到代数、数论和几何之间的相互作用。几何的成分现在已经很清楚了，因为方程本身定义了平面上的一条曲线（在两个变量的情况下），我们已经看到考虑这条曲线与各种直线的交点是多么有用。数论也很明显，因为我们在寻找整数或有理数的解，而数论的核心除了研究整数或有理数之间的关系之外，就没有什么了。但是代数呢？我们可以指出多项式本质上是一种代数对象。然而，其实代数扮演着更重要的角色。</p>
<p>回想一下，Bachet的复制公式可以这样描述：从三次曲线上的点<span
class="math inline">\(P\)</span>开始，在点<span
class="math inline">\(P\)</span>处画切线，取切线与曲线的第三个交点。同样地，如果我们从曲线上的两个点<span
class="math inline">\(P_1\)</span>和<span
class="math inline">\(P_2\)</span>开始，我们可以画一条穿过<span
class="math inline">\(P_1\)</span>和<span
class="math inline">\(P_2\)</span>的直线，然后看第三个交点<span
class="math inline">\(P_3\)</span>。这适用于<span
class="math inline">\(P_1\)</span>和<span
class="math inline">\(P_2\)</span>的大多数选择，因为大多数直线与三次曲线相交的点恰好是三个。我们可以将此过程（如图<span
class="math inline">\(3\)</span>所示）描述为在曲线上“添加”两个点并获得第三个点的一种方法。令人惊讶的是，经过细微地修改，这个几何运算将三次方程的有理解集变成了一个阿贝尔群！之前提到的Mordell定理，可以重新表述为这个群有有限数量的生成元。这就是把代数、数论和几何组合在一起的20世纪最伟大的定理之一。</p>
<img src="/2022/11/04/RationalPointOnEllipticCurves/figure3.png" class="" title="三次曲线上两个点的“加法”">
<p>我们希望前面的介绍已经让你相信丢番图方程在理论上的美妙和优雅。但是丢番图方程的研究，特别是椭圆曲线理论，也有它的实际应用。我们将在本书中研究两个这样的应用。</p>
<p>每个人都熟悉算术基本定理，它断言每个正整数都能被唯一地分解成素数的乘积。但是，如果整数相当大，比如在<span
class="math inline">\(10^{300}\)</span>到<span
class="math inline">\(10^{600}\)</span>之间，那么现实中可能不能完成该分解。虽然有快速的方法来检查这个大小的整数，是否为素数，或者说如果有人给你一个合数<span
class="math inline">\(N\)</span>，比如说有<span
class="math inline">\(450\)</span>位，那么你可以很容易地证明<span
class="math inline">\(N\)</span>不是质数，即使你可能无法找到<span
class="math inline">\(N\)</span>的任何质数因子。这种奇怪的现象，被Rivest,
Shamir和Adleman用来构建了第一个实用且安全的公开密钥密码系统，称为RSA。因此，找到一个大数的最佳分解算法，就具有了现实意义。其中有一种算法，当<span
class="math inline">\(N\)</span>具有不同大小的因子时特别有效，是由Hendrik
Lenstra提出的，它使用了在有限域上定义的椭圆曲线。我们在第4.4节描述Lenstra算法。</p>
<p>正如大数分解是困难的一样，将椭圆曲线上的一个给定点表示为曲线上另一个给定点的倍数也是困难的。实际上，根据目前的算法，它似乎比大数分解还困难得多，这被称为<em>椭圆曲线离散对数问题</em>。它已经被用作公开密钥密码系统的基础，因为底层的数学问题有更高的难度，在某些方面甚至比RSA更有效。我们在第4.5节简要介绍椭圆曲线密码学。</p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Elliptic Curves</tag>
      </tags>
  </entry>
  <entry>
    <title>SonarQube代码扫描</title>
    <url>/2021/01/22/SonarQube/</url>
    <content><![CDATA[<h2 id="sonarqube容器化安装">1、SonarQube容器化安装</h2>
<p>采用docker-compose方式部署SonarQube服务，但是需要先做一些系统设置才能启动</p>
<ul>
<li>对sonarqube挂载目录赋权：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sonarqube/   #与docker-compose.yml文件一致</span><br><span class="line">chown -R 999:999 .</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li>由于 Elasticsearch 占用内存较高。官方要求 <code>max_map_count</code>
需要配置到最小 <code>262144</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
<p>看有的文章提到还需要设置
<code>fs.file-max</code>，但本地部署未设置没有发现问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -w fs.file-max=65536</span><br></pre></td></tr></table></figure>
<p>上述设置是临时生效，如果需要永久生效，需要编辑
<code>/etc/sysctl.conf</code> 文件加入以下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br><span class="line">fs.file-max=65536</span><br></pre></td></tr></table></figure>
<p>如果采用永久配置，保险起见，重启系统</p>
<ul>
<li>创建docker-compose.yml文件如下</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:12</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5432</span><span class="string">:5432</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/postgres/postgresql/:/var/lib/postgresql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/postgres/data/:/var/lib/postgresql/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">sonar</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">sonar</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">sonar:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sonarqube:7.9-community</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sonar</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/sonarqube/extensions:/opt/sonarqube/extensions</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/sonarqube/logs:/opt/sonarqube/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/sonarqube/data:/opt/sonarqube/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/sonarqube/conf:/opt/sonarqube/conf</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9000</span><span class="string">:9000</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SONARQUBE_JDBC_USERNAME:</span> <span class="string">sonar</span></span><br><span class="line">      <span class="attr">SONARQUBE_JDBC_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line">      <span class="attr">SONARQUBE_JDBC_URL:</span> <span class="string">jdbc:postgresql://postgres:5432/sonar</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>在服务器部署时遇到了隔一段时间sonar容器宕机问题，排查可能还是es的jvm设置问题（内存不足导致堆栈溢出）。所以需要在部署文件中sonar的
<code>environment</code> 增加一项</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">SONARQUBE_SEARCH_JAVAOPTS=&quot;-Xmx1G</span> <span class="string">-Xms1G&quot;</span> <span class="comment">#对于运行ElasticSearch的JVM</span></span><br></pre></td></tr></table></figure>
<p>如果出现类似的问题，可能需要增加其他jvm设置项</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">SONARQUBE_WEB_JAVAOPTS=&quot;-Xmx1G</span> <span class="string">-Xms1G&quot;</span> <span class="comment">#对于Web Server JVM</span></span><br><span class="line"><span class="string">SONARQUBE_CE_JAVAOPTS=&quot;-Xmx1G</span> <span class="string">-Xms1G&quot;</span> <span class="comment">#对于计算引擎JVM</span></span><br></pre></td></tr></table></figure>
<p>1G的大小可以根据实际情况调整，一般不少于512m</p>
<h2 id="配置代码项目的-sonar-project.properties-文件">2、配置代码项目的
<code>sonar-project.properties</code> 文件</h2>
<p>需要安装 <code>sonar-scanner</code></p>
<h3 id="go语言项目">go语言项目</h3>
<ul>
<li><p>在 SonarQube &gt; Administration &gt; Marketplace 中安装
<code>SonarGo</code> 插件</p></li>
<li><p>采用 <code>golangci-lint</code> 扫描，安装后运行</p></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">golangci-lint run -v --out-format checkstyle &gt; report.xml</span><br></pre></td></tr></table></figure>
<ul>
<li><code>go test</code>执行单元测试，并输出覆盖率报告</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test -coverprofile=coverage.out ./...</span><br><span class="line">go test -json ./... &gt; report.json</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sonar-project.properties</code> 示例如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line">sonar.login=admin</span><br><span class="line">sonar.password=admin</span><br><span class="line">sonar.projectKey=&lt;Progect_Name&gt;</span><br><span class="line">sonar.projectName=&lt;Progect_Name&gt;</span><br><span class="line">sonar.projectVersion=1.0</span><br><span class="line">sonar.go.golangci-lint.reportPaths=report.xml</span><br><span class="line">sonar.go.coverage.reportPaths=coverage.out</span><br><span class="line">sonar.go.tests.reportPaths=report.json</span><br><span class="line">sonar.sources=./</span><br><span class="line">sonar.exclusions=**/*_test.go,**/vendor/**</span><br><span class="line">sonar.language=go</span><br><span class="line">sonar.tests=.</span><br><span class="line">sonar.test.inclusions=**/*_test.go</span><br><span class="line">sonar.test.exclusions=**/vendor/**</span><br></pre></td></tr></table></figure>
<ul>
<li>运行 <code>sonar-scanner</code> 即可</li>
</ul>
<h3 id="java项目">Java项目</h3>
<ul>
<li><p>在 SonarQube &gt; Administration &gt; Marketplace 中安装
<code>Java Code Quality and Security</code> 插件</p></li>
<li><p>Sonarqube扫描Java项目需要先对项目编译，以maven为例</p></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sonar-project.properties</code> 示例如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line">sonar.login=admin</span><br><span class="line">sonar.password=admin</span><br><span class="line">sonar.projectKey=&lt;Progect_Name&gt;</span><br><span class="line">sonar.projectName=&lt;Progect_Name&gt;</span><br><span class="line">sonar.projectVersion=1.0</span><br><span class="line">sonar.java.binaries=target/classes</span><br><span class="line">sonar.sources=src</span><br><span class="line">sonar.language=java</span><br></pre></td></tr></table></figure>
<ul>
<li>运行 <code>sonar-scanner</code> 即可</li>
</ul>
<h3 id="javascript项目">JavaScript项目</h3>
<ul>
<li><p>在 SonarQube &gt; Administration &gt; Marketplace 中安装
<code>SonarJS</code> 插件，会自动安装 <code>SonarTS</code> 插件</p></li>
<li><p><code>sonar-project.properties</code> 示例如下：</p></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line">sonar.login=admin</span><br><span class="line">sonar.password=admin</span><br><span class="line">sonar.projectKey=&lt;Progect_Name&gt;</span><br><span class="line">sonar.projectName=&lt;Progect_Name&gt;</span><br><span class="line">sonar.projectVersion=1.0</span><br><span class="line">sonar.sources=src</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sonar.tests=<span class="built_in">test</span></span></span><br><span class="line">sonar.language=js</span><br><span class="line">sonar.profile=node</span><br><span class="line"></span><br><span class="line">sonar.dynamicAnalysis=reuseReports</span><br><span class="line"></span><br><span class="line">sonar.javascript.jstest.reportsPath=reports</span><br><span class="line">sonar.javascript.lcov.reportPath=reports/coverage.lcov</span><br></pre></td></tr></table></figure>
<ul>
<li>运行 <code>sonar-scanner</code> 即可</li>
</ul>
<h3 id="rust项目">Rust项目</h3>
<ul>
<li><p>在 SonarQube Marketplace 还没有官方 <code>Rust</code>
插件，需要手动将 <a
href="https://github.com/elegoff/sonar-rust"><code>SonarRust</code></a>
插件安装到 Sonarqube 的 <code>extensions/plugins</code> 目录下，并重启
Sonarqube</p></li>
<li><p>采用 <code>cargo clippy</code> 扫描，运行</p></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo clippy --message-format=json &amp;&gt; report.json</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sonar-project.properties</code> 示例如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line">sonar.projectKey=&lt;Progect_Name&gt;</span><br><span class="line">sonar.projectName=&lt;Progect_Name&gt;</span><br><span class="line">sonar.projectVersion=1.0 \</span><br><span class="line">sonar.sources=src \</span><br><span class="line">sonar.exclusions=**/protos/**,**/target/** \</span><br><span class="line">sonar.language=rust \</span><br><span class="line">sonar.rust.clippy.reportPaths=report.json</span><br></pre></td></tr></table></figure>
<ul>
<li>运行 <code>sonar-scanner</code> 即可</li>
</ul>
<h2 id="使用-gitlab-ci-自动集成sonar代码扫描">3、使用
<code>gitlab-ci</code> 自动集成sonar代码扫描</h2>
<h3 id="配置go语言项目">配置go语言项目</h3>
<ul>
<li>修改ci相关的shell脚本，并在ci文件中加入scanner步骤</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -i --rm -v $(pwd):/src -w /src &lt;harbor-url&gt;/golangci-lint:latest golangci-lint run -v --timeout 10m --out-format checkstyle &gt; report.xml</span><br><span class="line"></span><br><span class="line">docker run -i --rm -v $(pwd):/src -w /src &lt;harbor-url&gt;/golang:latest go test -coverprofile=coverage.out ./... ; go test -json ./... &gt; report.json</span><br><span class="line"></span><br><span class="line">docker run -i --rm -v $(pwd):/src -w /src &lt;harbor-url&gt;/sonar-scanner-cli:latest sonar-scanner -X \</span><br><span class="line">  -Dsonar.host.url=http://localhost:9000 \</span><br><span class="line">  -Dsonar.sourceEncoding=UTF-8 \</span><br><span class="line">  -Dsonar.login=admin \</span><br><span class="line">  -Dsonar.password=admin \</span><br><span class="line">  -Dsonar.projectKey=&lt;Progect_Name&gt; \</span><br><span class="line">  -Dsonar.projectName=&lt;Progect_Name&gt; \</span><br><span class="line">  -Dsonar.projectVersion=1.0 \</span><br><span class="line">  -Dsonar.go.coverage.reportPaths=coverage.out \</span><br><span class="line">  -Dsonar.go.tests.reportPaths=report.json \</span><br><span class="line">  -Dsonar.sources=./ \</span><br><span class="line">  -Dsonar.exclusions=**/*_test.go,**/vendor/** \</span><br><span class="line">  -Dsonar.language=go \</span><br><span class="line">  -Dsonar.tests=. \</span><br><span class="line">  -Dsonar.working.directory=/tmp \</span><br><span class="line">  -Dsonar.test.inclusions=**/*_test.go \</span><br><span class="line">  -Dsonar.test.exclusions=**/vendor/** \</span><br><span class="line">  -Dsonar.go.golangci-lint.reportPaths=report.xml ; rm -rf report.xml coverage.out report.json</span><br></pre></td></tr></table></figure>
<h3 id="配置java项目">配置Java项目</h3>
<ul>
<li>修改ci相关的shell脚本，并在ci文件中加入scanner步骤</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function scanner()&#123;</span><br><span class="line">    log &quot;scanner begin&quot;</span><br><span class="line">    mvn $&#123;MVN_OPTIONS&#125; compile</span><br><span class="line">    docker run -i --rm -v $(pwd):/src -w /src &lt;harbour-url&gt;/sonar-scanner-cli:latest sonar-scanner -X \</span><br><span class="line">        -Dsonar.host.url=http://localhost:9000 \</span><br><span class="line">        -Dsonar.sourceEncoding=UTF-8 \</span><br><span class="line">        -Dsonar.login=admin \</span><br><span class="line">        -Dsonar.password=admin \</span><br><span class="line">        -Dsonar.projectKey=&lt;Progect_Name&gt; \</span><br><span class="line">        -Dsonar.projectName=&lt;Progect_Name&gt; \</span><br><span class="line">        -Dsonar.projectVersion=1.0 \</span><br><span class="line">        -Dsonar.java.binaries=target/classes \</span><br><span class="line">        -Dsonar.sources=src \</span><br><span class="line">        -Dsonar.language=java \</span><br><span class="line">        -Dsonar.working.directory=/tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置javascript项目">配置JavaScript项目</h3>
<ul>
<li>修改gitlab-ci.yaml文件即可</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">scanner</span></span><br><span class="line"></span><br><span class="line"><span class="string">.import_functions:</span> <span class="string">&amp;import_functions</span> <span class="string">|</span></span><br><span class="line"></span><br><span class="line">  <span class="string">function</span> <span class="string">scanner()</span> &#123;</span><br><span class="line">    <span class="string">docker</span> <span class="string">run</span> <span class="string">-i</span> <span class="string">--rm</span> <span class="string">-v</span> <span class="string">$(pwd):/src</span> <span class="string">-w</span> <span class="string">/src</span> <span class="string">&lt;harbour-url&gt;/sonar-scanner-cli:latest</span> <span class="string">sonar-scanner</span> <span class="string">-X</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.host.url=http://localhost:9000</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.sourceEncoding=UTF-8</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.login=admin</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.password=admin</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.projectKey=$</span>&#123;<span class="string">CI_PROJECT_NAME</span>&#125;  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.projectName=$</span>&#123;<span class="string">CI_PROJECT_NAME</span>&#125;  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.projectVersion=1.0</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.sources=src</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.language=js</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.profile=node</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.working.directory=/tmp</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.dynamicAnalysis=reuseReports</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.javascript.jstest.reportsPath=reports</span>  <span class="string">\</span></span><br><span class="line">        <span class="string">-Dsonar.javascript.lcov.reportPath=reports/coverage.lcov</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="meta">*import_functions</span></span><br></pre></td></tr></table></figure>
<h3 id="配置rust项目">配置Rust项目</h3>
<ul>
<li>修改ci相关的shell脚本，并在ci文件中加入scanner步骤</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo clippy --message-format=json &amp;&gt; report.json</span><br><span class="line"></span><br><span class="line">docker run -i --rm -v $(pwd):/src -w /src &lt;harbour-url&gt;/sonar-scanner-cli:latest sonar-scanner -X \</span><br><span class="line">  -Dsonar.host.url=http://localhost:9000 \</span><br><span class="line">  -Dsonar.sourceEncoding=UTF-8 \</span><br><span class="line">  -Dsonar.projectKey=$&#123;CI_PROJECT_NAME&#125; \</span><br><span class="line">  -Dsonar.projectName=$&#123;CI_PROJECT_NAME&#125; \</span><br><span class="line">  -Dsonar.projectVersion=1.0 \</span><br><span class="line">  -Dsonar.sources=src \</span><br><span class="line">  -Dsonar.exclusions=**/protos/**,**/target/** \</span><br><span class="line">  -Dsonar.language=rust \</span><br><span class="line">  -Dsonar.working.directory=/tmp \</span><br><span class="line">  -Dsonar.rust.clippy.reportPaths=report.json ; rm -rf report.json</span><br></pre></td></tr></table></figure>
<h2 id="sonarqube从7.9升级到8.9-lts">4、Sonarqube从7.9升级到8.9 LTS</h2>
<p>参见 <a
href="https://docs.sonarqube.org/latest/setup/upgrading/">Sonarqbue官方升级说明</a></p>
<h3 id="暂停旧服务">暂停旧服务</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>
<h3 id="删除不兼容的plugins">删除不兼容的Plugins</h3>
<p>不兼容的Plugin列表见：<a
href="https://docs.sonarqube.org/latest/instance-administration/plugin-version-matrix/">Plugin
Version Matrix</a></p>
<h3 id="修改docker-compose.yaml文件">修改docker-compose.yaml文件</h3>
<p>将</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sonar:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">sonarqube:7.9-community</span></span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sonar:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">sonarqube:8.9-community</span></span><br></pre></td></tr></table></figure>
<p>即可</p>
<h3 id="重新启动服务">重新启动服务</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>时间探秘</title>
    <url>/2022/03/22/TimeTour/</url>
    <content><![CDATA[<p>平时总会跟大家瞎聊一些东西，这时候发现有的人想聊哲学，有的人想聊物理，我思考了很久就找到了“时间”这个话题。</p>
<p>其实不管是生活中，还是科学理论和技术实践上，都有许多跟时间有关的事情，这些是可以串起来聊一聊的。</p>
<p>不过此文很长，并且有点“凌乱”，最后可能会让人觉得其实只是“好像一些没啥用的知识又增加了”。</p>
<span id="more"></span>
<h2 id="时间是什么">时间是什么？</h2>
<p>首先从哲学开始，先理清一下“哲学”的概念——哲学是研究普遍的、基础问题的学科。</p>
<p>我对哲学的理解，简单地说是，人类的“意识”对“物质”世界产生的“认知”，最终形成了对各种事物在我们脑海里所对应的“概念”，并且通过“归纳”、“演绎”等方式最终形成了“逻辑”与“知识”。</p>
<p>哲学当然是普遍的，例如大量的人可能不需要太多的交流，也能达成相近的哲学意识。但是哲学又是个性化的，每个人也可以有自己的“哲学”。</p>
<p>那“时间”在哲学里是个什么概念呢？</p>
<p>时间似乎是一个人出生之后就不言自明的“概念”了。</p>
<p>但细细想来，我不知道准确的答案，而且似乎哲学上也没有准确的定义。</p>
<p>当我搜索Wikipedia时，就发现这样一句话：“长久以来，时间一直是宗教、哲学及科学领域的研究主题之一，但学者们尚且无法为时间找到一个可以适用于各领域、具有一致性且又不循环的定义”。</p>
<p>对“时间”这个概念，是不是感受到好像没有那么简单了。</p>
<h2 id="生活时间">生活时间</h2>
<p><em>人的知识首先来自于生活常识</em></p>
<h3 id="时间的感知">时间的感知</h3>
<p>如果回到最基本的概念上，尽量不预设任何的知识，让我们想一想人是如何感知到“时间”的呢？</p>
<p>人们常常会说“世界好安静，仿佛时间都停止了”，也就是说一个静止的世界会让人感受不到时间的存在。</p>
<p>反之，如果坐在马路边，当看着小汽车一辆辆地驶过、看着工地上将楼房一层层加高，时间好像在发生作用了。</p>
<p>如果有人拿出同一个地点的两张照片，当它们长得一模一样或者说连“找茬”也发现不了任何区别，那么一般来说这两张照片应该是在同一个时间拍摄的。</p>
<p>反之，如果发现了一些区别，或者说照片里的某些元素发生了变化，人就能从这些变化中感知到时间的流逝。</p>
<p>所以虽然我不能给时间一个很好的定义，但我们都可以确信——时间是对物质世界变化的一种感知。</p>
<p>对于这样一次的“变化”，我们可以称之为“事件”。</p>
<p>事件的发生是与某个具体的时间相关联、相对应的。</p>
<p>多个事件的发生有先后顺序，也就是在时间上有“早晚”的概念。</p>
<p>（更准确地说，这个时间的比较应该是在同一个地点上发生的事件，或者是在同一个地点上观察到的事件。）</p>
<p>这样可以明确时间的一个重要特性——传递性，即在时间上对多个事件早晚关系之间的比较是可以依次传递的。例如，假设A比B早、B又比C早，那就一定有A比C早。</p>
<p>时间的传递性看起来是理所当然的，但这是一个很重要的数学性质。</p>
<p>因为这表示时间在拓扑结构上应该没有“成环”，而是一条“线”。</p>
<p>如果可以明确一个方向，即是“射线”，一般称它为“时间轴”。</p>
<h3 id="时间的度量">时间的度量</h3>
<p>那如何度量时间呢？</p>
<p>远古的人类看着太阳早起晚落，才有了“一天”的时间概念。另一方面，人们很难把“打到一只猎物”这种不确定的事件作为一种时间的衡量维度。</p>
<p>其实我们能够发现，身边有很多“事件”在周而复始的发生，即周期性的事件，就可以用它们来度量时间。</p>
<ul>
<li><p>好比地球绕太阳公转一周，即地球上四季的一轮变化，可以算作1年。</p></li>
<li><p>月球绕地球公转一周，也就是月亮一轮阴晴圆缺，可以算作1月。</p></li>
<li><p>当然还有地球自转一周，即太阳东升西落到再次升起，可以算作1日。</p></li>
</ul>
<p>人们就这样通过各种各样自然界的周期性事件，建立了对时间的度量维度。</p>
<p>如果可以对周期性事件的发生次数进行计数，就可以得到一种对时间的计量，例如第几天、第几年等等。</p>
<p>当然因为周期时间的尺度不同，这就是在不同的量级上为时间建立了不同的测量方法。</p>
<p>这样在时间轴上就定义了“刻度”，也就是给了每一个物理上发生的事件一个明确的时间坐标，这样也能很方便地辨识两个事件的早晚了。</p>
<p>在有了度量方法的基础上，可以注意分辨一下语言可能带来的歧义，即时间其实有两个涵义“时刻”和“时段”。</p>
<p>时刻在时间轴上是一个点，代表一个具体的事件发生时间点，而时段则是一个线段，是两个事件的间隔时间区间，或者表示一个事件持续发生的时间长度。</p>
<p>在生活语言中，我们往往对这两个涵义不加区分，例如“你今天什么时间去晚饭？”表示的是时刻，而“你今天下午有时间讨论一下吗？”更多表示的是时段（如果你3点零5分有事情，那一般不会回答自己3点有空吧）。</p>
<p>现在分清了时间的这两个语义，就可以更明确地讨论一些问题。例如产品运营上常常提出一些需求，比如“我们要做一个随时间变化的新增用户数看板”，这句话里的时间是哪个意思呢？</p>
<p>这里其实至少包含了三个“时间”：首先有一个“时刻”是看板的横轴刻度，其次有一个“时段”是看板的起止时间（绘图区间），最后还有一个很隐蔽的“时段”是对新增用户数的统计时长。</p>
<p>如果把统计时长分得很小（例如每秒就统计一次），那在这个时段内的新增用户数大概率其实是零的，也就没有数据，这种图画出来是很不好看的。</p>
<p>既然要指出是对每小时或者每天的新增用户数进行统计，这句话蕴含的精确意思可能是“以<code>日期</code>为横坐标，做一个<code>近三个月</code>的<code>每日</code>新增用户数看板”。</p>
<h3 id="历法">历法</h3>
<p>到这里为止，其实都是一些对生活时间的简单常识了，现在可以稍微深入下去，想点复杂一些的事情了。</p>
<p>回到年月日的讨论中来，也就是在常识上地球绕太阳一周是1年、地球自转一周是1天，大家肯定觉得是没有什么问题了。</p>
<p>但是一个很不巧（其实是必然）的事情是，1年并不是1天在时间上的整数倍。</p>
<p>更复杂地是，精确地现代观测发现，其实“年”还至少有两个不同的概念，一个叫回归年，一个叫恒星年。</p>
<img src="/2022/03/22/TimeTour/AxialTiltObliquity-zh-Hans.png" class="" title="天球、赤道、黄道与自转轴">
<p>回归年是站在地面观察者（也就是我们日常生活）的角度看到的1年，指太阳连续两次通过春分点的时间间隔。</p>
<p>我们想象有一个与地球同球心，并有相同的自转轴，半径无限大的球，称为“天球”。</p>
<p>地球的自转可以投影出“赤道”，而地球绕太阳公转的轨道面截天球所得的圆称为“黄道”。</p>
<p>黄道和赤道有两个交点，而“春分点”指的就是太阳从南向北在黄赤道上的交点。</p>
<p>即太阳的中心自西向东沿黄道从春分点到下一个春分点所经历的时间，是一个回归年，又称为太阳年。</p>
<p>1回归年有365.2422日，即365天5小时48分46秒。</p>
<p>恒星年是地球公转的真正周期，是在太空的角度看到的1年，从太阳上看，地球中心从太空中的某一点出发，环绕太阳一周，然后又回到了此点。</p>
<p>如果从地球上看，则是太阳中心从黄道上的某一点（可以对应某一颗遥远的恒星）出发，运行周天，然后又回到了同一点（同一恒星）。</p>
<p>1恒星年约为365天6时9分10秒。</p>
<p>因为地球的自转轴方向其实不是保持不动的，这个运动称为“进动”。</p>
<p>关于进动，可以想象一个陀螺，它在自转的同时，自转轴也在转动。</p>
<p>1个恒星年会比1个回归年要长大约10分钟，这个时间被称为“岁差”，也就是说大约每过140个恒星年会比相应的回归年多过了1天的时间。</p>
<p>那日历上的“年”，是按哪个“年”来的呢？显然是基于回归年，因为我们的古人只在地球上生活，太阳的光照是最直观也最重要的感知。</p>
<p>那么如何给某年中的某天一个标记，就是记录生活时间所要解决的首要问题了。</p>
<p>最简单的办法，从每年开始的第一天依次计数，这样可以记录到第365天算做一年的结束。</p>
<p>这里马上可以发现有两个问题，一是人工计数到365实在是有点不方便而且容易记错，二是既然1年不是1天的整数。</p>
<p>如果扔掉0.2422的小数不管的话，四五年之后，日历上一年的开始就要和它本应该开始的日期差出1天的时间了。</p>
<p>从古至今，无论国内外的哪个文明，最重要的一件事情就是确定“历法”了，也就是根据对天象的观察，确定一套满足日常生活所需要的时间记录方法。</p>
<p>例如，现在国际通用的公历，就是由古罗马的儒略历演变而来。现在公历以耶稣诞生之年作为纪年的开始（称为“元年”），并且把1年分为12个月，其中大月31天、小月30天。</p>
<p>有意思的是，在古罗马时期，著名的凯撒大帝也就是盖乌斯·尤利乌斯·恺撒(Gaius
Julius
Caesar)要用他的名字赋予他出生的七月（July），而他的继任者盖维斯·屋大维·奥古斯都也以自己的名字命名了八月(August)，并且都要求七八月都是大月（31天），最后大家就只好把二月减少至28天了。</p>
<p>为了解决回归年带小数的问题，公历上每4年设置了一个闰日，但是除非年份能被400整除，否则所有的世纪年（能被100整除）都不设闰日。这样公历年的平均长度为365.2425日，就与回归年的实际时长很接近了。</p>
<p>公历是只依照太阳运动以及有关的季节变化来确定的，所以是一种“太阳历”，简称阳历。</p>
<p>有“阳”就有“阴”，只依照月亮运动来确定的历法就称为阴历。</p>
<p>不过中国农历不是简单的“阴历”，因为农历即参照了月亮运动，也合并考虑了太阳的变化，所以其实是一种“阴阳历”。</p>
<p>农历首先根据月相的变化周期，以每一次月相朔望变化为一个月，同时参考太阳回归年为一年的长度，并设置了二十四节气，其中平年为十二个月、闰年为十三个月，大月三十天、小月二十九天。</p>
<p>农历需要通过合理的置闰法，如在19个农历年中加入7个闰年，使得日历上一年的平均天数与回归年的天数相符。</p>
<p>这种在“时间”上的复杂性，使得中国历史上一共产生了超过102部历法。</p>
<h3 id="世界时和时区">世界时和时区</h3>
<p>当古人只在地球上一个小范围内生活的时候，周围的人都可以共用一个日历。</p>
<p>但随着大航海的发现，地球是一个球体，当然是有时区的。</p>
<p>麦哲伦舰队在环球航行的时候，有一个船员每天都会写日记，当他回国的时候才发现日期“少”了一天。</p>
<p>这就是因为船每天都顺着太阳转动的方向（从东向西）航行，造成了船上的每一天实际上都比陆地上的每一天多了一点点时间，累积下来最终就差出了一天的日期。</p>
<p>现在出国旅行一般都要“倒时差”了，就是因为地球其他地区的“正午”并不一定就是我们当地时间的“正午”，大家以太阳光照判断出来的生活时间是不一样的。</p>
<p>为了能在地球上有一个统一的时间，现在确立了以格林尼治时间为标准时间的“世界时”，同时将地球上每15度设为一个时区（360度除以24小时），不同地区的人也都有了自己的“地方时”，这样总算是解决了地球人类的时差问题。</p>
<img src="/2022/03/22/TimeTour/World_Time_Zones_Map.png" class="" title="世界时区图">
<p>但是人类社会是更加复杂的，真实世界的时区设置不是理论上的那么简单。</p>
<p>比如国际日期变更线，大致上以180度经线为准，但是需要尽量绕开陆地和一些岛屿，并且照顾行政区划的统一。</p>
<p>例如，2011年12月29日萨摩亚把时区从国际日期变更线以东调整到了国际日期变更线以西，而美属萨摩亚却没有跟随调整，此举导致萨摩亚群岛出现了一整日时差。</p>
<p>中国横跨了东五区、东六区、东七区、东八区、东九区5个时区，但却统一使用北京所在的东八区时间。</p>
<p>美国本土分为了4个时区，俄罗斯甚至分成了11个时区。所以有新闻报道了俄罗斯的“高考趣闻”，远东地区都考完了，考生顺手把试题公布到网上，结果欧洲部分的考生还没进考场呢。</p>
<h2 id="物理时间">物理时间</h2>
<p><em>物理是一门定量的科学</em></p>
<h3 id="时间单位">时间单位</h3>
<p>现在“秒”是国际单位制中时间的基本单位。秒最初的来源是把1天分成24小时，1小时又分成60分钟，1分钟再分成60秒，即1天=86400秒。</p>
<p>在机械钟表出现之前，要比较精确地测量1秒是不太容易的，因为生活中好像没有这么严格的周期性事件。</p>
<p>在17世纪，摆钟的出现使得人们首次可以精确的计时到秒。</p>
<p>有个有趣的“发现”是，重力加速度差不多就是圆周率的平方，这就与秒摆有关。</p>
<p>因为摆动一下为1秒（即摆动周期为2秒）的摆钟，在标准重力下的摆长“恰巧”很接近1米，那根据单摆周期公式
<span class="math inline">\(𝑇=2\pi\sqrt{𝑙/𝑔}\)</span>就有<span
class="math inline">\(g\approx\pi^2\)</span>了。</p>
<p>在20世纪初，发明了石英谐振器，是一种利用石英晶片因压电效应而产生谐振现象的原理制成的器件。</p>
<p><em>压电效应是由雅克·居里（哥哥）与皮埃尔·居里（弟弟，就是居里夫人的老公咯）于1880年发现的。</em></p>
<p>石英谐振器的频率大致在兆赫兹，也就是可以提供微秒级的时间精度。</p>
<p>现在，已知最精准的时钟是“原子钟”，是基于原子能级间跃迁产生的电磁波来估算时间的。</p>
<p>当前最先进的原子钟时间精度已经达到<span
class="math inline">\(10^{-16}s\)</span>的量级了。</p>
<p>因此在1967年召开的第13届国际度量衡大会上，通过了用铯-133原子钟作为国际单位制中秒的定义。</p>
<p>国际单位制是世界上最普遍采用的标准度量系统，有七个基本单位。</p>
<p>随着2019年对质量、电流、热力学温度、物质的量的定义调整，现在所有的基本单位都已经采用物理常量的精确数值来定义了。</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 22%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">单位名称</th>
<th style="text-align: left;">单位符号</th>
<th style="text-align: center;">物理量</th>
<th style="text-align: center;">定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">秒</td>
<td style="text-align: left;"><span
class="math inline">\(s\)</span></td>
<td style="text-align: center;">时间</td>
<td
style="text-align: center;">铯-133原子在基态下的两个超精细能级之间跃迁所对应的辐射的9192631770个周期的时间</td>
</tr>
<tr class="even">
<td style="text-align: left;">米</td>
<td style="text-align: left;"><span
class="math inline">\(m\)</span></td>
<td style="text-align: center;">长度</td>
<td style="text-align: center;">光在<span
class="math inline">\(1/299792458\)</span>秒内在真空中行进的距离</td>
</tr>
<tr class="odd">
<td style="text-align: left;">千克</td>
<td style="text-align: left;"><span
class="math inline">\(kg\)</span></td>
<td style="text-align: center;">质量</td>
<td style="text-align: center;">由普朗克常数 <span
class="math inline">\(h = 6.62607015×10^{−34}J⋅s
(J=kg⋅m^2⋅s^{−2})\)</span>、米和秒所定义</td>
</tr>
<tr class="even">
<td style="text-align: left;">安培</td>
<td style="text-align: left;"><span
class="math inline">\(A\)</span></td>
<td style="text-align: center;">电流</td>
<td style="text-align: center;">由元电荷<span
class="math inline">\(e=1.602176634×10^{−19}C
(C=A⋅s)\)</span>和秒所定义</td>
</tr>
<tr class="odd">
<td style="text-align: left;">开尔文</td>
<td style="text-align: left;"><span
class="math inline">\(K\)</span></td>
<td style="text-align: center;">热力学温度</td>
<td style="text-align: center;">由玻尔兹曼常数<span
class="math inline">\(1.380649×10^{−23}J⋅K^{−1}
(J=kg⋅m^2⋅s^{−2})\)</span>、千克、米和秒所定义</td>
</tr>
<tr class="even">
<td style="text-align: left;">摩尔</td>
<td style="text-align: left;"><span
class="math inline">\(mol\)</span></td>
<td style="text-align: center;">物质的量</td>
<td style="text-align: center;">1摩尔包含<span
class="math inline">\(6.02214076×10^{23}\)</span>个基本实体，即阿伏伽德罗常数</td>
</tr>
<tr class="odd">
<td style="text-align: left;">坎德拉</td>
<td style="text-align: left;"><span
class="math inline">\(cd\)</span></td>
<td style="text-align: center;">发光强度</td>
<td style="text-align: center;">频率为<span
class="math inline">\(5.4×10^{14}\)</span>赫兹的单色光源在特定方向辐射强度为<span
class="math inline">\(\frac{1}{683}W/sr\)</span>时的发光强度</td>
</tr>
</tbody>
</table>
<h3 id="时间的对称性">时间的对称性</h3>
<p>从生活常识出发，已经建立了一条“时间轴”的概念。现在请想一想什么是“规律”？什么是“物理规律”？</p>
<p>书面意思是“规律是在某种范围内或某种条件下，事物间的必然本质联系”，而物理规律就是物质世界的规律了。</p>
<p>显而易见，物理规律应该是不随着时间而变化的，否则这就不能叫做“规律”了。</p>
<p>这里揭示了时间一个很重要的性质——时间平移不变性：在不同的时间，物理系统服从的规律是相同的。</p>
<p>这句话简直就是把“物理规律”的本意换了一种说法而已，所以这个性质是非常非常基本的，甚至都不能去怀疑它的正确性。</p>
<p>有意思的是，数学上可以证明“诺特定理”：通俗的说，每一种对称性都对应着一个守恒量。</p>
<p>时间平移不变性恰恰就是对应了能量守恒定律，也就是说如果有一天你想推翻一些“老旧”的物理定律，能量守恒是一定要保留到最后的。</p>
<p>另一方面，也可以定义时间反演不变性：例如在牛顿第二定律<span
class="math inline">\(𝑚𝑑^2𝑟/𝑑𝑡^2 =𝐹\)</span>中，将时间反号（<span
class="math inline">\(t&#39;=-t\)</span>），其实完全不会改变运动方程。</p>
<p>也就是说从力学的角度，如果时间方向反过来的话，物理规律应该也是不变的。</p>
<p>但热力学第二定律否定了这一点，也就是说时间其实有一个“正确”的方向，即让孤立系统的熵增大的方向。</p>
<p>一个在动力学规律上满足时间反演不变性的微观系统，为什么在宏观上却不满足时间反演不变性了呢？这仍然是现代理论物理中一个很有哲学意味的问题。</p>
<h3 id="时间的相对性">时间的相对性</h3>
<p>这里我不打算去思考时间的绝对性问题，也就是说从始至终都没有假设过每个人的时间会是一样的。</p>
<p>请直接进入到“正确”的思维中来，即每个人的时间理应是不一样的。这个性质在物理上被称为时间的相对性。</p>
<p>首先每一个“观察者”可以建立一个参考系，即让我们想象以某某的视角来观察这个世界。所以如果切换观察者的视角，能够看到的世界当然并不一定是一样的，理当如此对吧。</p>
<p>如果想象以一个刚体，即物理假设不会形变的物体，作为参考系。这样就可以用它的前后、左右、上下建立坐标系<span
class="math inline">\(O(x,y,z)\)</span>，而空间只有三个方向，这也是来自“生活常识”。</p>
<p>有了坐标系就可以给这个观察者“世界”中的所有物体赋予一个空间坐标了，这里需要引入“长度”的概念。</p>
<p>在思维实验上，只需要用一把“尺子”一点点地在三个方向去丈量，就可以得到某个点在当前参考系下的坐标。</p>
<p>那关键的问题就是，如何“统一”参考系的时间呢？</p>
<p>可以想象，观察者自己手里拿着一个时钟，滴答滴答地在走动。</p>
<p>离观察者很远、但是在空间上保持静止的某一个物体上也有一个时钟。</p>
<p>因为空间是均匀的，观察者和物体在理论上其实是完全对等的地位、彼此可以互相切换，所以在这里可以假设，两者时间流逝的速度理应是相同的。</p>
<p>这里相当于设想两个时钟是同一批次生产的、完全一模一样，所以在时间计数上也就完全相同。</p>
<p>唯一的问题是，两个时钟最初的时刻可能不一定是对齐的。例如在参考系的统一时间里，A时钟是从9点走到了10点，但B时钟是从9点零5分走到了10点零5分，两个时钟有5分钟的时差。</p>
<p>这时候观察者就需要首先和其他空间点上的时钟进行一次时间对齐了。</p>
<p>一个可行的方式就是通过某种信号传输手段（例如“光”），在观察者的时间（如<span
class="math inline">\(t_0=9:00:00\)</span>）发送到空间点A，A在收到信号后马上把自己的时间（<span
class="math inline">\(t_1=9:05:01\)</span>）发回观察者，当观察者收到返回的消息时（<span
class="math inline">\(t_2=9:00:02\)</span>），马上就可以计算出物体和自己之间的时间差（<span
class="math inline">\(\Delta
t=t_1-t_0-(t_2-t_0)/2\)</span>），并由此认为所有空间点都可以与自己进行时间对齐了。</p>
<p>接下来，继续考虑两个有相对运动的参考系。按照上面的方式，首先两者都可以分别建立自己的时空坐标系<span
class="math inline">\(O(x,y,z,t)\)</span>和<span
class="math inline">\(O^{\prime}(x^{\prime},y^{\prime},z^{\prime},t^{\prime})\)</span>。</p>
<p>为了方便，前者一般称为“静止系”，后者称为“运动系”。需要注意的是，静止和运动在这里是相对的，所以完全等价地，也可以把后者当做静止系，而把前者当做运动系。</p>
<p>在分清两个参考系后，就容易理清“同时”的相对性问题了。</p>
<p>“同时”可以有两种表述，一是在同一个地点同时发生了两个事件，但是更广泛地是在不同的地点同时发生了两个事件。</p>
<p>例如一个人站在窗边，外面电闪雷鸣，有两道闪电的光同时从左右两边射了进来，过了几秒它们的雷声也同时响起，那在这个人看来这两次闪电应当是同时发生的。</p>
<p>对于一个参考系来说，例如在静止系中，A和B同时的意思就是事件在时空坐标上满足<span
class="math inline">\(t_A = t_B\)</span>。</p>
<p>因为在两个相对运动的参考系中，建立了不同的时空坐标系，即一般来说<span
class="math inline">\(t_A \neq t^{\prime}_A\)</span>且<span
class="math inline">\(t_B \neq
t^{\prime}_B\)</span>，所以对于静止系中同时的事件，在运动系中当然并不一定也是同时的了。</p>
<h3 id="狭义相对论">狭义相对论</h3>
<p>首先狭义相对论只讨论惯性系中的物理问题，也就是静止参考系和与静止系保持匀速直线运动的参考系。</p>
<p>引入两条简单的基本原理：</p>
<ul>
<li>光速不变原理：在所有惯性系中，真空中的光速不变，且与光源运动无关</li>
<li>狭义相对性原理：在所有惯性系中，物理定律有相同的表达形式。</li>
</ul>
<p>光速不变的思想来自于19世纪末的大量物理实验，最终被爱因斯坦敏锐地提升到了原理的高度。</p>
<p>相对性原理通俗地说，就是在不同的惯性系中，物理公式在形式上应该是一样的，比如静止系里的公式如果是速度的一次方，到了运动系里就不应该变成了速度的二次方。</p>
<p>如果预先接受麦克斯韦方程组是正确的，在相对性原理的基础上，也可以根据真空介电常数和真空磁导率两个自然常量推导出光速不变性。</p>
<p>但是需要强调的是，狭义相对论并不依赖麦克斯韦方程是否正确，也就是说光速不变仍然是狭义相对论中一个独立的基本原理。</p>
<p>从狭义相对论的两条基本原理出发，我们可以推导出两个有相对运动参考系之间在时空坐标系上的变换关系。</p>
<p>在牛顿的绝对时空观中，即满足伽利略变换：</p>
<p><span class="math inline">\(x^{\prime}=x-vt\)</span></p>
<p><span class="math inline">\(y^{\prime}=y\)</span></p>
<p><span class="math inline">\(z^{\prime}=z\)</span></p>
<p><span class="math inline">\(t^{\prime}=t\)</span></p>
<p>其中<span
class="math inline">\(v\)</span>是参考系之间的相对速度，可以看到绝对时空观里，假设了两个参考系可以有完全相同的时间。</p>
<p>而在狭义相对论中，即满足洛伦兹变换：</p>
<p><span
class="math inline">\(x^{\prime}=\frac{x-vt}{\sqrt{1-v^2/c^2}}\)</span></p>
<p><span class="math inline">\(y^{\prime}=y\)</span></p>
<p><span class="math inline">\(z^{\prime}=z\)</span></p>
<p><span
class="math inline">\(t^{\prime}=\frac{t-\frac{vx}{c^2}}{\sqrt{1-v^2/c^2}}\)</span></p>
<p>其中<span
class="math inline">\(\gamma=1/\sqrt{1-v^2/c^2}=1/\sqrt{1-\beta^2}\)</span>称为洛伦兹因子，又名相对论因子，在相对论的公式中可以经常见到。</p>
<p>爱因斯坦在讲解相对论时，喜欢将静止系称为地面参考系，而把运动系看做一辆匀速行驶的火车，即火车参考系。</p>
<p>想象在火车上，从车底垂直向车顶发射一道光线。</p>
<p>根据光到达车顶的时间，可以得到车厢的高度是<span
class="math inline">\(c\Delta t^{\prime}\)</span>，其中<span
class="math inline">\(c\)</span>是光速，<span
class="math inline">\(\Delta t^{\prime}\)</span>是火车系里的时间。</p>
<p>在地面系看来，因为火车在运动，这道光线就不是垂直向上而是斜着地走了<span
class="math inline">\(c\Delta
t\)</span>，注意到这里运用了光速不变原理，<span
class="math inline">\(\Delta
t\)</span>是地面系的时间，而且在这个时间里在地面系看到火车也移动了<span
class="math inline">\(v\Delta t\)</span>的距离。</p>
<p>在地面系看来，火车移动的距离、车厢高度和光线斜着运动的长度构成了一个直角三角形。</p>
<p>根据勾股定理，就可以得到<span class="math inline">\((v\Delta
t)^2+(c\Delta t^{\prime})^2=(c\Delta t)^2\)</span>，即<span
class="math inline">\(\Delta t=\Delta t^{\prime}/\sqrt{1-v^2/c^2}=\gamma
\Delta t^{\prime}\)</span>。</p>
<p>这里不仅得到了相对论因子，而且因为<span class="math inline">\(\gamma
&gt; 1\)</span>，可以看到在地面系看来，它的时间<span
class="math inline">\(\Delta t\)</span>走得比火车上的时间<span
class="math inline">\(\Delta
t^{\prime}\)</span>要快，或者说地面系认为火车上的时钟走得比地面的时钟要慢，也就是“动钟变慢”的效应。</p>
<p>狭义相对论还可以得到一个重要的公式——质能方程：</p>
<p><span class="math inline">\(E=mc^2\)</span></p>
<p>这里的质量<span
class="math inline">\(m\)</span>是物质的动质量，会随着物体的运动速度变大而变大。</p>
<p>一个有静止质量的物体在加速到光速后，能量会变成无穷大的，预示了光速是物质世界的最大速度。</p>
<h3 id="狭义相对论的效应">狭义相对论的效应</h3>
<p>首先动钟变慢可以“合理”地解释中国古代神话故事，例如西游记里说的“天上一日、地上一年”。根据<span
class="math inline">\(\gamma =
365\)</span>，就可以得到神仙在天上是以<span
class="math inline">\(0.999996\)</span>倍光速在运动的。:)</p>
<p>除了动钟变慢的效应，狭义相对论还带来了“动尺缩短”的效应。例如，在地面系测量火车车厢的长度，会比火车系自己测到的车厢长度要短。</p>
<p>动尺缩短与同时的相对性有重要的联系。</p>
<p>因为测量长度最重要的是能够“同时”测得两个端点的空间坐标，而在地面系看来，火车系自己测量车厢的时候不是“同时”的，所以自然两个参考系所测量得到的长度也就是不一样的。</p>
<p>动钟变慢和动尺缩短也“提醒”了我们保持运动的重要性，因为运动可以让人活得更久、变得更瘦哦。:)</p>
<p>另一方面，初次认识相对论的人也会有很多困惑，比如其实明明可以发现很多的“超光速”现象。</p>
<p>用一支激光笔，假设它的光照射到了月球上，可以想象只要手轻轻地转动，在月球上的光斑就会非常快速地移动，甚至超过光速。</p>
<p>但这种“影子”式的超光速，并不与相对论有任何冲突，因为这里真实运动的物质“光”仍然是在保持光速运动的。</p>
<p>再比如我们在运动场看台上表演的“人浪”，如果大家配合出色，这个波浪围着运动场的传播速度也可以是非常快的，但是真实的观众只是原地站起来又坐下而已，当然没有发生真实物质上的“超光速”。</p>
<p>借用后来信息论的语言，其实狭义相对论表达了“信息”的传播速度是不可能超过光速的。</p>
<p>如果发生了超光速，就会对因果律的哲学产生颠覆。</p>
<p>因果律就是事件发生的因果关系，比如母鸡生小鸡，有因才有果。</p>
<p>用事件的语言来描述因果律，就是A事件的发生可以传递出来一种信息，这个信息的传播速度不会超过光速，而信息最终引发了B事件。</p>
<p>在科幻中，如果有某种超光速的能力，那在B事件发生时，就可以传递另一个信息回到A事件发生前，从而阻止了A事件的发生，这就是“外祖母悖论”。</p>
<p>从因果律的角度，一个观察者只能观察到一段时间内光速可传播范围内的事件，即以观察者为时空原点，可观察到的事件坐标要满足<span
class="math inline">\(x^2+y^2+z^2 \leq
c^2t^2\)</span>，这在四维时空中是一对“圆锥”，称为光锥。</p>
<p>在狭义相对论中，光锥表示的是与当前事件能够存在因果关系的所有时空点的集合，包括了过去光锥和未来光锥。</p>
<h3 id="狭义相对论的应用">狭义相对论的应用</h3>
<p>在20世纪初，爱因斯坦提出相对论之后，相对论特别是狭义相对论已经成为了现代物理学的基石。</p>
<p>在大众看来，可能觉得相对论离我们的生活还很遥远，但其实在现代生活中需要运用相对论的地方无处不在。</p>
<p>例如我们日常使用的定位服务，包括美国的GPS、中国的北斗等卫星导航系统，就离不开相对论的应用。</p>
<p>卫星导航系统的原理是用多个卫星发出的时空坐标，在接收器上通过“三角运算”来计算出所在点的坐标（经度、纬度、海拔高度以及时间）。</p>
<p>所以一般来说至少需要三颗卫星才能确定一个空间定位，当然如果能连接到的卫星越多，可以达到的精度就会越高。</p>
<p>因此导航卫星上都需要安装一个高精度的原子钟用于计时。</p>
<p>但是卫星在围绕地球运动，也就会产生“动钟变慢”的相对论效应。</p>
<p>现在来计算一下原子钟的时间漂移，即其引起的定位误差。</p>
<p>一般来说，导航卫星的高度大约2万公里，相应的速度大约为<span
class="math inline">\(4km/s\)</span>。</p>
<p>因此狭义相对论效应带来的“相对误差”为<span
class="math inline">\(\Delta = \gamma - 1 \approx v^2/2c^2 \approx
10^{-10}\)</span>。</p>
<p>也就是说，导航卫星如果每绕地球一周（大约12小时），就会因为“动钟变慢”的效应带来约4微秒的误差，乘以光速即对应了大约1200米的定位偏移。</p>
<p>所以如果现代卫星导航系统的定位精度是这么差的话，肯定就无法实用了。</p>
<h3 id="广义相对论">广义相对论</h3>
<p>狭义相对论是限定在惯性参考系里的讨论，如果是非惯性参考系呢？</p>
<p>这个问题要复杂得多，但爱因斯坦在发表狭义相对论之后十年就又发表了广义相对论。</p>
<p>广义相对论引入了“等效原理”，即非惯性系中感受到的惯性加速度是与万有引力的重力加速度在效果上是完全等效的，或者说作为引力“荷”的引力质量与力学中代表惯性的惯性质量是完全等效的。</p>
<p>可以想象，在一片没有任何天体的空间有一个静止的观察者A，同时有一个加速运动的电梯里面有观察者B。</p>
<p>在A看来因为电梯向上加速运动，B会受到一个虚拟的、向下的惯性力，而在B看来电梯是静止的，但是自己受到了一个持续的、向下的力，可以等效为电梯地面的“引力”，虽然电梯下方并没有真实的天体存在。</p>
<p>所以在电梯内部放下一个苹果，在观察者B看来也会和万有引力一样苹果加速落到地上。</p>
<p>等效原理确保了在一个封闭的电梯内，观察者是没有办法通过物理实验来判定自己到底是处于一个加速运动的空间里，还是处于一个引力场之中。</p>
<p>从广义相对论引申出，有质量的时空不是平直的、而是弯曲的，也就是说前面狭义相对论中认为不同空间点的时间流逝速度相同（平直时空）是不准确的。</p>
<p>广义相对论“意外地”统一了时空和引力，即引力其实是时空弯曲的几何效应。</p>
<p>对于时间来说，广义相对论可以带来称为引力红移的效应，也就是在引力场越强的地方，时间流逝就越慢。</p>
<p>例如利用两个非常精确的原子钟，可以测量发现海拔450米左右的东京晴空塔上时间每天比地面快4纳秒。</p>
<p>对于导航卫星来说，因为引力红移的效应，每天要快大约45微秒。</p>
<p>相比于每天慢约8微妙的狭义相对论“动钟变慢”的效应，导航卫星要考虑的广义相对论影响明显更为重要。</p>
<h3 id="时间是连续的吗">时间是连续的吗？</h3>
<p>在相对论中时间是连续的，但另一个现代物理学的支柱——量子理论，给世界带来了离散性。</p>
<p>根据广义相对论和量子理论，可以得到一个普朗克时间<span
class="math inline">\(𝑡_𝑝=(\hbar
𝐺/𝑐^5)^{1/2}=5.4×10^{−44}s\)</span>，这是现代物理学在理论上有效的最小时间尺度。</p>
<p>这对应着普朗克长度<span class="math inline">\(l_𝑝=(\hbar
𝐺/𝑐^3)^{1/2}=1.6×10^{−35}m\)</span>和普朗克能量<span
class="math inline">\(E_𝑝=(\hbar
𝑐^5/G)^{1/2}=1.22×10^{19}GeV\)</span>。这里<span
class="math inline">\(GeV\)</span>是一个能量单位，即<span
class="math inline">\(10^{9}\)</span>电子伏特。现在世界最大的大型强子对撞机（LHC）的能量也才到<span
class="math inline">\(TeV\)</span>量级，也就是<span
class="math inline">\(10^{12}\)</span>电子伏特。</p>
<p>从宇宙大爆炸假说出发，时间是存在一个“原点”的，也就是说在基础理论上，普朗克时间之外的宇宙所遵循的基本物理规律差不多已经被人类掌握了。</p>
<p>也就是说，在某种意义上，我们可以“准确地”推演出宇宙大爆炸后，质子等各种粒子的形成，氢氦等更多原子的形成，恒星的诞生，银河系等星系的诞生，直到现在所看到的整个宇宙。</p>
<img src="/2022/03/22/TimeTour/CMB_Timeline75_zh-cnversion.jpg" class="" title="宇宙大爆炸">
<p>但是，在普朗克尺度下，引力的量子效应将变得非常重要，而物理学上还并没有建立满足量子化的引力理论，也就是说在普朗克时间内，现在已知的所有物理理论是失效的，那里还是一片未知的“时空”。</p>
<p>普朗克时间只是现有物理理论失效的一个时间尺度，真实世界的时间是否可以继续细分甚至无限细分呢？我们并不知道。</p>
<p>所以在物理世界里，用数学表示的时间虽然形式上很简单，只是一条被称为时间轴的线，但是还没有人确定，这条线到底是连续的点、或者是离散的点所组成的。</p>
<h2 id="虚拟时间">虚拟时间</h2>
<p><em>数字时代搭建起了虚拟世界</em></p>
<h3 id="计算机里的时间">计算机里的时间</h3>
<p>计算机是用数字电路组成的。在数字电路里的一切运算都要按时钟频率来工作。</p>
<p>所以没有时钟，数字电路就无法工作。</p>
<p>例如一段电流信号，必须按照时钟周期，在相应的时间间隔内以“关”代表0，以“开”代表1。</p>
<p>在每一台现代计算机中都有“时钟”进行授时。</p>
<p>首先是通过硬件时钟RTC（Real-Time
Clock）来记录时刻，RTC是计算机中独立的一块硬件并自带电源，也就是说在电脑关机的情况下仍然可以工作。</p>
<p>RTC会持续记录一个比较粗略的时间，例如某年某月某日某时某分某秒，与电子表计时是类似的。</p>
<p>可以想象，硬件时钟不是特别的精确。例如因为硬件制作工艺不可能完全相同，不同计算机的硬件时间本身就不一样。</p>
<p>另一方面，个人电脑如果长期不使用，硬件时钟因为有计时误差，所以可以发现当再次开机时，电脑显示的时间会与真实世界的时间有比较大的差异。</p>
<p>不过，计算机显示的时间不是直接来自硬件，而是由操作系统提供的。</p>
<p>操作系统会通过硬件和软件提供一个“时钟”，称为操作系统时钟。</p>
<p>例如，操作系统会在开机时获取硬件时钟的时刻，再利用CPU计时器等记录程序运行的时段，从而得到一个实时的时间。</p>
<p>既然不同的计算机会有不同的时钟，为了统一全球计算机的时间，就需要一个标准时间来实现时间同步。</p>
<p>网络时间协议（NTP）就是用来使计算机时间同步化的一种协议，可以提供高精准度（毫秒级）的时间校正。</p>
<p>所以在实际上，操作系统会通过网络时间协议获取网络时间，并对当前计算机的时间进行校正，这样我们才能始终在自己电脑上看到跟“真实时间”一致的数字时间了。</p>
<p>可以设想，如果电脑长时间不联网，它的时间也会发生“漂移”。</p>
<p>这就是有时候在一些内部网络环境中，可以发现实时的调用请求与互联网时间存在“时差”的原因。</p>
<p>另外，位于陕西西安的中国科学院国家授时中心，承担着我国国家标准时间（北京时间）的产生、保持和发播任务，所以新闻联播在每天晚上7点播报的，其实是来自西安的“北京时间”。</p>
<h3 id="计算机时间的表示">计算机时间的表示</h3>
<p>一般在计算机中表示时间有两种常见的格式，一种是Unix时间戳。</p>
<p>Unix时间戳是一个有符号的整数，记录了世界协调时（UTC）时间上自1970年1月1日0时0分0秒以来的总秒数或总毫秒数。</p>
<p>例如世界时的1970年1月1日0时0分0秒就是0秒，北京时间的2022年2月2日22时22分22秒就是1643811742秒。</p>
<p>另一种格式是国际标准化组织制定的ISO-8601时间格式，可以比较友好地表示时间。</p>
<p>例如世界时的2022-02-02T22:22:22Z，北京时间（东八区）的2022-02-02T22:22:22+08:00。</p>
<p>目前看起来，时间在计算机中好像还是比较简单的。</p>
<p>但是其实时间表示还是带来了很多意想不到的问题，也就是程序bugs。</p>
<p>例如著名的千年虫问题：上个世纪囿于存储空间有限，再加上人们普遍觉得系统更新会很快，所以程序员大多采用两位数来表示年份，比如用06/15/98，而不是06/15/1998。但是当进入新世纪，到了2000年，系统只知道是01/01/00，不知道这是1900还是2000，就发生了程序错误。</p>
<p>类似千年虫的问题还有很多，例如早期计算机采用32位系统，时间戳也只使用了32位有符号整数，这样能表示的最大正整数是<span
class="math inline">\(2^{31}-1=2147483647\)</span>，对应的世界时即2038-01-19T03:14:07Z。也就是说，到了2038年1月19日，如果还有系统在使用32位时间戳的程序，类似千年虫的问题又要出现了。</p>
<p>更加意想不到的是，还有“闰秒”引起的bug。</p>
<p>因为原子钟测量得十分精确，我们其实可以发现由于地球自转的不规则和长期的自转减慢等效应，天文观测上的一年不是一个完全不变的周期时间，比如不同的回归年之间可以差出来那么一秒钟。</p>
<p>一般来说多年积累下来，这个差值会是多一秒，但也有可能少一秒，这就要想办法“置闰”到世界的标准时间中去，因此被称为闰秒。</p>
<p>对于到底要不要继续设置闰秒，国际上有很多的讨论，支持一方的主要观点是：如果不对闰秒进行任何处理，我们未来使用的计时系统就会与看到的自然现象不吻合了。</p>
<p>例如很多很多年以后，可能时钟显示早上8点，起床才发现太阳其实正在下山，因为精确的计算机时间与缓缓变化的自然周期时间之间在不断积累差异。</p>
<p>在2012年6月30日，当时UTC时间上插入了一个正闰秒。</p>
<p>不幸的是，由于Linux系统某些版本的闰秒处理逻辑，触发了一个死锁的bug，造成了大规模的Linux服务器内核死锁而宕机。</p>
<p>简单地说，Linux内核在处理闰秒时会先进行时钟中断，这里会给时钟加锁，而处理过程中会调用打印函数来记录日志。</p>
<p>不巧的是打印函数中本身又需要调用时钟，但是因为时钟已经加锁而且无法释放，最终就造成了内核死锁而整个系统宕机。</p>
<p>可以看到，与时间有关的问题所造成的软件缺陷是非常隐蔽、难以发现的，上面几个例子也体现出来很多的“意想不到”。所以程序员们，在编程中如果碰到跟时间有关的问题，请一定要多思考一下并保持警惕哦。</p>
<p>例如，假设要实现一个可以自恢复的数据服务，即先将调用请求存入日志缓存，然后再依次处理数据，这样可以在系统断电等意外发生时，就从未处理完成的日志恢复，重新开始处理数据，从而给用户提供一种安全可靠的服务。</p>
<p>一种很直观的实现方式，可能会选择以时间戳作为日志的标识键（或键值的一部分），这样只要在系统重启时搜索中断时间以后的所有日志，重新处理数据就可以了。</p>
<p>但是请别忘了，重启后的操作系统时间是可能发生变化的，甚至以时间戳表示的重启时间有可能还会小于记录的“中断时间”（操作系统时间穿越了），那些未处理的日志则有可能不仅不会被处理，反而会被新的请求给覆盖了。</p>
<h3 id="分布式系统的时间">分布式系统的时间</h3>
<p>分布式系统一般是利用网络进行消息传递，在多台计算机设备上实现数据一致性、故障容错性的复杂系统，从而解决服务高可靠高可用、性能瓶颈、设备异地分布等实际问题。</p>
<p>在分布式系统理论中，时间具有重要的意义。</p>
<p>首先如果在多台计算机中可以有且仅有唯一的全局时钟，可以保证在有限时间内完成计算，在有限时间内完成网络传输，被称为“同步系统”。</p>
<p>同步系统中发送出去的消息是有确定的返回时间的，所以只要大多数节点回复了相同的消息，就可以认为整个分布式系统达成了一致。</p>
<p>即在少数服从多数的情况下，同步系统可以提供50%的容错率。</p>
<p>反之称为“异步系统”，即就算本地时钟的差异小到可以忽略不计，但取决于带宽的拥塞程度、CPU的繁忙程度，互相之间发送消息的延迟还是非常地不确定。</p>
<p>在分布式系统理论中，由Fischer，Lynch和Patterson提出了著名的FLP不可能原理：即在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。</p>
<p>也就是说异步系统的容错率是0%。</p>
<p>一个形象的例子是“三个和尚没水喝”：A、B、C每天早上要决定去不去挑水，第一次A说去、B说不去，所以要等C来决定，但C还在睡觉（节点失效）；等了一天C睡醒后收到了B的消息决定不去，A还是要去，所以要等B决定，但B等得太久又睡着了；又等了一天B也睡醒了，想了想原本应该听A的所以又选择了去，C还是不去，所以最后还是要等A决定，但A等了两天实在太累了，也睡着了。这样循环往复，也就是说异步系统是不可能可靠的。</p>
<p>但实际情况还没有那么极端，如果系统可以保证在有限时间内完成计算和网络传输，但是这个时间无法被预先知道，或者系统只能在一段无法预知的时间内，保证计算和网络传输有一个时间上限，这样被称为部分同步系统。</p>
<p>因为网络分区等可能性存在，部分同步系统可以实现的容错率是33%。</p>
<p>例如，PBFT算法中可以使用<span
class="math inline">\(3f+1\)</span>节点，来允许<span
class="math inline">\(f\)</span>个节点失效甚至作恶。</p>
<p>既然分布式系统如此复杂，那今天在我们大量采用云服务的情况下，为什么开发分布式系统时，程序也能够运行得好好的？</p>
<p>没有感知并不代表问题不存在或者不重要，程序员使用的很多基础级软件，例如Consul、Kafka或者说分布式系统里一切看似中心化的部分，都已经使用了类似的机制，只不过是有人帮你把这些细节屏蔽掉了而已。</p>
<h3 id="区块链">区块链</h3>
<p>区块链就是在大量的分布式节点中用一个个区块串起来的唯一链条。</p>
<p>首先区块链网络是有多个区块链节点组成的，每个节点一般不存在谁比谁更特殊的关系，所以称之为对等节点和对等网络。</p>
<p>各个节点在收到对区块链系统的请求（一般称为交易）后，会首先通过数字签名验证交易的真实性，并通过自己的本地账本验证交易的有效性，同时向其他节点进行广播。</p>
<p>通过区块链的共识机制，可以对单笔或多笔交易打包形成的区块达成一致性共识，即多数节点都能认可此区块以及其中全部交易数据的正确性，并最终记入到自己的本地账本中。</p>
<p>区块链中的一个个区块通过哈希算法和哈希值依次串联，这也是区块链（Blockchain）名字的由来了。</p>
<p>所以链上的一个个区块就是一个个的时间戳，标识着这个系统的过去、现在、未来，从而协调整个以区块链为基础的分布式系统在“时间”上步调一致地前进。</p>
<p>可以说“区块即时刻、链即历史”。</p>
<p>在区块链系统中的物理时间概念已经模糊了，因为一般只需要通过区块号的大小，就可以快速辨别系统时间的先后。</p>
<p>例如以太坊在系统更新时，通常都不会指明具体的物理时间，而是以未来的某个区块号作为发版目标。</p>
<p>因此站在当前数字化的“元宇宙”时代，区块链可以说是为虚拟世界建立了一种时间基座。</p>
<p>从物质世界走进虚拟世界，我们的闲聊就到此结束吧，但时间永不停逝。</p>
]]></content>
      <categories>
        <category>Technologies</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>Philosophy</tag>
        <tag>Physics</tag>
      </tags>
  </entry>
  <entry>
    <title>在Excel中使用VB提取超链接</title>
    <url>/2024/10/11/Url-VBA-Excel/</url>
    <content><![CDATA[<h3 id="打开excel文档">打开Excel文档</h3>
<ol type="1">
<li><p>按“Alt+F11”进入VBA环境；</p></li>
<li><p>右击“Microsoft Excel 对象”；</p></li>
<li><p>从其扩展菜单中选择“插入”-“模块”项；</p></li>
<li><p>接着在打开的“模块1”编辑界面中，输入代码：</p></li>
</ol>
<span id="more"></span>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Function</span> GetActAddress(HlinkCell)</span><br><span class="line">Application.Volatile <span class="literal">True</span></span><br><span class="line"><span class="keyword">With</span> HlinkCell.Hyperlinks(<span class="number">1</span>)</span><br><span class="line">GetActAddress = IIf(.Address = <span class="string">&quot;&quot;</span>, .SubAddress, .Address)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>
<p>返回Excel编辑界面后，在超链接右侧的单元格，输入“=GetActAddress”的完整公式，即可提取超链接信息。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>用Ollama本地部署DeepSeek-R1模型</title>
    <url>/2025/06/04/Ollama-DeepSeek-R1/</url>
    <content><![CDATA[<p><code>Ollama</code>是专为本地机器便捷部署和运行大模型而设计的。</p>
<h2 id="部署ollama">1.部署<code>Ollama</code></h2>
<p>官网：<a href="https://ollama.com">https://ollama.com</a></p>
<p><code>Ollama</code>支持macOS、Linux、Windows等系统直接裸机部署，也支持Docker部署。</p>
<p>Linux服务器可以通过以下命令行一键下载和安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果没有报错，会提示<code>Ollama</code>的默认配置文件地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Created symlink /etc/systemd/system/default.target.wants/ollama.service → /etc/systemd/system/ollama.service.</span><br></pre></td></tr></table></figure>
<p>使用以下命令查看<code>Ollama</code>服务状态，如果显示<code>running</code>就说明没有问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status ollama</span><br></pre></td></tr></table></figure>
<p>查看安装版本号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ollama -v</span><br></pre></td></tr></table></figure>
<p>查看帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ollama -h</span><br></pre></td></tr></table></figure>
<p>另外也可以使用Docker一键部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama --restart always ollama/ollama</span><br></pre></td></tr></table></figure>
<h2 id="网络配置">2. 网络配置</h2>
<p><code>Ollama</code>安装后，默认只能本地访问。</p>
<p>如果需要局域网内其他机器也能访问，需要对<code>OLLAMA_HOST</code>进行配置，开启监听任何来源IP。</p>
<p>首先，需要编辑配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/ollama.service</span><br></pre></td></tr></table></figure>
<p>在<code>[Service]</code>下面修改，加上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Environment=&quot;OLLAMA_HOST=0.0.0.0:11434&quot;</span><br></pre></td></tr></table></figure>
<p>修改配置后，需要重启<code>Ollama</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart ollama</span><br></pre></td></tr></table></figure>
<p>安装成功后，可以在<strong>客户端</strong>的浏览器打开
http://your_ip:11434/，如果出现<code>Ollama is running</code>，说明服务已经成功运行。</p>
<p>如果提示访问不可用，应该是服务器防火墙限制了。</p>
<p>这时候，通过iptables，可以限制和允许特定IP地址对特定端口的访问。</p>
<p>如果要只允许特定IP地址对特定端口的访问，可以使用iptables的INPUT链和ACCEPT动作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport &lt;端口号&gt; -s &lt;IP地址&gt; -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>对于<code>Ollama</code>来说，端口号即<code>11434</code>。</p>
<p>然后，为了安全性，推荐添加另一条规则来阻止除特定IP地址以外的所有其他IP访问该端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport &lt;端口号&gt; -j DROP</span><br></pre></td></tr></table></figure>
<h2 id="部署基础模型如deepseek-r1">3. 部署基础模型，如DeepSeek-R1</h2>
<p>访问：<a
href="https://ollama.com/search">https://ollama.com/search</a></p>
<p>可以看到<code>Ollama</code>支持部署的模型列表，默认按热度排序。</p>
<p>这里选择deepseek-r1，可以看到deepseek-r1的介绍和各种不同大小的版本（2025年6月4日截图）：</p>

<p>根据安装服务器的规格，选择一个合适的模型，例如deepseek-r1:8b。</p>
<p>选择后，复制右上角的命令行，在服务器上运行，即可本地部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ollama run deepseek-r1</span><br></pre></td></tr></table></figure>
<p>等待安装完成，会出现命令行对话框，即可以开始使用了。</p>
<h2 id="安装对话软件">4. 安装对话软件</h2>
<p>可以在客户端安装对话软件，配置本地模型后，即可使用，例如：</p>
<ul>
<li><a href="https://chatboxai.app">Chatbox</a></li>
<li><a href="https://www.openwebui.com">Open WebUI</a></li>
</ul>
<p>对于cursor等可以配置本地模型的软件，选择<code>Ollama</code>模型即可。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Ollama</tag>
        <tag>DeepSeek</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark技术原理</title>
    <url>/2025/09/09/Spark/</url>
    <content><![CDATA[<p>本文整理了 Spark 的核心机制，涵盖 RDD
的设计思想、存储方式、不可变性、Stage 概念，以及 Spark 相对于 MapReduce
的改进。</p>
<p>来源于 Spark 最核心的两篇学术论文：</p>
<ol type="1">
<li><p><strong>Zaharia, M., et al. (2012). <em>Resilient Distributed
Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster
Computing</em>. NSDI.</strong> 这是 Spark 的“基础论文”，提出了 RDD
的概念。</p></li>
<li><p><strong>Zaharia, M., et al. (2010). <em>Spark: Cluster Computing
with Working Sets</em>. HotCloud.</strong> 这是 Spark
的早期论文，主要论证了基于内存的数据处理框架可以比 MapReduce
更快。</p></li>
</ol>
<span id="more"></span>
<h2 id="一spark-的技术原理">一、Spark 的技术原理</h2>
<p>在 Spark 出现之前，Hadoop MapReduce
已被广泛用于大规模批处理。但是在若干场景下，MapReduce
的开销和表达能力变成瓶颈：</p>
<ul>
<li><strong>迭代式算法昂贵</strong>：机器学习、图计算等需要多次扫描相同中间数据；MapReduce
每一步通常把中间结果写磁盘，I/O 成本极高。</li>
<li><strong>交互式分析迟滞</strong>：需要低延迟探索式查询时，MapReduce
高延迟不适合。</li>
<li><strong>编程表达力有限</strong>：MapReduce 编程模型主要围绕
map/reduce，两阶段模板不能自然表达复杂数据流。</li>
<li><strong>资源利用与调度粒度粗</strong>：每个作业开闭代价大，难以复用内存中已生成的数据。</li>
</ul>
<h3 id="核心抽象rddresilient-distributed-dataset">1.
核心抽象：RDD（Resilient Distributed Dataset）</h3>
<ul>
<li><p><strong>分布式集合</strong>：RDD
是一个不可变、分区化的数据集合，可以分布在集群不同节点上。</p></li>
<li><p><strong>容错机制</strong>：RDD
不依赖于数据复制（replication）来实现容错，而是通过
<strong>lineage（血缘记录）</strong>。即每个 RDD
都知道自己是如何由上游数据转换而来的，一旦分区丢失，可以通过 lineage
重新计算。</p></li>
<li><p><strong>操作</strong>分为两类：</p>
<ul>
<li><em>Transformations</em>（转换）：如
<code>map</code>、<code>filter</code>、<code>join</code>，延迟执行（lazy
evaluation）。</li>
<li><em>Actions</em>（动作）：如
<code>count</code>、<code>collect</code>、<code>save</code>，触发计算。</li>
</ul></li>
</ul>
<h3 id="内存计算">2. 内存计算</h3>
<ul>
<li>Spark 在执行时尽量将中间结果保存在 <strong>内存</strong>
中，避免频繁的磁盘读写。</li>
<li>对迭代式计算（机器学习、图计算）性能优势明显，因为可以反复访问缓存数据。</li>
</ul>
<h3 id="调度与执行">3. 调度与执行</h3>
<ul>
<li>Spark 用 <strong>有向无环图（DAG）</strong> 表示计算流程。</li>
<li>与 MapReduce 的两个阶段（map → reduce）不同，Spark 的 DAG
可以包含多个转换，系统会根据数据依赖关系自动划分 stage 并优化调度。</li>
</ul>
<h2 id="二rdd是什么">二、RDD是什么？</h2>
<ul>
<li><strong>逻辑数据集</strong>：RDD
表示一个不可变、分区化的分布式数据集合（logical
view），不是传统意义上总是把数据驻留在某个全局容器中。</li>
<li><strong>不可变（immutable）与纯函数式转换</strong>：所有转换（<code>map</code>、<code>filter</code>
等）产生新的 RDD，不修改原 RDD。</li>
<li><strong>延迟求值</strong>：transformations 是惰性的，action（如
<code>count</code>、<code>collect</code>）触发计算。</li>
<li><strong>lineage（血缘）</strong>：每个 RDD 保存如何从上游 RDD
生成自己的转换链（依赖信息），用于恢复和优化。</li>
<li><strong>StorageLevel</strong>：决定缓存策略（<code>MEMORY_ONLY</code>、<code>MEMORY_AND_DISK</code>、序列化等）。</li>
</ul>
<h3 id="抽象层面rdd-不是存数据的容器">1. 抽象层面：RDD
不是“存数据”的容器</h3>
<ul>
<li><p>RDD（Resilient Distributed
Dataset）这个名字容易让人误解，以为它像数据库表那样真正保存数据。</p></li>
<li><p><strong>实际上，RDD 更像是“数据的逻辑视图 +
元数据”</strong>，它自己并不直接保存数据，而是：</p>
<ul>
<li>保存数据的<strong>分区信息</strong>（partitions），</li>
<li>记录如何从上游数据计算得到这些分区的<strong>依赖关系（dependencies）</strong>
和 <strong>计算逻辑（compute 方法）</strong>，</li>
<li>保存数据在集群上的<strong>存储策略</strong>（storage
level：内存、磁盘、序列化等）。</li>
</ul></li>
</ul>
<p>换句话说：</p>
<blockquote>
<p>RDD = 数据分区描述 + lineage 依赖 + 计算方法 + 存储级别。</p>
</blockquote>
<h3 id="rdd-内部的数据结构源码角度">2. RDD
内部的数据结构（源码角度）</h3>
<p>在 Spark 源码中，RDD
是一个抽象类（<code>org.apache.spark.rdd.RDD[T]</code>），核心字段有：</p>
<ul>
<li><p><strong>partitions: Array[Partition]</strong></p>
<ul>
<li>描述 RDD 拥有多少个分区，每个分区是一个 <code>Partition</code>
对象（记录分区 ID、数据块的位置信息）。</li>
<li>分区是最小的调度单位。</li>
</ul></li>
<li><p><strong>dependencies: Seq[Dependency[_]]</strong></p>
<ul>
<li>记录 RDD 之间的依赖关系（窄依赖 / 宽依赖）。</li>
<li>这是 lineage 的核心，用来在容错时回溯。</li>
</ul></li>
<li><p><strong>compute(partition: Partition, context: TaskContext):
Iterator[T]</strong></p>
<ul>
<li>每个 RDD 子类都必须实现 <code>compute</code>
方法，定义如何计算某个分区的数据。</li>
<li>真正的数据不是提前存好的，而是 <strong>在 action 触发时，才通过
compute 动态计算生成</strong>。</li>
</ul></li>
<li><p><strong>storageLevel: StorageLevel</strong></p>
<ul>
<li>定义 RDD
的持久化策略（<code>MEMORY_ONLY</code>、<code>MEMORY_AND_DISK</code>、<code>DISK_ONLY</code>、序列化等）。</li>
<li>当用户调用 <code>persist()</code> 或 <code>cache()</code> 时，Spark
会把计算得到的数据缓存在内存（或磁盘）。</li>
</ul></li>
<li><p><strong>preferredLocations(partition: Partition):
Seq[String]</strong></p>
<ul>
<li>指示数据分区的最佳执行位置（数据本地性），帮助 Spark
调度时减少网络传输。</li>
</ul></li>
</ul>
<p>常见 RDD 子类（举例，有助理解数据来源）：</p>
<ul>
<li><code>HadoopRDD</code> / <code>NewHadoopRDD</code>：从 HDFS 或
Hadoop 输入格式读入。</li>
<li><code>MapPartitionsRDD</code> / <code>MappedRDD</code>：表示 map 或
mapPartitions 的结果（窄依赖）。</li>
<li><code>ShuffledRDD</code>：需要 shuffle 的中间结果（宽依赖）。</li>
<li><code>UnionRDD</code>、<code>FilteredRDD</code> 等。</li>
</ul>
<h3 id="存储时的物理形态">3. 存储时的物理形态</h3>
<ul>
<li><strong>默认</strong>：RDD
只是保持计算逻辑与分区描述，数据是在执行时通过 <code>compute</code>
生成。</li>
<li><strong>cache/persist</strong>：当用户 <code>cache()</code> 或
<code>persist()</code>，计算出的分区数据会被存储在每个 Executor 的
<strong>BlockManager</strong> 中。BlockManager
管理内存块、磁盘块（和序列化字节数组）并与 Master 协调位置元数据。</li>
</ul>
<p>当 RDD 被实际计算并缓存时，它的数据会以 <strong>JVM 对象</strong> 或
<strong>序列化字节数组</strong> 的形式存储：</p>
<ul>
<li><p><strong>MEMORY_ONLY</strong></p>
<ul>
<li>数据直接存成 JVM 对象（如 Scala 的 Array、Java 的对象）。</li>
<li>速度最快，但占用内存大。</li>
</ul></li>
<li><p><strong>MEMORY_AND_DISK</strong></p>
<ul>
<li>内存放不下的部分会溢写到磁盘，下次访问时从磁盘加载。</li>
</ul></li>
<li><p><strong>DISK_ONLY</strong></p>
<ul>
<li>全部存到磁盘。</li>
</ul></li>
<li><p><strong>MEMORY_ONLY_SER / MEMORY_AND_DISK_SER</strong></p>
<ul>
<li>数据序列化成字节数组存储，节省空间但 CPU 开销更大。</li>
</ul></li>
</ul>
<p>存储格式与 trade-off ：</p>
<ul>
<li><strong>JVM 对象（MEMORY_ONLY）</strong>：读取快，但占内存高，GC
成本需注意。</li>
<li><strong>序列化存储（MEMORY_ONLY_SER）</strong>：节省内存、提高网络传输效率，但序列化/反序列化消耗
CPU。推荐使用高效序列化（如 Kryo）。</li>
<li><strong>内存 +
磁盘（MEMORY_AND_DISK）</strong>：内存不足则溢出到磁盘。</li>
<li><strong>落盘（DISK_ONLY）</strong>：适用于内存非常紧张或极大数据。</li>
</ul>
<h3 id="小例子">4. 小例子</h3>
<p>假设有一段代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd1 = sc.textFile(<span class="string">&quot;hdfs://data/log.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> rdd2 = rdd1.map(_.split(<span class="string">&quot; &quot;</span>)(<span class="number">0</span>))   <span class="comment">// 取出第一列</span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd2.distinct()</span><br><span class="line">rdd3.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rdd1</code>：一个 <strong>HadoopRDD</strong>，分区信息来自
HDFS block。</li>
<li><code>rdd2</code>：一个 <strong>MappedRDD</strong>，保存了对
<code>rdd1</code> 的窄依赖，以及 <code>map</code> 的函数逻辑。</li>
<li><code>rdd3</code>：一个 <strong>DistinctRDD</strong>，依赖
<code>rdd2</code>（宽依赖）。</li>
<li><code>persist</code>：意味着当 <code>rdd3</code>
第一次计算出来时，会存到内存，不够就写磁盘。</li>
</ul>
<p>✅ <strong>总结一句话</strong>：</p>
<ul>
<li><strong>逻辑层面</strong>：RDD
是不可变的、分区化的逻辑数据集，核心由分区（partitions）、依赖（dependencies）、计算方法（compute）、存储策略（storage
level）组成。</li>
<li><strong>物理层面</strong>：RDD
本身不存数据，数据要么来自上游数据源（如 HDFS），要么由 lineage
计算得出；如果调用
<code>cache/persist</code>，才会把数据真正存到内存/磁盘。</li>
</ul>
<h3 id="什么叫不可变">5. 什么叫“不可变”？</h3>
<p><strong>RDD 的不可变性（immutability）</strong>
不是随便加的一个约束，而是 Spark 设计中至关重要的原则。</p>
<ul>
<li>当你对一个 RDD 做操作（比如
<code>map</code>、<code>filter</code>），你并不会在原有的 RDD
上修改数据。</li>
<li>相反，会生成一个新的 RDD（带有 lineage，指向上游 RDD
和转换函数）。</li>
<li>原始 RDD 始终保持不变。</li>
</ul>
<p>👉
类似函数式编程里的“不可变对象”，所有的转换操作都是“生成新对象”。</p>
<h4 id="简化容错机制">（1）简化容错机制</h4>
<ul>
<li><p>如果 RDD
是可变的，每个节点可能会以不同方式修改它，一旦出错就很难恢复原始状态。</p></li>
<li><p>由于 RDD 是不可变的，Spark 可以放心地只存 lineage：</p>
<ul>
<li>出错时，重新从最初数据 + 操作链计算，结果必然一致。</li>
</ul></li>
<li><p>这让 <strong>lineage 容错机制</strong> 成为可能。</p></li>
</ul>
<h4 id="简化并行计算">（2）简化并行计算</h4>
<ul>
<li>在分布式环境下，多个 task 可能同时访问同一个 RDD。</li>
<li>不可变性保证了不会有写冲突（write conflict）。</li>
<li>不需要加锁或复杂的同步机制，降低了并发编程的难度。</li>
</ul>
<h4 id="提升调度与优化的可预测性">（3）提升调度与优化的可预测性</h4>
<ul>
<li>因为 RDD 的内容不会被随意修改，Spark 调度器可以对整个 DAG
进行全局优化。</li>
<li>每个 stage
的依赖关系是确定的、纯函数式的，这让任务划分、数据本地性调度、重算等更可控。</li>
</ul>
<h4
id="更安全的缓存cachepersist">（4）更安全的缓存（Cache/Persist）</h4>
<ul>
<li>如果 RDD
是可变的，缓存的数据可能随时被别的任务修改，导致结果不一致。</li>
<li>不可变性保证了：一旦缓存，数据就不会变，后续访问结果始终一致。</li>
<li>这就是 Spark <code>cache()</code> / <code>persist()</code>
可以放心使用的根本原因。</li>
</ul>
<h4 id="函数式编程思想的延续">（5）函数式编程思想的延续</h4>
<ul>
<li>Spark 的 API 设计深受 Scala 和函数式编程影响。</li>
<li>不可变数据结构（immutable collections）+ 纯函数（map、filter） →
提供声明式编程模型。</li>
<li>开发者只描述“做什么”，而不用关心“怎么执行”，更容易表达复杂的数据流逻辑。</li>
</ul>
<h3 id="rdd-的局限与-spark-演进dataframe-dataset">6. RDD 的局限与 Spark
演进（DataFrame / Dataset）</h3>
<ul>
<li><strong>表达能力与优化空间</strong>：RDD
提供自由度高但缺乏全局语义。Spark 后来引入 DataFrame/Dataset + Catalyst
优化器与 Tungsten 执行层，在
SQL/结构化数据上能做更深度的算子融合、物理计划优化、代码生成，从而获得更好性能。
<ul>
<li>DataFrame：一张“分布式表”，类似数据库表，行列结构清晰，每列有数据类型。</li>
<li>Dataset：在 DataFrame
的基础上，提供了编译时类型检查和更强的面向对象支持。</li>
<li>这两者让 Spark 可以对“表结构”和“查询计划”做更高级的优化（不像 RDD
只是黑盒函数）。</li>
</ul></li>
<li><strong>什么时候还用
RDD？</strong>：低层控制（自定义序列化、精细分区策略、复杂非结构化流处理）或学习/研究原理时仍然有价值。但生产
ETL/SQL/ML 工作流推荐首选 DataFrame / Dataset。</li>
</ul>
<p>Catalyst 是 Spark SQL 的
<strong>查询优化器</strong>，它的作用类似数据库里的优化器。工作分四层：</p>
<ul>
<li><strong>解析</strong>：把 SQL / DataFrame
操作翻译成逻辑计划（Logical Plan）。</li>
<li><strong>规则优化</strong>：应用一系列规则（比如常量折叠、谓词下推、投影剪裁、算子融合），得到更优的逻辑计划。</li>
<li><strong>物理计划生成</strong>：根据数据大小和集群情况选择具体算子实现，比如选择
broadcast join 还是 shuffle join。</li>
<li><strong>代码生成（Codegen）</strong>：将最终的物理计划转化为高效的
JVM 字节码，避免解释执行带来的函数调用开销。</li>
</ul>
<p>这样，Spark 就能像数据库一样，自动为 SQL/DataFrame
查询生成更高效的执行方式。</p>
<p>Catalyst 负责“计划优化”，而 <strong>Tungsten
专注于“执行效率”</strong>：</p>
<ul>
<li><strong>内存管理优化</strong>：绕过 JVM 的对象存储和
GC，使用二进制格式直接管理内存。</li>
<li><strong>缓存效率</strong>：利用 CPU Cache
Line，压缩存储，减少内存访问开销。</li>
<li><strong>向量化执行</strong>：批量处理数据，减少函数调用开销。</li>
<li><strong>代码生成（Whole-Stage
Codegen）</strong>：把一系列算子融合成一段连续的 Java
方法，避免频繁的函数切换（类似手工写的 for 循环一样高效）。</li>
</ul>
<h2 id="三基于lineage实现容错机制">三、基于Lineage实现容错机制</h2>
<ul>
<li>RDD 是不可变的，且对每个 RDD 保存生成它的依赖链（lineage）。</li>
<li>当某个分区数据丢失（executor 崩溃、磁盘坏块等），Spark
不依赖副本去恢复，而是根据 lineage
重新计算该分区所需的上游分区并重放计算。</li>
</ul>
<h3 id="传统方式的容错问题">1. 传统方式的容错问题</h3>
<p>在分布式系统里，节点和数据分区经常会丢失。两种常见的容错手段是：</p>
<ul>
<li><strong>复制（Replication）</strong>：比如 HDFS，通常存 3
份副本，任何一份坏掉还能用别的副本。优点是恢复快，缺点是存储开销大（3
倍以上）。</li>
<li><strong>检查点（Checkpointing）</strong>：定期把中间状态保存下来，出错时从检查点恢复。优点是安全，缺点是频繁
I/O 成本高。</li>
</ul>
<p>MapReduce 主要依赖复制来保证容错，每一步计算的输出写入
HDFS，带来了大量的磁盘读写。</p>
<h3 id="spark-的改进lineage-血缘机制">2. Spark 的改进：Lineage
血缘机制</h3>
<p>Spark 提出了一种更轻量的思路：</p>
<ul>
<li><p><strong>RDD 是不可变的</strong>。当你对一个 RDD 做
<code>map</code> 或 <code>filter</code>
时，不会改变原数据，而是生成一个新的 RDD。</p></li>
<li><p><strong>RDD 记录“怎么来的”而不是“结果是什么”</strong>。</p>
<ul>
<li>每个 RDD 都保存了自己是由哪个上游 RDD，通过什么转换算子生成的（例如
<code>RDD2 = RDD1.map(f)</code>）。</li>
<li>这条“转换链”就是 <strong>lineage（血缘）</strong>。</li>
</ul></li>
<li><p><strong>容错时重算</strong>：</p>
<ul>
<li>如果某个分区丢失，Spark 不会去找副本，而是回溯
lineage，重新执行丢失分区所需的那部分计算。</li>
<li>因为 lineage
是逻辑依赖关系图（DAG），系统只需重算必要的分区，而不是整个数据集。</li>
</ul></li>
</ul>
<h3 id="原理举例">3. 原理举例</h3>
<p>假设有这样一条计算链：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">RDD1 (HDFS 原始数据)</span><br><span class="line">   ↓ map</span><br><span class="line">RDD2</span><br><span class="line">   ↓ filter</span><br><span class="line">RDD3</span><br><span class="line">   ↓ reduceByKey</span><br><span class="line">RDD4 (最终结果)</span><br></pre></td></tr></table></figure>
<p>如果在计算 <code>RDD4</code> 时，某个分区丢了：</p>
<ol type="1">
<li>Spark 会查看 <code>RDD4</code> 的 lineage，发现它来自
<code>RDD3.reduceByKey</code>。</li>
<li>然后回溯到 <code>RDD3</code>，再发现它来自
<code>RDD2.filter</code>。</li>
<li>继续回溯到 <code>RDD2.map</code>，最后到
<code>RDD1</code>（原始数据还在 HDFS，有副本保障）。</li>
<li>Spark 就只需要重新从 <code>RDD1</code> 的相关分区开始，沿着 lineage
重新执行 map → filter → reduceByKey，恢复丢失的分区。</li>
</ol>
<blockquote>
<p>注意：只需
<strong>重算丢失的那几个分区</strong>，而不是整个数据集。</p>
</blockquote>
<h3 id="为什么高效">4. 为什么高效？</h3>
<ul>
<li><strong>省存储</strong>：不需要存 3 份副本，只要保存 lineage
信息即可。</li>
<li><strong>省 I/O</strong>：不用每步都落盘，只有在需要 checkpoint
或最终结果时才写磁盘。</li>
<li><strong>重算局部</strong>：出错时只重算丢失的分区，而不是整个任务。</li>
<li><strong>适合大数据场景</strong>：大多数大数据任务是“确定性转换”的（pure
function），lineage 保证了重算结果和原来一致。</li>
</ul>
<h3 id="特殊情况宽依赖和窄依赖">5. 特殊情况：宽依赖和窄依赖</h3>
<ul>
<li><strong>窄依赖（Narrow Dependency）</strong>：每个子 RDD
分区依赖于上游 RDD 的少数几个分区（如
<code>map</code>、<code>filter</code>），恢复时只需重算少量数据。</li>
<li><strong>宽依赖（Wide Dependency）</strong>：子 RDD
的每个分区依赖上游 RDD 的多个分区（如
<code>groupByKey</code>、<code>reduceByKey</code>），恢复时可能要重算较大范围数据。</li>
</ul>
<p>Lineage 很长或依赖中包含大量宽依赖时，重算代价会变高。Spark
提供两种缓解方式：</p>
<ul>
<li><strong>Checkpoint（检查点）</strong>：把 RDD 写入可靠存储（如
HDFS），并截断 lineage。适合长迭代或多阶段计算的中间结果持久化。</li>
<li><strong>缓存（persist）</strong>：把数据放进
BlockManager，避免每次都重复计算（不是容错的替代，但能减少重算频次）。</li>
</ul>
<p>✅ <strong>总结一句话</strong>： Spark 通过 <strong>lineage</strong>
记录 RDD 的生成逻辑，避免了昂贵的副本存储；一旦分区丢失，就沿着 lineage
重算必要的数据分区，从而实现了
<strong>轻量、高效的容错机制</strong>。</p>
<h2 id="四stage与task">四、Stage与Task</h2>
<p>用户通过 transformations 构建一棵有向无环图（DAG），节点是
RDD，边是依赖。Spark 的 DAGScheduler 会把这个逻辑 DAG
划分成若干物理阶段（stages）。</p>
<ul>
<li><strong>Stage</strong>：一段可以在不进行 shuffle
的情况下连续执行的转换链（由窄依赖组成）。遇到
<strong>宽依赖</strong>（需要 shuffle）时，Spark 会把 DAG
在该点切分为多个 Stage。</li>
<li>因此：多个连续的 <code>map</code>/<code>filter</code> 可以形成一个
Stage；带
<code>reduceByKey</code>、<code>groupByKey</code>、<code>join</code>
的节点会触发 shuffle，成为 Stage 边界。</li>
</ul>
<h3 id="rdd-转换-vs-stage">1. RDD 转换 vs Stage</h3>
<ul>
<li><p><strong>RDD 转换（transformation）</strong></p>
<ul>
<li>比如
<code>map</code>、<code>filter</code>、<code>reduceByKey</code>，每个转换都会生成一个新的
RDD。</li>
<li>转换只是逻辑上的描述（DAG 中的一个节点）。</li>
</ul></li>
<li><p><strong>Stage</strong></p>
<ul>
<li>是 Spark
执行调度的<strong>物理执行单元</strong>，由一组可以并行计算的任务（tasks）组成。</li>
<li>一个 Stage 对应于 DAG 中一段连续的、<strong>只有窄依赖（narrow
dependency）</strong> 的 RDD 转换链。</li>
<li>当遇到 <strong>宽依赖（wide dependency）</strong> 时（例如
<code>reduceByKey</code>、<code>groupByKey</code>、<code>join</code>），Spark
必须执行 <strong>shuffle</strong>，这会触发 Stage 的划分。</li>
</ul></li>
</ul>
<p>👉 换句话说： <strong>RDD 转换是逻辑层面的数据依赖，Stage
是物理层面的执行划分。</strong></p>
<h3 id="stage-划分规则">2. Stage 划分规则</h3>
<p>Spark 根据 <strong>RDD 依赖关系</strong> 来划分 Stage：</p>
<ul>
<li><p><strong>窄依赖 (Narrow Dependency)</strong></p>
<ul>
<li>子 RDD 的每个分区依赖于父 RDD 的少数几个分区（比如
<code>map</code>、<code>filter</code>）。</li>
<li>这些操作可以在同一个 Stage 内完成。</li>
</ul></li>
<li><p><strong>宽依赖 (Wide Dependency)</strong></p>
<ul>
<li>子 RDD 的每个分区依赖父 RDD 的多个分区（比如
<code>reduceByKey</code>、<code>groupByKey</code>）。</li>
<li>必须经过 <strong>shuffle</strong>，不同节点之间需要交换数据。</li>
<li>发生 shuffle 的地方，就是 Stage 的边界。</li>
</ul></li>
</ul>
<h3 id="举个例子">3. 举个例子</h3>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd1 = sc.textFile(<span class="string">&quot;hdfs://data/log.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> rdd2 = rdd1.map(_.split(<span class="string">&quot; &quot;</span>)(<span class="number">0</span>))      <span class="comment">// 窄依赖</span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd2.filter(_.nonEmpty)        <span class="comment">// 窄依赖</span></span><br><span class="line"><span class="keyword">val</span> rdd4 = rdd3.map((_, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> rdd5 = rdd4.reduceByKey(_ + _)        <span class="comment">// 宽依赖（触发 shuffle）</span></span><br><span class="line"><span class="keyword">val</span> rdd6 = rdd5.mapValues(_ / <span class="number">2</span>)          <span class="comment">// 窄依赖</span></span><br><span class="line">rdd6.saveAsTextFile(<span class="string">&quot;hdfs://data/out&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Stage
1</strong>：<code>rdd1 → rdd2 → rdd3 → rdd4</code>（全部是窄依赖，可以流水线式执行）</li>
<li><strong>Stage
2</strong>：<code>rdd5</code>（<code>reduceByKey</code> 引发
shuffle，需要新的 Stage）</li>
<li><strong>Stage 3</strong>：<code>rdd6</code> → 输出（窄依赖）</li>
</ul>
<p>所以最终 DAG 会被拆成 <strong>3 个 Stage</strong>。</p>
<h3 id="stage-和-task-的关系">4. Stage 和 Task 的关系</h3>
<ul>
<li><p><strong>Stage</strong>：一组逻辑上可以并行执行的任务集合。</p></li>
<li><p><strong>Task</strong>：在一个具体分区上的计算单元。</p>
<ul>
<li>一个 Stage 会被分解为多个 Task，每个 Task 处理一个分区的数据。</li>
<li>Task 在 Executor 上并行执行。Stage 的并行度等于参与 Stage
的分区数。</li>
</ul></li>
</ul>
<p>举例：</p>
<ul>
<li>如果 Stage 有 100 个分区，就会产生 100 个 Task，分布到不同的
Executor 上执行。</li>
</ul>
<h3 id="为什么-shuffle-代价昂贵">5 为什么 Shuffle 代价昂贵？</h3>
<p>Shuffle 涉及
<strong>网络传输</strong>（跨节点数据移动）、<strong>磁盘
I/O</strong>（map 端写本地文件，reduce
端读取）、<strong>序列化/反序列化</strong>、以及
<strong>合并/排序</strong>（sort-based
shuffle）。这些都显著增加延迟与资源消耗：</p>
<ul>
<li>使用 <code>reduceByKey</code>（在 map 端进行 combine）代替
<code>groupByKey</code>，减少数据发送量。</li>
<li>通过合理的 <code>partitionBy</code> 与自定义 Partitioner
控制数据分布（避免数据倾斜）。</li>
<li>对小表使用 <strong>广播 Join（broadcast join）</strong>，避免
shuffle 大表。</li>
<li>合理使用
<code>mapPartitions</code>、避免频繁创建对象来减少序列化开销。</li>
</ul>
<h2 id="五总结与-mapreduce-相比的改进">五、总结：与 MapReduce
相比的改进</h2>
<h3 id="数据存储与迭代计算">1. 数据存储与迭代计算</h3>
<ul>
<li><strong>MapReduce</strong>：每一步的中间结果都会写入
HDFS，后续步骤需要重新从磁盘加载。适合单次批处理，但对迭代算法（如
PageRank、K-means）效率低下。</li>
<li><strong>Spark</strong>：将中间结果保存在内存中（也可选择落盘），极大提高了迭代计算和交互式计算性能。</li>
</ul>
<h3 id="编程模型">2. 编程模型</h3>
<ul>
<li><strong>MapReduce</strong>：程序员必须围绕“map +
reduce”两种操作来设计任务，表达能力有限。</li>
<li><strong>Spark</strong>：提供了更丰富的 API，包括
<code>map</code>、<code>filter</code>、<code>reduceByKey</code>、<code>join</code>
等算子，并支持 DAG 计算图，编程抽象更自然。</li>
</ul>
<h3 id="容错机制">3. 容错机制</h3>
<ul>
<li><strong>MapReduce</strong>：通过数据复制（replication，通常是 3 份
HDFS 副本）保证容错，但带来存储开销。</li>
<li><strong>Spark</strong>：通过 lineage
记录计算逻辑，只需在故障时重算丢失分区，不必复制全部数据，存储和恢复更高效。</li>
</ul>
<h3 id="性能">4. 性能</h3>
<ul>
<li><strong>MapReduce</strong>：磁盘 I/O 成本高，延迟大。</li>
<li><strong>Spark</strong>：内存计算 + DAG
优化，大幅提升性能。在论文实验中，Spark 在迭代式任务上可比 Hadoop
MapReduce 快 10~100 倍。</li>
</ul>
<h3 id="应用场景">5. 应用场景</h3>
<ul>
<li><strong>MapReduce</strong>：适合大规模批处理，如日志分析、数据清洗。</li>
<li><strong>Spark</strong>：既能做批处理，又能做迭代计算、流处理（Spark
Streaming）、SQL 查询（Spark
SQL）、机器学习（MLlib）、图计算（GraphX），生态更丰富。</li>
</ul>
<h3 id="总结">6. 总结</h3>
<ul>
<li>Spark 的核心创新是 <strong>RDD 抽象</strong>，用 lineage
提供了高效的容错方式。</li>
<li>Spark 将 <strong>内存计算 + DAG 执行模型</strong>
引入分布式计算，大幅减少了磁盘 I/O 的开销。</li>
<li>相比 MapReduce，Spark 在
<strong>迭代计算、交互式分析、多场景支持</strong>
等方面有了质的提升。</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>RDD</tag>
      </tags>
  </entry>
</search>
