<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heshengpku.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="发布者: 币学院 发表于: 2017-7-4 16:40 原作者: 张海宁、陈家豪来自: 亨利笔记 1. 概述 本文将介绍如何使用 Docker 容器技术来建立起一个多节点Fabric集群，并且描述在集群上如何进行基本的操作，如chaincode的生命周期维护等。文中采用Fabric 1.0的端到端（e2e_cli）示例作为基础来说明原理。本文提供是手动配置的方法，后续将介绍利用容器平台">
<meta property="og:type" content="article">
<meta property="og:title" content="超级账本Fabric 1.0 多节点集群的部署">
<meta property="og:url" content="https://heshengpku.github.io/2017/11/06/Fabric-Multiple-Nodes/index.html">
<meta property="og:site_name" content="何晟">
<meta property="og:description" content="发布者: 币学院 发表于: 2017-7-4 16:40 原作者: 张海宁、陈家豪来自: 亨利笔记 1. 概述 本文将介绍如何使用 Docker 容器技术来建立起一个多节点Fabric集群，并且描述在集群上如何进行基本的操作，如chaincode的生命周期维护等。文中采用Fabric 1.0的端到端（e2e_cli）示例作为基础来说明原理。本文提供是手动配置的方法，后续将介绍利用容器平台">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://heshengpku.github.io/2017/11/06/Fabric-Multiple-Nodes/4peer1orderLocal.jpg">
<meta property="og:image" content="https://heshengpku.github.io/2017/11/06/Fabric-Multiple-Nodes/4peer1order.jpg">
<meta property="article:published_time" content="2017-11-06T05:08:00.000Z">
<meta property="article:modified_time" content="2024-02-20T07:24:52.000Z">
<meta property="article:author" content="He, Sheng">
<meta property="article:tag" content="Blockchain">
<meta property="article:tag" content="Hyperledger">
<meta property="article:tag" content="Fabric">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://heshengpku.github.io/2017/11/06/Fabric-Multiple-Nodes/4peer1orderLocal.jpg">

<link rel="canonical" href="https://heshengpku.github.io/2017/11/06/Fabric-Multiple-Nodes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>超级账本Fabric 1.0 多节点集群的部署 | 何晟</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">何晟</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">HE, SEHNG</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>Commonweal 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://heshengpku.github.io/2017/11/06/Fabric-Multiple-Nodes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="He, Sheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何晟">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          超级账本Fabric 1.0 多节点集群的部署
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-06 13:08:00" itemprop="dateCreated datePublished" datetime="2017-11-06T13:08:00+08:00">2017-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-20 15:24:52" itemprop="dateModified" datetime="2024-02-20T15:24:52+08:00">2024-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><em>发布者: 币学院 发表于: 2017-7-4 16:40 原作者: 张海宁、陈家豪来自:
亨利笔记</em></p>
<h4 id="概述">1. 概述</h4>
<p>本文将介绍如何使用 Docker
容器技术来建立起一个多节点<code>Fabric</code>集群，并且描述在集群上如何进行基本的操作，如<code>chaincode</code>的生命周期维护等。文中采用Fabric
1.0的端到端（e2e_cli）示例作为基础来说明原理。本文提供是手动配置的方法，后续将介绍利用容器平台（如
K8s 等）自动部署超级账本的方式。</p>
<span id="more"></span>
<img src="/2017/11/06/Fabric-Multiple-Nodes/4peer1orderLocal.jpg" class="" title="单节点下的Fabric网络结构图">
<p>Fabric
源码中包含一个简单的e2e单机部署示例，方便用户理解、研究和开发应用。如图1.1所示，在单个机器节点上通过
docker-compose 建立了5个节点的Fabric网络，每个节点都是由单独的 Docker
容器来模拟。其中 peer0 和 peer1 是同属于 org1 的节点，peer2 和 peer3
是同属于 org2 的节点，它们都加入了相同的 channel 中，并在该 channel
中进行交易，而 orderer 则为该 channel 中的交易提供排序服务。</p>
<img src="/2017/11/06/Fabric-Multiple-Nodes/4peer1order.jpg" class="" title="多节点下的Fabric网络结构图">
<p>虽然e2e_cli的示例比较简单，但它把多个节点混合部署在一起，无法区分哪些配置对应哪个节点。另外，在实际场景中，Fabric
节点可能会由不同的组织分别拥有和维护，peers 和 orderer
必然会分布在不同的物理节点上，因此多节点的Fabric
部署成为需要解决的问题</p>
<h4 id="单机运行hyperledger-fabric实例">2. 单机运行Hyperledger
Fabric实例</h4>
<p>需要安装Go，并下载Fabric源码 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install golang</span><br><span class="line">mkdir gocode/src/github.com/hyperledger/</span><br><span class="line">cd gocode/src/github.com/hyperledger/</span><br><span class="line">git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure> 记得配置环境变量
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.profile</span><br><span class="line">export GOPATH=$HOME/gocode</span><br></pre></td></tr></table></figure> 下载docker
image，在<code>gocode/src/github.com/hyperledger/fabric</code>下执行
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make docker</span><br></pre></td></tr></table></figure> 可能需要执行 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git branch --all</span><br><span class="line">git fetch</span><br><span class="line">make clean</span><br><span class="line">make dist-clean</span><br><span class="line">make configtxgen</span><br><span class="line">make docker</span><br><span class="line">make peer-docker</span><br><span class="line">make orderer-docker</span><br><span class="line">make couchdb</span><br></pre></td></tr></table></figure> PS:
如果<code>make docker</code>运行错误，重新输入<code>make docker</code>运行</p>
<!-- 也可以用docker命令手动安装相关镜像，注意`fabric`相关镜像没有`latest`版本
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull hyperledger/fabric-orderer:x86_64-1.0.1</span><br><span class="line">docker pull hyperledger/fabric-peer:x86_64-1.0.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rename it to <span class="string">&#x27;latest&#x27;</span></span></span><br><span class="line">docker tag hyperledger/fabric-orderer:x86_64-1.0.1 hyperledger/fabric-orderer:latest</span><br><span class="line">docker tag hyperledger/fabric-peer:x86_64-1.0.1 hyperledger/fabric-peer:latest </span><br></pre></td></tr></table></figure>
<p>--&gt;</p>
<p>也可以进入到<code>fabric/examples/e2e_cli</code>目录下，运行<code>./download-dockerimages.sh</code>来下载必要镜像。镜像下载完成后，就可以通过
<code>docker save</code>
命令把镜像打包成压缩文件，传送到各个VM。当VM接收到压缩文件后，可以通过
<code>docker load</code>
来解压和导入镜像。如果有私有的容器镜像仓库registry，如 Harbor
等，也可以把镜像推送到私有registry，再从各个机器中拉取。</p>
<p>通过以下命令来保存所有 <code>tag</code> 含有 <code>fabric</code>
标识的镜像到名字为 <code>images</code> 的压缩文件中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save $(docker images | grep fabric | awk &#123;‘print $1’&#125; ) -o images</span><br></pre></td></tr></table></figure> 生成
<code>images</code>
文件后，就可以通过scp把它拷贝到还没有镜像的其他节点中，例如，地址为
10.112.122.6
的节点需要安装以上镜像，可以通过以下命令把<code>images</code> 远程拷贝到
10.112.122.6 的home目录下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp images root@10.112.122.6:~</span><br></pre></td></tr></table></figure> 然后在 10.112.112.6
这台主机的home目录上运行： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i images</span><br></pre></td></tr></table></figure> 等待一段时间后, 通过
<code>docker images</code> 命令就能查看到相关镜像的信息。</p>
<p>测试安装结果 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd examples/e2e_cli</span><br><span class="line">./network_setup.sh up</span><br></pre></td></tr></table></figure> 进入到 <code>fabric/example/e2e_cli</code>
文件夹中，<code>network_setup.sh</code> 是一键测试脚本，该脚本启动了6个
docker 容器，其中有4个容器运行 peer 节点和1个容器运行 orderer
节点，它们组成一个Fabric集群。另外, 还有一个 cli 容器用于执行创建
channel 、加入 channel 、安装和执行chaincode 等操作。测试用的 chaincode
定义了两个变量，在实例化的时候给这两个变量赋予了初值，通过invoke操作可以使两个变量的值发生变化。</p>
<p>如果正常则显示如下内容，即在单机运行4+1的Fabric实例 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=== All GOOD，End-2-End execution completed ===</span><br></pre></td></tr></table></figure>
许多的调试信息具体可参考 e2e_cli 目录下的 <code>script/script.sh</code>
文件。</p>
<p>可以关闭Fabric网络 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network_setup.sh down</span><br></pre></td></tr></table></figure></p>
<h4 id="把单节点e2e_cli范例改为多节点的大致步骤">3.
把单节点e2e_cli范例改为多节点的大致步骤</h4>
<ol type="1">
<li>准备环境</li>
</ol>
<p>运行Fabric节点需要依赖以下工具：</p>
<ol type="a">
<li><p>Docker：用于管理Fabric镜像以及运行 peer 和 orderer
等组件</p></li>
<li><p>Docker-compose： 用于配置 Fabric 容器</p></li>
<li><p>Fabric源码：源码提供了用于生成证书和配置 channel
的工具和测试代码</p></li>
<li><p>Go语言开发环境：源码的工具编译依赖于 Go 语言</p></li>
</ol>
<ol start="2" type="1">
<li>配置多节点Fabric集群</li>
</ol>
<p>在单节点e2e_cli示例中，所有节点部署在同一个 docker-compose
的内部网络中，通过容器的7051端口进行通信。但是在多节点的情况下，容器之间不能进行直接通讯，因此需要把容器的7051端口映射到宿主机上，通过各个宿主机的7051端口来实现节点间通信。我们在每个节点中修改
docker-compose.yaml 中的 service 定义，在不同节点只启动需要的
service。例如，在节点1中只启动peer0 的 service，在节点5中仅启动 orderer
等。</p>
<ol start="3" type="1">
<li>启动多节点Fabric集群</li>
</ol>
<p>在各个节点上配置好 Fabric
的启动环境后，需要依次登录到节点上通过docker-compose up的方式启动 Fabric
节点。由于启动环境有依赖关系，如 peer1 以 peer0
作为发现节点，因此需要先启动 peer0 再启动 peer1 。</p>
<ol start="4" type="1">
<li>配置channel</li>
</ol>
<p>在 Fabric 中，channel
代表了一个私有的广播通道，保证了消息的隔离性和私密性，它由 orderer
来管理。channel 中的成员共享该 channel
的账本，并且只有通过验证的用户才能在 channel 中进行交易，与一个 channel
相关的属性记录在该channel的初始区块中，可通过 reconfiguration
交易进行更改。channel的初始区块由 create channel 交易生成，peer 向
orderer 发送该交易时会带有的 config.tx 文件，该文件定义 channel
的相关属性。</p>
<ol start="5" type="1">
<li>发布chaincode</li>
</ol>
<p>chaincode 是开发人员按照特定接口编写的智能合约，通过 SDK 或者 CLI 在
Fabric 的网络上安装并且初始化后，该应用就能访问网络中的共享账本。</p>
<p>chaincode 的生命周期如下:</p>
<ol type="a">
<li>Install（安装）</li>
</ol>
<p>chaincode 要在 Fabric 网络上运行，必须要先安装在网络中的 peer
上，安装同时注明版本号保证应用的版本控制。</p>
<ol start="2" type="a">
<li>Instantiate（实例化）</li>
</ol>
<p>在 peer 上安装 chaincode 后，还需要实例化才能真正激活该 chaincode
。在实例化的过程中，chaincode
就会被编译并打包成容器镜像，然后启动运行。若 chaincode
在实例化的过程中更新了数据状态，如给某个变量赋予初始值，则该状态变化会被记录在共享账本中。每个应用只能被实例化一次，实例化可在任意一个已安装该
chaincode 的 peer 上进行。</p>
<ol start="3" type="a">
<li>Invoke和query （调用和查询）</li>
</ol>
<p>chaincode 在实例化后，用户就能与它进行交互，其中 query
查询与应用相关的状态（即只读），而 invoke 则可能会改变其状态。</p>
<ol start="4" type="a">
<li>Upgrade（升级）</li>
</ol>
<p>在 chaincode 添加新功能或出现 bug 需要升级时，可以通过 upgrade
交易来实现。这时需要把新的代码通过install交易安装到正在运行该
chaincode的 peer
上，安装时需注明比先前版本更高的版本号，接下来只需要向任意一个安装了新代码的
peer 发送 upgrade 交易就能更新 chaincode ，chaincode
在更新前的状态也会得到保留。</p>
<h4 id="部署hyperledger-fabric-v1.0多节点集群文档一">4. 部署Hyperledger
Fabric v1.0多节点集群（文档一）</h4>
<ol type="1">
<li>准备工作</li>
</ol>
<p>先在5台计算机（虚拟机）上按上面步骤布置好Hyperledger
Fabric环境，并确认<code>ssh server</code>开启 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br></pre></td></tr></table></figure>
如果没有安装server端，可以 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>
虚拟机可以直接克隆生成五个新的虚拟机。其中4台虚拟机运行 peer
节点，另外一台运行 orderer 节点，为其他的四个节点提供order服务。</p>
<p>在<code>VirtualBox</code>中<code>控制&gt;设置&gt;网络</code>选择<code>Host-Only</code>模式</p>
<p>在控制台中输入 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure> 可以查看本机IP地址</p>
<p>将5台虚拟机分别作为<code>order</code> <code>peer0.org1</code>
<code>peer1.org1</code> <code>peer0.org2</code>
<code>peer1.org2</code>节点，并记住对应的IP地址，假设依次为
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.99.101</span><br><span class="line">192.168.99.102</span><br><span class="line">192.168.99.103</span><br><span class="line">192.168.99.104</span><br><span class="line">192.168.99.105</span><br></pre></td></tr></table></figure> 2. 生成公私钥、证书、创世区块</p>
<p>在任意VM上运行 <code>fabric/examples/e2e_cli</code> 目录下的
<code>generateArtifacts.sh</code> 脚本 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd examples/e2e.cli</span><br><span class="line">./generateArtifacts.sh mychannel</span><br></pre></td></tr></table></figure>
可生成两个目录，它们分别为 <code>channel-artifacts/</code> 和
<code>crypto-config/</code>，两个目录的结构分别如下: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-channel-artifacts</span><br><span class="line">    -channel.tx</span><br><span class="line">    -genesis.block</span><br><span class="line">    -Org1MSPanchors.tx</span><br><span class="line">    -Org2MSPanchors.tx</span><br></pre></td></tr></table></figure>
上述目录里的文件用于 <code>orderer</code> 创建 <code>channel</code> ,
它们根据 <code>configtx.yaml</code> 的配置生成。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-crypto-config</span><br><span class="line">    -ordererOrganizations</span><br><span class="line">    -peerOrganizations</span><br></pre></td></tr></table></figure>
上述目录里面有 <code>orderer</code> 和 <code>peer</code>
的证书、私钥和以及用于通信加密的<code>tls</code>证书等文件，它通过
<code>configtx.yaml</code> 配置文件生成。</p>
<p>该命令只需在某个VM上运行一次，其他VM上就不需要运行。</p>
<ol start="2" type="1">
<li><code>order</code>节点设置</li>
</ol>
<p>设置节点的<code>docker-compose</code>文件</p>
<p>e2e_cli中提供了多个yaml文件，我们可以基于docker-compose-cli.yaml文件创建：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp docker-compose-cli.yaml docker-compose-peer.yaml</span><br></pre></td></tr></table></figure>
然后修改docker-compose-peer.yaml，去掉orderer的配置，只保留一个peer和cli，因为我们要多级部署，节点与节点之前又是通过主机名通讯，所以需要修改容器中的host文件，也就是extra_hosts设置，修改后的peer配置如下：
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer0.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">    <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;orderer.example.com:192.168.99.102&quot;</span></span><br></pre></td></tr></table></figure>
同样，cli也需要能够和各个节点通讯，所以cli下面也需要添加extra_hosts设置，去掉无效的依赖，并且去掉<code>command</code>这一行，每个peer都会有个对应的客户端，也就是cli，所以只需要去手动执行一次命令，而不是自动运行。修改后的cli配置如下：
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cli:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cli</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-tools</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">GOPATH=/opt/gopath</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ID=cli</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;orderer.example.com:192.168.99.101&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer0.org1.example.com:192.168.99.102&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer1.org1.example.com:192.168.99.103&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer0.org2.example.com:192.168.99.104&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer1.org2.example.com:192.168.99.105&quot;</span></span><br></pre></td></tr></table></figure>
在单机模式下，4个peer会映射主机不同的端口，但是我们在多机部署的时候是不需要映射不同端口的，所以需要修改<code>base/docker-compose-base.yaml</code>文件，将所有peer的端口映射都改为相同的：
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7051</span><span class="string">:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7052</span><span class="string">:7052</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7053</span><span class="string">:7053</span></span><br></pre></td></tr></table></figure>
设置orderer节点的docker-compose文件,与创建peer的配置文件类似，复制一个yaml文件出来进行修改：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp docker-compose-cli.yaml docker-compose-orderer.yaml</span><br></pre></td></tr></table></figure>
<code>orderer</code>服务器上只需要保留order设置，其他peer和cli设置都可以删除。orderer可以不设置extra_hosts</p>
<ol start="3" type="1">
<li>分发配置文件</li>
</ol>
<p>前面操作都是在<code>orderer</code>节点上完成的，接下来需要将这些文件分发到另外4台服务器上</p>
<p>先登录<code>peer0.org1</code>节点，将本地的e2e_cli文件夹删除：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm e2e_cli –R</span><br></pre></td></tr></table></figure>
然后再登录到<code>orderer</code>服务器上，退回到<code>examples</code>文件夹
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r e2e_cli UserName@192.168.99.102:/gocode/src/github.com/hyperledger/fabric/examples/</span><br></pre></td></tr></table></figure>
我们在前面配置的就是<code>peer0.org1</code>上的节点，所以复制过来后不需要做任何修改。</p>
<p>再次运行scp命令，复制到<code>peer1.org1</code>上，然后我们需要对docker-compose-peer.yaml做一个小小的修改，将启动的容器改为peer1.org1.example.com，并且添加peer0.org1.example.com的IP映射，对应的cli中也改成对peer1.org1.example.com的依赖(各种文件索引位置都要修改)。这是修改后的peer1.org1.example.com上的配置文件：
复制代码 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">        <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">        <span class="attr">service:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;orderer.example.com:192.168.99.101&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;peer0.org1.example.com:192.168.99.102&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">cli:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cli</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-tools</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">GOPATH=/opt/gopath</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_ID=cli</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/server.crt</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/server.key</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;orderer.example.com:192.168.99.101&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer0.org1.example.com:192.168.99.102&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer1.org1.example.com:192.168.99.103&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer0.org2.example.com:192.168.99.104&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;peer1.org2.example.com:192.168.99.105&quot;</span></span><br></pre></td></tr></table></figure>
接下来继续使用<code>scp</code>命令将orderer上的文件夹传送给<code>peer0.org2</code>和<code>peer1.org2</code>，然后也是修改一下docker-compose-peer.yaml文件，使得其启动对应的<code>peer</code>节点。</p>
<ol start="4" type="1">
<li>启动<code>Fabric</code></li>
</ol>
<p>现在所有文件都已经准备完毕，可以启动我们的Fabric网络了。</p>
<p>首先启动<code>orderer</code>节点，在<code>orderer</code>服务器上运行：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-orderer.yaml up –d</span><br></pre></td></tr></table></figure>
运行完毕后我们可以使用<code>docker ps</code>看到运行了一个名字为<code>orderer.example.com</code>的节点。</p>
<p>然后启动<code>peer</code>节点，切换到<code>peer0.org1.example.com</code>服务器，启动本服务器的peer节点和cli：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-peer.yaml up –d</span><br></pre></td></tr></table></figure> 运行完毕后使用docker
ps应该可以看到2个正在运行的容器。</p>
<p>接下来依次在另外3台服务器运行启动peer节点容器的命令： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-peer.yaml up –d</span><br></pre></td></tr></table></figure>
现在整个<code>Fabric</code>
4+1服务器网络已经成型，接下来是创建<code>channel</code>和运行<code>ChainCode</code>。</p>
<p>切换到<code>peer0.org1.example.com</code>服务器上，使用该服务器上的cli来运行创建<code>Channel</code>和运行<code>ChainCode</code>的操作</p>
<p>首先进入cli容器： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> 进入容器后,可以看到命令提示变为：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@b41e67d40583:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br></pre></td></tr></table></figure>
说明已经以root的身份进入到cli容器内部。官方已经提供了完整的创建<code>Channel</code>和测试<code>ChainCode</code>的脚本，并且已经映射到cli容器内部，所以只需要在cli内运行如下命令：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/script.sh mychannel</span><br></pre></td></tr></table></figure>
那么该脚本就可以一步一步的完成创建通道，将其他节点加入通道，更新锚节点，创建<code>ChainCode</code>，初始化账户，查询，转账，再次查询等链上代码的各个操作都可以自动化实现。直到最后，系统提示：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">===================== All GOOD, End-2-End execution completed =====================</span><br></pre></td></tr></table></figure>
说明4+1的<code>Fabric</code>多机部署成功了。我们现在是在<code>peer0.org1.example.com</code>的cli容器内，我们也可以切换到<code>peer0.org2.example.com</code>服务器，运行<code>docker ps</code>命令，可以看到本来是2个容器的，现在已经变成了3个容器</p>
<h4 id="部署hyperledger-fabric-v1.0多节点集群文档二">5. 部署Hyperledger
Fabric v1.0多节点集群（文档二）</h4>
<p>此文档和上一节的方法基本相同，细节之处可做参考选择，方便理解。</p>
<p>以下各VM的工作目录为： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">GOPATH/src/github.com/hyperledger/fabric/examples/e2e_cli</span></span><br></pre></td></tr></table></figure>
可在任意VM上运行以下命令，生成构建 Fabric 网络所需的成员证书等必要材料：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash generateArtifacts.sh</span><br></pre></td></tr></table></figure> 该命令只需在某个VM上运行一次，其他VM上就不需要运行。</p>
<p>在运行该命令的VM中会生成 <code>channel-artifacts</code> 和
<code>crypto-config</code> 目录，需要把它们拷贝到其他VM的 e2e_cli
目录下，如果在VM中已经存在该目录，则先把目录删除。当每个VM中都有统一的
<code>channel-artifacts</code> 和 <code>crypto-config</code>
目录后接下来就开始配置 compose 文件。</p>
<p>I. VM1的配置：</p>
<ol type="1">
<li>修改 <code>/etc/hosts</code> 的映射关系</li>
</ol>
<p>因为容器内部通过域名的方式访问 orderer , 因此需要通过修改 /etc/hosts
把orderer 的域名和 ip 地址对应起来，在文件中添加: <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.69</span>   <span class="string">orderer.example.com</span></span><br></pre></td></tr></table></figure> 2.
修改<code>docker-compose-cli.yaml</code></p>
<p>在默认的情况下，<code>docker-compose-cli.yaml</code>会启动6个service（容器），它们分别为
<code>peer0.org1.example.com</code>、
<code>peer1.org1.example.com</code>、
<code>peer0.org2.example.com</code>、
<code>peer1.org2.example.com</code>、 <code>orderer.example.com</code>
和
<code>cli</code>，因为每台机器只运行与之对应的一个节点，因此需要注释掉无需启动的
service。</p>
<ol type="1">
<li><p>除 peer0.org1.example.com 和 cli service 外，其他 service
全部注释。</p></li>
<li><p>在 cli 的 volumes 中加入映射关系： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-./peer/:/opt/gopath/src/github.com/hyperledger/fabric/peer/</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>注释 cli 中的 depends_on 和 command : <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line">  <span class="comment">#- orderer.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">  <span class="comment">#- peer1.org1.example.com</span></span><br><span class="line">  <span class="comment">#- peer0.org2.example.com</span></span><br><span class="line">  <span class="comment">#- peer1.org2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#command: /bin/bash -c &#x27;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#x27;</span></span><br></pre></td></tr></table></figure>
之前我们把容器中的工作目录挂载到宿主机的 <code>e2e_cli/peer</code>
目录下, 是因为在执行 create channel 的过程中，orderer 会返回一个
mychannel.block 作为 peer 加入 channel 的依据，其他的 peer
要加入到相同的 channel 中必须先获取该 mychannel.block
文件。因此，通过挂载目录从宿主机就能方便获得 mychannel.block
，并且把它传输到其他的 VM 上。</p></li>
</ol>
<p>挂载 <code>/etc/hosts</code> 的目的是把主机中 orderer.exmaple.com 与
IP 地址10.112.122.69 的映射关系带入容器中,目的是让 cli 能通过域名访问
orderer 。在实际环境中，建议通过配置 DNS 而不是修改
<code>/etc/hosts</code> 文件（下同）。</p>
<ol start="3" type="1">
<li>修改 <code>base/peer-base.yaml</code>，添加 volumes： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure>
这样 peer 容器能通过域名访问orderer了。</li>
</ol>
<ol start="2" type="I">
<li>VM2配置：</li>
</ol>
<ol type="1">
<li>修改 /etc/hosts 的映射关系</li>
</ol>
<p>peer1.org1.example.com 使用了 peer0.org1.example.com
作为它的初始化节点，因此需要在主机中还需要加入 VM1 的 ip 地址。
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.69</span>   <span class="string">orderer.example.com</span></span><br><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.144</span>  <span class="string">peer0.org1.example.com</span></span><br></pre></td></tr></table></figure> 2. 修改docker-compose-cli.yaml</p>
<ol type="1">
<li><p>类似VM1，除 peer1.org1.example.com 和 cli service 外，其他
service 全部注释。</p></li>
<li><p>在 cli 的 volumes 中加入映射关系： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-./peer/:/opt/gopath/src/github.com/hyperledger/fabric/peer/</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>注释cli中的 depends_on 和 command: <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line"> <span class="comment">#- orderer.example.com</span></span><br><span class="line"> <span class="comment">#- peer0.org1.example.com</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line"> <span class="comment">#- peer0.org2.example.com</span></span><br><span class="line"> <span class="comment">#- peer1.org2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#command:/bin/bash -c &#x27;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改cli中的环境变量 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<ol start="3" type="1">
<li>修改base/peer-base.yaml，同VM1的修改。</li>
</ol>
<ol start="3" type="I">
<li>VM3配置：</li>
</ol>
<ol type="1">
<li>修改 /etc/hosts 的映射关系 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.69</span>      <span class="string">orderer.example.com</span></span><br></pre></td></tr></table></figure></li>
<li>修改docker-compose-cli.yaml</li>
</ol>
<ol type="1">
<li><p>VM3 上运行 peer2 节点，因此除 peer0.org2.example.com 和 cli
service 外,其他 service 全部注释。</p></li>
<li><p>在cli的 volumes 中加入映射关系： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-./peer/:/opt/gopath/src/github.com/hyperledger/fabric/peer/</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>注释cli中的 depends_on 和 command : <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line"> <span class="comment">#- orderer.example.com</span></span><br><span class="line"> <span class="comment">#- peer0.org1.example.com</span></span><br><span class="line"> <span class="comment">#- peer1.org1.example.com</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line"> <span class="comment">#- peer1.org2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#command:/bin/bash -c &#x27;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改cli中的环境变量 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;</span></span><br><span class="line"><span class="string">CORE_PEER_ADDRESS=peer0.org2.example.com:7051</span></span><br><span class="line"><span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<ol start="3" type="1">
<li>修改base/peer-base.yaml，同VM1。</li>
</ol>
<ol start="4" type="I">
<li>VM4配置：</li>
</ol>
<ol type="1">
<li>修改/etc/hosts的映射关系</li>
</ol>
<p>peer1.org2.example.com 使用了 peer0.org2.example.com
作为它的初始化节点，因此需要在映射关系中加入 VM3 的 ip 地址
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.69</span>       <span class="string">orderer.example.com</span></span><br><span class="line"><span class="number">10.112</span><span class="number">.122</span><span class="number">.12</span>       <span class="string">peer0.org2.example.com</span></span><br></pre></td></tr></table></figure> 2. 修改docker-compose-cli.yaml</p>
<ol type="1">
<li><p>VM4运行peer3，因此除peer1.org2.example.com和cliservice
外,其他service全部注释</p></li>
<li><p>在cli的volumes中加入映射关系： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-./peer/:/opt/gopath/src/github.com/hyperledger/fabric/peer/</span></span><br><span class="line"><span class="string">-/etc/hosts:/etc/hosts</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改cli中的 depends_on 和 command: <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">depends_on:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line"><span class="comment">#command:/bin/bash -c &#x27;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改cli中的环境变量 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;</span></span><br><span class="line"><span class="string">CORE_PEER_ADDRESS=peer1.org2.example.com:7051</span></span><br><span class="line"><span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<ol start="3" type="1">
<li>修改base/peer-base.yaml，同VM1。</li>
</ol>
<p>V. VM5配置如下：</p>
<ol type="1">
<li>修改docker-compose-cli.yaml</li>
</ol>
<p>除orderer外的其他 service 全部注释，即只启动 orderer 。</p>
<ol start="6" type="I">
<li>启动多节点Fabric集群</li>
</ol>
<ol type="1">
<li>启动orderer</li>
</ol>
<p>进入到 VM5 的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure>
此时终端会出现大量记录，当出现<code>Beginning to service requests</code>时，orderer启动完成。有了
<code>orderer</code> 之后，就可以通过它来管理 <code>channel</code>
。</p>
<ol start="2" type="1">
<li>启动 org1的第一个节点 peer0 ，即 peer0.org1.example.com</li>
</ol>
<p>进入到 VM1 的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure> 此时通过docker ps -a 命令可以看到成功启动了
peer0.org1.example.com 和 cli 两个容器。</p>
<p>接下来实现创建 channel 、加入 channel 和安装 chanicode
。首先进入到cli容器内： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> cli 与 orderer 之间的通讯使用 tls
加密，设置环境变量 ORDERER_CA 以作建立握手的凭证： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/cacerts/ca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure>
注：以下所有涉及到 ORDERER_CA 环境变量的命令都需预先给该变量赋值。</p>
<p>进入到 cli 容器后会自动跳转到
/opt/gopath/src/github.com/hyperledger/fabric/peer
目录，即工作目录，通过compose文件的配置，该目录映射为宿主机的
/e2e_cli/peer 。</p>
<p>在工作目录下输入以下命令，创建名为 mychannel 的 channel ：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls --cafile $ORDERER_CA</span><br></pre></td></tr></table></figure> <code>channel</code>
创建成功后，会在当前目录下生成<code>mychannel.block</code>文件。每个peer
在向 orderer 发送 <code>join channel</code>
交易的时候，需要提供这个文件才能加入到 <code>mychannel</code>
中，因此运行在其他 VM 上的 peer 需要得到 <code>mychannel.block</code>
文件来加入到 <code>mychannel</code> 中。由于之前的文件映射关系，
<code>mychannel.block</code> 文件可在宿主机的 <code>e2e_cli/peer</code>
目录下获取，这时可以通过宿主机把 <code>mychannel.block</code> 拷贝到
VM2, VM3, VM4的 <code>e2e_cli/peer</code> 目录下。</p>
<p>把 peer0.org1.example.com 加入到 mychannel 中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure> 更新
mychannel 中 org1 的 anchor peer 的信息： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile $ORDERER_CA</span><br></pre></td></tr></table></figure> 安装 chaincode
示例 chaincode_example02 到 peer0.org1.example.com 中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -nmycc -v 1.0 -p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure>
这时候 chaincode 代码已经安装到了 peer0
节点上，但并未实例化运行。接下来先配置好其他节点。</p>
<ol start="3" type="1">
<li>启动 org1 的第二个节点 peer1，即 peer1.org1.example.com</li>
</ol>
<p>进入到VM2的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure> 进入到 cli 容器内部： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> 由于前面已经把
mychannel.block 拷贝到了 VM2 的 e2e_cli/peer 目录下，因此
mychannel.block 可通过容器内的
<code>/opt/gopath/src/github.com/hyperledger/fabric/peer</code>
目录访问。</p>
<p>把 peer1.org1.example.com 加入到 mychannel 中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure> 安装
chaincode_example02 到 peer1.org1.example.com 中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -nmycc -v 1.0 –p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure> 4.
启动 org2 的第一个节点 peer2，即 peer0.org2.example.com</p>
<p>进入到 VM3 的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose-f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure> 进入到cli容器内部： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure>
把peer0.org2.example.com加入到mychannel中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure> 更新
mychannel 中 org2 的 anchor peer 的信息： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile $ORDERER_CA</span><br></pre></td></tr></table></figure> 安装
chaincode_example02 到 peer0.org2.example.com 中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -nmycc -v 1.0 -p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure> 5.
启动org2的第二个节点peer3 ，即 peer1.org2.example.com</p>
<p>进入到 VM4 的 <code>fabric/examples/e2e_cli</code> 目录下，运行
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose-f docker-compose-cli.yaml up -d</span><br></pre></td></tr></table></figure> 首先进入到cli容器内部： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cli bash</span><br></pre></td></tr></table></figure> 把
peer1.org2.example.com 加入到 mychannel 中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure> 安装
chaincode_example02 到 peer1.org2.example.com 中： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -nmycc -v 1.0 -p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure> 6.
运行chaincode</p>
<p>通过前面的步骤，整个多节点Fabric网络已经运行起来了，每个peer都加入到了标识为
<code>mychannel</code> 的 channel 中，并且都安装了一个简单的 chaincode
(该 chaincode 在安装时被标识为 <code>mycc</code> ) 。下面步骤运行和维护
chaincode。</p>
<ol type="1">
<li>实例化chaincode</li>
</ol>
<p>chaincode 的实例化可在任意 peer 上进行，并且 <strong>chaincode
只能被实例化一次</strong>，下面以在 peer0.org2.example.com 上实例化
chaincode 为例。</p>
<p>首先登录VM3并进入到cli容器内部运行： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile $ORDERER_CA -C mychannel-nmycc -v 1.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]&#125;&#x27; -P &quot;OR     (&#x27;Org1MSP.member&#x27;,&#x27;Org2MSP.member&#x27;)&quot;</span><br></pre></td></tr></table></figure>
这时候会构建一个新的容器来运行chaincode，通过<code>docker ps -a</code>
命令可以看到新容器： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev-peer0.org2.example.com-mycc-1.0</span><br></pre></td></tr></table></figure>
上述实例化中，我们对两个变量‘a’和‘b’分别赋予初值100和200，通过 channel
它们的值被同步到了其他peer的账本上，即使其他peer还没有构建运行 chaincode
的容器。</p>
<ol start="2" type="1">
<li>执行 chaincode 的 query 交易</li>
</ol>
<p>由于 chaincode 已经被 peer0.org2.example.com 实例化了，因此其他 peer
不需要再次实例化它了，但是 chaincode 的状态（world
state）却是已经记录在各个peer的账本上的。</p>
<p>接下来我们在peer0.org1.example.com上查看chaincode的状态，登录到VM1上并进入cli容器内部执行：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -nmycc -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> 上面的命令查看 mycc 中变量 a 的值，由于在 peer 跟
chaincode 发生互动之前还不存在运行 chaincode
的容器，因此第一次交互的时候需要先构建运行 chaincode
的容器，等待一段时间后返回结果：100 。</p>
<p>此时通过 <code>docker ps -a</code> 命令能看到新容器： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev-peer0.org1.example.com-mycc-1.0</span><br></pre></td></tr></table></figure>
该值与实例化时的赋值一致，说明 peer0.org1 和 peer0.org2 两个 peer
可以相互通信。</p>
<ol start="3" type="1">
<li>执行chaincode的invoke交易</li>
</ol>
<p>接下来，我们执行一个 invoke 交易，使得变量 a 向变量 b 转帐
20，得到最终值为["a":"80","b":"220"]。</p>
<p>登录到VM2并进入到cli容器中中通过以下命令查询mycc的状态：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> 稍作等待后返回结果为100，下面执行 invoke 交易，改变 a
的值为 80 ： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -oorderer.example.com:7050  --tls --cafile $ORDERER_CA -C mychannel -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;20&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> (4) 再次执行 chaincode 的 query 交易</p>
<p>在peer1.org1.example.com 上重复以上查看 chaincode
的步骤，得到返回结果为 80
，说明测试通过，至此，Fabric网络构建完毕，各个部件工作正常。</p>
<ol start="7" type="1">
<li>更新chaincode</li>
</ol>
<p>通过 <code>channel upgrade</code> 命令可以使得 <code>chaincode</code>
更新到最新的版本，而低版本 chaincode 将不能再使用。</p>
<p>登录到VM1的 cli 容器中再次安装 chaincode_example02
，但赋予它更高的版本号 2.0： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -n mycc -v 2.0 -p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure> 在 VM1 的 cli 容器升级
chaincode ,添加两个变量 ‘c’和‘d’: <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode upgrade -o  orderer.example.com:7050 --tls --cafile $ORDERER_CA -n mycc -v 2.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;c&quot;, &quot;10&quot;,&quot;d&quot;,&quot;20&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure>
等待一段时间后，可以通过<code>docker ps -a</code>
来查看新容器构建的容器,该容器的名称为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev-peer0.org1.example.com-mycc-2.0</span><br></pre></td></tr></table></figure>
通过以下命令查询c的变量： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode -n mycc -C mychannel -v 2.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;c&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> 返回结果为10</p>
<p>再次查询a的变量： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode -n mycc -C mychannel -v 2.0 -c&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure> 返回结果为80，说明更新 chaincode
成功。</p>
<p>这时候对账本的修改会通过 orderer 同步到其他 peer 上，但是在其他 peer
上将无法查看或更改 chaincode 的状态，因为它们还在使用旧版的 chaincode
，所以其他 peer 要想正常访问还需再次安装 chaincode
，并且设置相同的版本号 ( chaincode
代码没发生改变，只是安装时版本号更新为 2.0 )，命令如下：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">peerchaincode install -n mycc -v 2.0 –p \</span><br><span class="line">github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Blockchain/" rel="tag"><i class="fa fa-tag"></i> Blockchain</a>
              <a href="/tags/Hyperledger/" rel="tag"><i class="fa fa-tag"></i> Hyperledger</a>
              <a href="/tags/Fabric/" rel="tag"><i class="fa fa-tag"></i> Fabric</a>
              <a href="/tags/Docker/" rel="tag"><i class="fa fa-tag"></i> Docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/11/01/Ethereum/" rel="prev" title="以太坊私有链搭建操作指南">
      <i class="fa fa-chevron-left"></i> 以太坊私有链搭建操作指南
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/01/02/Fabric-Chaincode/" rel="next" title="Fabric chaincode开发调试">
      Fabric chaincode开发调试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%9C%BA%E8%BF%90%E8%A1%8Chyperledger-fabric%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.</span> <span class="nav-text">2. 单机运行Hyperledger
Fabric实例</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="He, Sheng"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">He, Sheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/heshengpku" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;heshengpku" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:heshengpku@gmail.com" title="E-Mail → mailto:heshengpku@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://scholar.google.com/citations?user=2BKQWbIAAAAJ" title="Google → https:&#x2F;&#x2F;scholar.google.com&#x2F;citations?user&#x3D;2BKQWbIAAAAJ" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/heshengpku/" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;heshengpku&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://orcid.org/0000-0002-7142-8990" title="ORCiD → https:&#x2F;&#x2F;orcid.org&#x2F;0000-0002-7142-8990" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>ORCiD</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/sheng-he-14" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;sheng-he-14" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>Zhihu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="">
      
        <option value="zh-CN" data-href="/2017/11/06/Fabric-Multiple-Nodes/" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/2017/11/06/Fabric-Multiple-Nodes/" selected="">
          English
        </option>
      
    </select>
  </div>

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He, Sheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">55k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">3:18</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
